<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">

  <script type="text/javascript">
    var CoCat = {
      isHome: false,
      isPost: true,
      isArchive: false
    };
  </script>
  
  <title>关于循环展开优化 | CatX</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这几天蛋疼，下手开始实现一个虚拟机，主要的参考书籍是Bill Blunden的&amp;lt;Virtual Machine Design and Implementation in C/C++&amp;gt;，书中实现了一个基本完整的HEC虚拟机。除了实践一下其中的知识以外，最主要的还是实际调查一下自己对原作者实现中不满意的地方，如果时间和精力足够，再添加没有实现的JIT以及配套的高级语言编译器。
在Hec的实">
<meta property="og:type" content="article">
<meta property="og:title" content="关于循环展开优化">
<meta property="og:url" content="http://catx.me/2011/09/15/loop-unrolling-cpp/index.html">
<meta property="og:site_name" content="CatX">
<meta property="og:description" content="这几天蛋疼，下手开始实现一个虚拟机，主要的参考书籍是Bill Blunden的&amp;lt;Virtual Machine Design and Implementation in C/C++&amp;gt;，书中实现了一个基本完整的HEC虚拟机。除了实践一下其中的知识以外，最主要的还是实际调查一下自己对原作者实现中不满意的地方，如果时间和精力足够，再添加没有实现的JIT以及配套的高级语言编译器。
在Hec的实">
<meta property="og:updated_time" content="2014-08-30T22:33:13.530Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关于循环展开优化">
<meta name="twitter:description" content="这几天蛋疼，下手开始实现一个虚拟机，主要的参考书籍是Bill Blunden的&amp;lt;Virtual Machine Design and Implementation in C/C++&amp;gt;，书中实现了一个基本完整的HEC虚拟机。除了实践一下其中的知识以外，最主要的还是实际调查一下自己对原作者实现中不满意的地方，如果时间和精力足够，再添加没有实现的JIT以及配套的高级语言编译器。
在Hec的实">
  <!-- Swiftype -->
  <meta class="swiftype" name="title" data-type="string" content="关于循环展开优化">

  
    <link rel="alternative" href="/atom.xml" title="CatX" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="app"><div class="master is-post" data-reactid=".22u7zh8tp1c" data-react-checksum="-45632798"><div class="top-banner" style="display:none;" data-reactid=".22u7zh8tp1c.0"><span data-reactid=".22u7zh8tp1c.0.0">Banner Message</span><a href="#" data-reactid=".22u7zh8tp1c.0.1">Go</a></div><nav class="navbar navbar-default" style="text-shadow:0px 0px 10px white, 0px 0px 5px white, 0px 0px 10px #a99a48, 0px 0px 5px #a99a48;" data-reactid=".22u7zh8tp1c.1"><div class="container" data-reactid=".22u7zh8tp1c.1.0"><div class="navbar-header" data-reactid=".22u7zh8tp1c.1.0.0"><a class="navbar-link hamburger-menu icon-link" href="javascript:void(0)" data-reactid=".22u7zh8tp1c.1.0.0.0"><i class="fa fa-2x fa-bars" data-reactid=".22u7zh8tp1c.1.0.0.0.0"></i></a><a class="navbar-brand" href="/" data-reactid=".22u7zh8tp1c.1.0.0.1"><i class="logo icon cocat-logo" data-reactid=".22u7zh8tp1c.1.0.0.1.0"></i><span data-reactid=".22u7zh8tp1c.1.0.0.1.1"><ruby data-reactid=".22u7zh8tp1c.1.0.0.1.1.0:$Cat"><rb data-reactid=".22u7zh8tp1c.1.0.0.1.1.0:$Cat.0">Cat</rb><rp data-reactid=".22u7zh8tp1c.1.0.0.1.1.0:$Cat.1">(</rp><rt data-reactid=".22u7zh8tp1c.1.0.0.1.1.0:$Cat.2">猫</rt><rp data-reactid=".22u7zh8tp1c.1.0.0.1.1.0:$Cat.3">)</rp></ruby><ruby data-reactid=".22u7zh8tp1c.1.0.0.1.1.0:$X"><rb data-reactid=".22u7zh8tp1c.1.0.0.1.1.0:$X.0">X</rb><rp data-reactid=".22u7zh8tp1c.1.0.0.1.1.0:$X.1">(</rp><rt data-reactid=".22u7zh8tp1c.1.0.0.1.1.0:$X.2">杀</rt><rp data-reactid=".22u7zh8tp1c.1.0.0.1.1.0:$X.3">)</rp></ruby><span data-reactid=".22u7zh8tp1c.1.0.0.1.1.1">CatX</span></span></a><span data-reactid=".22u7zh8tp1c.1.0.0.2"></span></div><div class="collapse navbar-collapse" data-reactid=".22u7zh8tp1c.1.0.1"><form class="navbar-form navbar-right" role="search" data-reactid=".22u7zh8tp1c.1.0.1.0"><div class="form-group" data-reactid=".22u7zh8tp1c.1.0.1.0.0"><input type="text" class="form-control" placeholder="Search" data-reactid=".22u7zh8tp1c.1.0.1.0.0.0"/></div></form><ul class="nav navbar-nav navbar-right" data-reactid=".22u7zh8tp1c.1.0.1.1"><li class="" data-reactid=".22u7zh8tp1c.1.0.1.1.$Home"><a class="" href="/" data-reactid=".22u7zh8tp1c.1.0.1.1.$Home.0">Home</a></li><li class="" data-reactid=".22u7zh8tp1c.1.0.1.1.$Archives"><a class="" href="/archives/" data-reactid=".22u7zh8tp1c.1.0.1.1.$Archives.0">Archives</a></li></ul></div></div></nav><div class="post-wrapper" data-reactid=".22u7zh8tp1c.2"><section id="preview" style="background-color:#a99a48;" class="" data-reactid=".22u7zh8tp1c.2.0"><div class="intro-wrapper" data-reactid=".22u7zh8tp1c.2.0.0"><div class="container" data-reactid=".22u7zh8tp1c.2.0.0.0"><div class="row" data-reactid=".22u7zh8tp1c.2.0.0.0.0"><div class="feature-image col-sm-8 col-sm-push-4 col-xs-12" data-reactid=".22u7zh8tp1c.2.0.0.0.0.0"><img alt="Feature image" src="/image/stock/7.jpg" data-reactid=".22u7zh8tp1c.2.0.0.0.0.0.0"/></div><div style="text-shadow:0px 0px 10px white, 0px 0px 5px white, 0px 0px 10px #a99a48, 0px 0px 5px #a99a48;" class="post-title col-sm-4 col-sm-pull-8 col-xs-12 col-xs-12" data-reactid=".22u7zh8tp1c.2.0.0.0.0.1"><h1 data-reactid=".22u7zh8tp1c.2.0.0.0.0.1.0">关于循环展开优化</h1><div class="post-intro" data-reactid=".22u7zh8tp1c.2.0.0.0.0.1.1"><p>这几天蛋疼，下手开始实现一个虚拟机，主要的参考书籍是Bill Blunden的&lt;Virtual Machine Design and Implementation in C/C++&gt;，书中实现了一个基本完整的HEC虚拟机。除了实践一下其中的知识以外，最主要的还是实际调查一下自己对原作者实现中不满意的地方，如果时间和精力足够，再添加没有实现的JIT以及配套的高级语言编译器。</p>
<p>在Hec的实现中，有一个基本的功能，就是实现虚拟机字节码的endian与native code的endian之间的转换（如果相反），只是简单的颠倒字节顺序。主要在虚拟机加载字节码，开始执行之前调用，直接影响字节码加载到开始执行期间用户的等待时间。</p>
<p>Blunden为了优化性能，在这部分应用了循环展开[<a href="http://en.wikipedia.org/wiki/Loop_unwinding" title="Loop unwinding @ wikipedia">1</a>]技术。本文记录了在开发过程中采用的几种与Blunden不同的实现方法，以及初步的对比。</p></div></div></div></div></div></section><section id="post-action" data-reactid=".22u7zh8tp1c.2.1"><div class="container" data-reactid=".22u7zh8tp1c.2.1.0"><div class="post-socials" data-reactid=".22u7zh8tp1c.2.1.0.0"><div class="like-button" data-reactid=".22u7zh8tp1c.2.1.0.0.0"><a class="social icon-link" href="javascript:void(0);" data-reactid=".22u7zh8tp1c.2.1.0.0.0.0"><i class="fa fa-2 fa-heart-o" data-reactid=".22u7zh8tp1c.2.1.0.0.0.0.0"></i></a></div><span data-reactid=".22u7zh8tp1c.2.1.0.0.1">TODO: duoshuo</span></div><div class="action-buttons" data-reactid=".22u7zh8tp1c.2.1.0.1">TODO: action buttons</div></div></section><article data-reactid=".22u7zh8tp1c.2.2"><div class="container" data-reactid=".22u7zh8tp1c.2.2.0"><p>这几天蛋疼，下手开始实现一个虚拟机，主要的参考书籍是Bill Blunden的&lt;Virtual Machine Design and Implementation in C/C++&gt;，书中实现了一个基本完整的HEC虚拟机。除了实践一下其中的知识以外，最主要的还是实际调查一下自己对原作者实现中不满意的地方，如果时间和精力足够，再添加没有实现的JIT以及配套的高级语言编译器。</p>
<p>在Hec的实现中，有一个基本的功能，就是实现虚拟机字节码的endian与native code的endian之间的转换（如果相反），只是简单的颠倒字节顺序。主要在虚拟机加载字节码，开始执行之前调用，直接影响字节码加载到开始执行期间用户的等待时间。</p>
<p>Blunden为了优化性能，在这部分应用了循环展开[<a href="http://en.wikipedia.org/wiki/Loop_unwinding" title="Loop unwinding @ wikipedia" target="_blank" rel="external">1</a>]技术。本文记录了在开发过程中采用的几种与Blunden不同的实现方法，以及初步的对比。</p>
<a id="more"></a>
<p><strong>0. Blunden原始实现</strong></p>
<p>原始实现提供了一系列单独的bytecodeToTypeName以及typeNameToBytecode全局函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">U2 <span class="title">bytecodeToWord</span><span class="params">(U1 bytes[])</span></span>;</span><br><span class="line"><span class="function">U4 <span class="title">bytecodeToDWord</span><span class="params">(U1 bytes[])</span></span>;</span><br><span class="line"><span class="function">U8 <span class="title">bytecodeToQWord</span><span class="params">(U1 bytes[])</span></span>;</span><br><span class="line"><span class="function">F4 <span class="title">bytecodeToFloat</span><span class="params">(U1 bytes[])</span></span>;</span><br><span class="line"><span class="function">F8 <span class="title">bytecodeToDouble</span><span class="params">(U1 bytes[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wordToBytecode</span><span class="params">(U2 word, U1 arr[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dwordToBytecode</span><span class="params">(U4 dword, U1 arr[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qwordToBytecode</span><span class="params">(U8 qword, U1 arr[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floatToBytecode</span><span class="params">(F4 flt, U1 arr[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doubleToBytecode</span><span class="params">(F8 dbl, U1 arr[])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>其中U代表unsigned，后面的数字代表位长，在win32平台下的定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> S1	signed char</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> S2	signed short</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> S4	signed long</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> S8	signed __int64	</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> U1	unsigned char</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> U2	unsigned short</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> U4	unsigned long</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> U8	unsigned __int64</span></span><br></pre></td></tr></table></figure>
<p>以下仅列举U8版本的qwordToBytecode实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qwordToBytecode</span><span class="params">(U8 qword, U1 arr[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	U1 *buffer;</span><br><span class="line"></span><br><span class="line">	buffer = (U1*)&amp;amp;qword;</span><br><span class="line">	arr[<span class="number">0</span>] = buffer[<span class="number">7</span>];</span><br><span class="line">	arr[<span class="number">1</span>] = buffer[<span class="number">6</span>];</span><br><span class="line">	arr[<span class="number">2</span>] = buffer[<span class="number">5</span>];</span><br><span class="line">	arr[<span class="number">3</span>] = buffer[<span class="number">4</span>];</span><br><span class="line">	arr[<span class="number">4</span>] = buffer[<span class="number">3</span>];</span><br><span class="line">	arr[<span class="number">5</span>] = buffer[<span class="number">2</span>];</span><br><span class="line">	arr[<span class="number">6</span>] = buffer[<span class="number">1</span>];</span><br><span class="line">	arr[<span class="number">7</span>] = buffer[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">/*end qwordToBytecode*/</span></span><br></pre></td></tr></table></figure>
<p>可以看出Blunden的实现是C Style的，基本上就是一大堆全局函数与变量，缺乏封装性。各个类型的转换函数没有统一的调用接口，而且由于采用了循环展开，导致对每一个类型转换的函数体都非常冗长，整个代码就变成了一大堆重复代码的组合。</p>
<p>当然这主要是出于性能的考虑，不过考虑到现在的C++编译器的性能已经不再是当年的情况，C++完全可以做到与C相同甚至更好的性能，同时提供更易于维护的代码。实际上，很多C语言写的程序最后也是用C++编译器编译的。</p>
<p><strong>1.实现一：For Loop</strong></p>
<p>在讨论优化之前，要有个被优化的对象作为对比，以下是用For循环在一个struct中实现同样的功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &amp;lt;<span class="keyword">typename</span> T&amp;gt;</span><br><span class="line"><span class="keyword">struct</span> ForLoopAssign</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AssignBytes</span><span class="params">(<span class="keyword">const</span> U1 src[], U1 dest[])</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; <span class="keyword">sizeof</span>(T); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			dest[i] = src[<span class="keyword">sizeof</span>(T) - i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里只是最主要的交换赋值部分，采用了模板类，为的是同一个接口实现不同类型转换功能的调用，而不是若干个单独的函数。</p>
<p>模板类在编译时就会被展开，因此在运行时的性能损耗很小。</p>
<p>可以看到这段代码的优点是简短，易于维护，几行代码实现了几十行代码的功能。缺点当然是For-Loop造成的性能损耗。</p>
<p>调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ForLoopAssign&amp;lt;T&amp;gt;::AssignBytes(src, dest);</span><br></pre></td></tr></table></figure>
<p><strong>2.实现二：手动循环展开</strong></p>
<p>Prototype：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &amp;lt;<span class="keyword">int</span> byteLen&amp;gt;</span><br><span class="line"><span class="keyword">struct</span> ExplicitUnrolling</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AssignBytes</span><span class="params">(<span class="keyword">const</span> U1 src[], U1 dest[])</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>特化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &amp;lt;&amp;gt;</span><br><span class="line"><span class="keyword">struct</span> ExplicitUnrolling&amp;lt;<span class="number">1</span>&amp;gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AssignBytes</span><span class="params">(<span class="keyword">const</span> U1 src[], U1 dest[])</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		dest[<span class="number">0</span>] = src[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &amp;lt;&amp;gt;</span><br><span class="line"><span class="keyword">struct</span> ExplicitUnrolling&amp;lt;<span class="number">2</span>&amp;gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AssignBytes</span><span class="params">(<span class="keyword">const</span> U1 src[], U1 dest[])</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		dest[<span class="number">0</span>] = src[<span class="number">1</span>];</span><br><span class="line">		dest[<span class="number">1</span>] = src[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &amp;lt;&amp;gt;</span><br><span class="line"><span class="keyword">struct</span> ExplicitUnrolling&amp;lt;<span class="number">4</span>&amp;gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AssignBytes</span><span class="params">(<span class="keyword">const</span> U1 src[], U1 dest[])</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		dest[<span class="number">0</span>] = src[<span class="number">3</span>];</span><br><span class="line">		dest[<span class="number">1</span>] = src[<span class="number">2</span>];</span><br><span class="line">		dest[<span class="number">2</span>] = src[<span class="number">1</span>];</span><br><span class="line">		dest[<span class="number">3</span>] = src[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &amp;lt;&amp;gt;</span><br><span class="line"><span class="keyword">struct</span> ExplicitUnrolling&amp;lt;<span class="number">8</span>&amp;gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AssignBytes</span><span class="params">(<span class="keyword">const</span> U1 src[], U1 dest[])</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		dest[<span class="number">0</span>] = src[<span class="number">7</span>];</span><br><span class="line">		dest[<span class="number">1</span>] = src[<span class="number">6</span>];</span><br><span class="line">		dest[<span class="number">2</span>] = src[<span class="number">5</span>];</span><br><span class="line">		dest[<span class="number">3</span>] = src[<span class="number">4</span>];</span><br><span class="line">		dest[<span class="number">4</span>] = src[<span class="number">3</span>];</span><br><span class="line">		dest[<span class="number">5</span>] = src[<span class="number">2</span>];</span><br><span class="line">		dest[<span class="number">6</span>] = src[<span class="number">1</span>];</span><br><span class="line">		dest[<span class="number">7</span>] = src[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实就是对C Style实现的C++封装，性能接近原实现，调用只需要一句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExplicitUnrolling&amp;lt;<span class="keyword">sizeof</span>(T)&amp;gt;::AssignBytes(src, dest);</span><br></pre></td></tr></table></figure>
<p>显然，作为显示实现的代码，也是难于维护的。</p>
<p><strong>3.实现3：模板元递归</strong></p>
<p>递归模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &amp;lt;<span class="keyword">int</span> byteN, <span class="keyword">int</span> byteLen&amp;gt;</span><br><span class="line"><span class="keyword">struct</span> AssignByte</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Assign</span><span class="params">(<span class="keyword">const</span> U1 src[], U1 dest[])</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		dest[byteN - <span class="number">1</span>] = src[byteLen - byteN];</span><br><span class="line">		AssignByte&amp;lt;byteN - <span class="number">1</span>, byteLen&amp;gt;::Assign(src, dest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>递归边界：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &amp;lt;<span class="keyword">int</span> byteLen&amp;gt;</span><br><span class="line"><span class="keyword">struct</span> AssignByte&amp;lt;<span class="number">1</span>, byteLen&amp;gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Assign</span><span class="params">(<span class="keyword">const</span> U1 src[], U1 dest[])</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		dest[<span class="number">0</span>] = src[byteLen - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssignByte&amp;lt;<span class="keyword">sizeof</span>(T), <span class="keyword">sizeof</span>(T)&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>
<p>和For Loop实现相比，这段代码只长了几句，但是却实现了循环展开。</p>
<p>以U4为例，调用的时候实际上是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssignByte&amp;lt;<span class="number">4</span>, <span class="number">4</span>&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>
<p>在Assign函数体中形成递归调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dest[<span class="number">4</span> - byteLen] = src[<span class="number">4</span> - byteLen];</span><br><span class="line"><span class="comment">//递归调用</span></span><br><span class="line">AssignByte&amp;lt;<span class="number">4</span> - <span class="number">1</span>, byteLen&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>
<p>直到传入的byteN == 1到达递归边界。</p>
<p>但这个递归是在编译时进行的，实际上是编译器递归的生成了如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">AssignByte&amp;lt;<span class="number">4</span>, <span class="number">4</span>&amp;gt;::Assign(<span class="keyword">const</span> U1 src[], U1 dest[])</span><br><span class="line">&#123;</span><br><span class="line">	dest[<span class="number">3</span>] = src[<span class="number">0</span>];</span><br><span class="line">	AssignByte&amp;lt;<span class="number">3</span>, <span class="number">4</span>&amp;gt;::Assign(src, dest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AssignByte&amp;lt;<span class="number">3</span>, <span class="number">4</span>&amp;gt;::Assign(<span class="keyword">const</span> U1 src[], U1 dest[])</span><br><span class="line">&#123;</span><br><span class="line">	dest[<span class="number">2</span>] = src[<span class="number">1</span>];</span><br><span class="line">	AssignByte&amp;lt;<span class="number">2</span>, <span class="number">4</span>&amp;gt;::Assign(src, dest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AssignByte&amp;lt;<span class="number">2</span>, <span class="number">4</span>&amp;gt;::Assign(<span class="keyword">const</span> U1 src[], U1 dest[])</span><br><span class="line">&#123;</span><br><span class="line">	dest[<span class="number">1</span>] = src[<span class="number">2</span>];</span><br><span class="line">	AssignByte&amp;lt;<span class="number">1</span>, <span class="number">4</span>&amp;gt;::Assign(src, dest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AssignByte&amp;lt;<span class="number">1</span>, <span class="number">4</span>&amp;gt;::Assign(<span class="keyword">const</span> U1 src[], U1 dest[])</span><br><span class="line">&#123;</span><br><span class="line">	dest[<span class="number">0</span>] = src[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以在运行时没有任何递归，只是一系列的函数调用，但更妙的是对于足够短的函数体，编译器会自动进行inline优化，省略函数调用，以上代码最后编译后等效于人肉实现的循环展开。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dest[<span class="number">0</span>] = src[<span class="number">3</span>];</span><br><span class="line">dest[<span class="number">1</span>] = src[<span class="number">2</span>];</span><br><span class="line">dest[<span class="number">2</span>] = src[<span class="number">1</span>];</span><br><span class="line">dest[<span class="number">3</span>] = src[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>这种方法最后做到了与For Loop相近长度的易于维护的代码，以及（理论上）与人肉循环展开一致的性能。</p>
<p><strong>4.测试与结果分析</strong></p>
<p>测试代码分别调用以上3种实现100000000、1000000000、10000000000次，记录执行时间。</p>
<p>测试平台：Windows 7 Ultimate 32bit + Visual Studio 2010</p>
<p>Release Build:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------&#10;Test U2&#10;For-Loop x100000000: 207&#10;Template x100000000: 88&#10;Explicit x100000000: 119&#10;&#10;Test U4&#10;For-Loop x100000000: 183&#10;Template x100000000: 85&#10;Explicit x100000000: 93&#10;&#10;Test U8&#10;For-Loop x100000000: 182&#10;Template x100000000: 86&#10;Explicit x100000000: 86&#10;&#10;----------------------------------&#10;Test U2&#10;For-Loop x1000000000: 1768&#10;Template x1000000000: 878&#10;Explicit x1000000000: 1169&#10;&#10;Test U4&#10;For-Loop x1000000000: 1796&#10;Template x1000000000: 879&#10;Explicit x1000000000: 882&#10;&#10;Test U8&#10;For-Loop x1000000000: 1760&#10;Template x1000000000: 881&#10;Explicit x1000000000: 893&#10;&#10;----------------------------------&#10;Test U2&#10;For-Loop x10000000000: 13508&#10;Template x10000000000: 7648&#10;Explicit x10000000000: 13349&#10;&#10;Test U4&#10;For-Loop x10000000000: 12094&#10;Template x10000000000: 6005&#10;Explicit x10000000000: 6267&#10;&#10;Test U8&#10;For-Loop x10000000000: 12075&#10;Template x10000000000: 5914&#10;Explicit x10000000000: 6314</span><br></pre></td></tr></table></figure></p>
<p>输出中For Loop为循环实现，Template为模板元递归实现，Explicit为人肉实现。</p>
<p>可以看到，For loop不出意外的慢。</p>
<p>在Release Build模式下，模板元递归的性能与人肉循环展开一致，甚至在位长等于2的类型中优于后者，这应该是编译器优化造成的（待考）。</p>
<p>在Debug Build模式下出现了反常，模板元递归实现的执行时间意外的比人肉实现慢：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------&#10;Test U2&#10;For-Loop x100000000: 5187&#10;Template x100000000: 9629&#10;Explicit x100000000: 3576&#10;&#10;Test U4&#10;For-Loop x100000000: 4821&#10;Template x100000000: 16005&#10;Explicit x100000000: 3533&#10;&#10;Test U8&#10;For-Loop x100000000: 7009&#10;Template x100000000: 28891&#10;Explicit x100000000: 4171&#10;&#10;-------------------------------------------</span><br></pre></td></tr></table></figure>
<p>查看Disassemblely：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//static inline void Assign(const U1 src[], U1 dest[])&#10;//&#123;&#10;01156D30  push        ebp&#10;01156D31  mov         ebp,esp&#10;01156D33  sub         esp,0C0h&#10;01156D39  push        ebx&#10;01156D3A  push        esi&#10;01156D3B  push        edi&#10;01156D3C  lea         edi,[ebp-0C0h]&#10;01156D42  mov         ecx,30h&#10;01156D47  mov         eax,0CCCCCCCCh&#10;01156D4C  rep stos    dword ptr es:[edi]&#10;//&#9;dest[byteN - 1] = src[byteLen - byteN];&#10;01156D4E  mov         eax,dword ptr [dest]&#10;01156D51  mov         ecx,dword ptr [src]&#10;01156D54  mov         dl,byte ptr [ecx]&#10;01156D56  mov         byte ptr [eax+1],dl&#10;//&#9;AssignByte&#38;lt;byteN - 1, byteLen&#38;gt;::Assign(src, dest);&#10;01156D59  mov         eax,dword ptr [dest]&#10;01156D5C  push        eax&#10;01156D5D  mov         ecx,dword ptr [src]&#10;01156D60  push        ecx&#10;01156D61  call        AssignByte&#38;lt;1,2&#38;gt;::Assign (11511FEh)&#10;01156D66  add         esp,8&#10;//&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出造成反常的原因是编译器为了便于debug，并没有进行inline优化，依然是函数调用。</p>
<p>另外Debug模式会插入许多额外代码方便调试器，因此造成了整体性能的下降。</p>
<p><strong>5.小结</strong></p>
<p>因为偷懒，本文并未比较C实现与C++实现之间的性能差异，虽然有理由相信实现一中结构体静态成员函数调用的成本与C全局函数调用成本不相上下，但仍然是不严密之处。</p>
<p>仅就3种实现的对比而言，可以确定的是：</p>
<p>a.循环展开优化是有效果的</p>
<p>b.执行成本：函数调用&gt;循环&gt;展开后代码</p>
<p>c.实际优化结果结果依赖于编译器以及编译模式</p>
<p>&nbsp;</p>
</div></article></div><footer class="footer" data-reactid=".22u7zh8tp1c.3"><div class="container" data-reactid=".22u7zh8tp1c.3.0"><div class="row" data-reactid=".22u7zh8tp1c.3.0.0"><div class="col-md-6 footer-left" data-reactid=".22u7zh8tp1c.3.0.0.0"><p data-reactid=".22u7zh8tp1c.3.0.0.0.0"><span data-reactid=".22u7zh8tp1c.3.0.0.0.0.0"><span data-reactid=".22u7zh8tp1c.3.0.0.0.0.0.0">© 2015 </span><span data-reactid=".22u7zh8tp1c.3.0.0.0.0.0.1">CatX</span><span data-reactid=".22u7zh8tp1c.3.0.0.0.0.0.2"> by </span><a href="#" data-reactid=".22u7zh8tp1c.3.0.0.0.0.0.3">AKFish</a><span data-reactid=".22u7zh8tp1c.3.0.0.0.0.0.4">. </span></span><span data-reactid=".22u7zh8tp1c.3.0.0.0.0.1"><a href="https://github.com/akfish/hexo-cocat-theme" data-reactid=".22u7zh8tp1c.3.0.0.0.0.1.0">CoCat</a><span data-reactid=".22u7zh8tp1c.3.0.0.0.0.1.1"> Theme by </span><a href="http://catx.me" data-reactid=".22u7zh8tp1c.3.0.0.0.0.1.2">AKFish</a></span></p><ul data-reactid=".22u7zh8tp1c.3.0.0.0.1"><li data-reactid=".22u7zh8tp1c.3.0.0.0.1.$admin@example=1com"><a href="mailto:admin@example.com" target="_blank" data-reactid=".22u7zh8tp1c.3.0.0.0.1.$admin@example=1com.0">admin@example.com</a></li><li data-reactid=".22u7zh8tp1c.3.0.0.0.1.$About"><a href="/about.html" target="_blank" data-reactid=".22u7zh8tp1c.3.0.0.0.1.$About.0">About</a></li><li data-reactid=".22u7zh8tp1c.3.0.0.0.1.$Terms"><a href="/terms.html" target="_blank" data-reactid=".22u7zh8tp1c.3.0.0.0.1.$Terms.0">Terms</a></li><li data-reactid=".22u7zh8tp1c.3.0.0.0.1.$FAQ"><a href="/faq.html" target="_blank" data-reactid=".22u7zh8tp1c.3.0.0.0.1.$FAQ.0">FAQ</a></li></ul></div><div class="col-md-6 footer-socials" data-reactid=".22u7zh8tp1c.3.0.0.1"><a style="background:transparent;" class="social icon-link github" href="https://github.com/akfish" target="_blank" data-reactid=".22u7zh8tp1c.3.0.0.1.$github"><i class="fa fa-2 fa-github" data-reactid=".22u7zh8tp1c.3.0.0.1.$github.0"></i></a><a style="background:transparent;" class="social icon-link rss" href="/atom.xml" target="_blank" data-reactid=".22u7zh8tp1c.3.0.0.1.$rss"><i class="fa fa-2 fa-rss" data-reactid=".22u7zh8tp1c.3.0.0.1.$rss.0"></i></a></div></div></div></footer></div></div>

  <script src="/script/cocat.js" type="text/javascript"></script>
  <script type="text/javascript" src="/react_bundle.js"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>

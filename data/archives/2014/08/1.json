{"year":2014,"month":8,"isDark":false,"type":"archive","path":"archives/2014/08/","json_base":"data/archives/2014/08/","json":"data/archives/2014/08/1.json","current":1,"total":1,"posts":[{"type":"post","json_base":"data/posts","json":"data/posts/2014/08/31/sae-chinese-keyword-extraction-service.json","path":"2014/08/31/sae-chinese-keyword-extraction-service/","data":{"title":"SAE中文关键字提取服务","content":"<p><img src=\"/images/ea44d54a8c5dfedd723e46cf537ac31ab84a791d.png\" alt=\"\"></p>\n<h2 id=\"u4ECB_u7ECD\"><a href=\"#u4ECB_u7ECD\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>SAE提供了效果不错的<a href=\"http://sae.sina.com.cn/doc/python/segment.html\" target=\"_blank\" rel=\"external\">中文分词服务</a>，于是花了点时间做了个基于TF-IDF的关键字提取算法。</p>\n<p>语料库来自<a href=\"http://www.cncorpus.org/\" target=\"_blank\" rel=\"external\">语料库在线</a>。</p>\n<h2 id=\"TF-IDF\"><a href=\"#TF-IDF\" class=\"headerlink\" title=\"TF-IDF\"></a>TF-IDF</h2><p>在把一篇文章分词过后，要从中提取出最能代表文章主题的关键字，最young最simple的办法就是基于词频(TF, term frequency)：</p>\n<p>$$TF(t, d) = f(t, d)$$</p>\n<p>其中$t$为一个单词，$d$为文档，$f(t, d)$为这个单词在文档中出现的频率。</p>\n<p>这样带来的问题很显然，即使通过停止词干掉一些频率极高，但对内容毫无贡献的词汇（如“的、地、得”），依然无法排除某些本身频率就很高的词汇。<br>比如在天朝，“中国”一词在所有文章里都有很高的出现概率，但并不见得所有文章都和天朝相关。</p>\n<p>假如有一个语料库，包含了大量具有代表性的文章。如果一个词汇在这个语料库里大量出现，则认为这个词汇本身就是个高频词；<br>如果一个词汇在语料库里出现频率不高，但在一篇文章里频繁出现，显然这个词汇是这篇文章里特有的。<br>基于这个想法，就引入了IDF(inverse document frequency):<br><span>$$IDF(t, D) = log \\frac{N}{ 1 + \\|\\{d \\in D: t \\in D\\}\\| }$$</span><!-- Has MathJax --></p>\n<p>TF-IDF值，就能用来判断一个词汇是否是一篇文章里的关键字：</p>\n<p>$$ TFIDF = w(t) * TF(t, d) * IDF(t, D) $$</p>\n<p>这里加入了一个权重函数，按词性对词汇进行过滤：<br><span>$$w(t) = \\left\\{\n  \\begin{array}{l l}\n    0.8 & t\\ is\\ v.\\ or\\ n.\\\\\n    0.6 & t\\ is\\ adv.\\ or\\ adj.\\\\\n    0 & other\n  \\end{array} \\right.$$</span><!-- Has MathJax --></p>\n<h2 id=\"u94FE_u63A5\"><a href=\"#u94FE_u63A5\" class=\"headerlink\" title=\"链接\"></a>链接</h2><ul>\n<li><a href=\"http://catx.me/seger-demo/\">Demo</a></li>\n</ul>\n<div id=\"badge-container-akfish-seger-demo-0b5e19\" class=\"hexo-github\" style=\"width: 100%\"></div>\n<script src=\"/hexo-github/badge.js\"></script>\n<script type=\"text/javascript\">\n  loadStyle(\"/hexo-github/style.css\");\n  loadStyle(\"/hexo-github/octicons/octicons.css\");\n  new Badge(\"#badge-container-akfish-seger-demo-0b5e19\", \"akfish\", \"seger-demo\", \"0b5e19\", false);\n</script>\n\n<div id=\"badge-container-akfish-seger-b64d75\" class=\"hexo-github\" style=\"width: 100%\"></div>\n<script src=\"/hexo-github/badge.js\"></script>\n<script type=\"text/javascript\">\n  loadStyle(\"/hexo-github/style.css\");\n  loadStyle(\"/hexo-github/octicons/octicons.css\");\n  new Badge(\"#badge-container-akfish-seger-b64d75\", \"akfish\", \"seger\", \"b64d75\", false);\n</script>\n\n<ul>\n<li><a href=\"https://github.com/akfish/seger-demo\" target=\"_blank\" rel=\"external\">GitHub - Seger Demo</a></li>\n<li><a href=\"https://github.com/akfish/seger\" target=\"_blank\" rel=\"external\">GitHub - Seger</a></li>\n</ul>\n","date":"2014-08-30T22:29:46.000Z","path":"2014/08/31/sae-chinese-keyword-extraction-service/","isDark":true,"featureColor":"#b66d48","featureImage":"/images/word.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#b66d48","isDark":true,"contrast":4.032235245651348},"Muted":{"color":"#846852","isDark":true,"contrast":5.253713678379464},"DarkVibrant":{"color":"#462a1c","isDark":true,"contrast":16.342879549491663},"DarkMuted":{"color":"#3b3435","isDark":true,"contrast":15.84737578931552},"LightMuted":{"color":"#a28c7e","isDark":true,"contrast":3.187235771086366}},"permalink":"http://catx.me/2014/08/31/sae-chinese-keyword-extraction-service/","json":"data/posts/2014/08/31/sae-chinese-keyword-extraction-service.json","tags":[{"name":"Algorithm","slug":"Algorithm","path":"tags/Algorithm/","permalink":"http://catx.me/tags/Algorithm/","postCount":2},{"name":"GitHub","slug":"GitHub","path":"tags/GitHub/","permalink":"http://catx.me/tags/GitHub/","postCount":6},{"name":"NLP","slug":"NLP","path":"tags/NLP/","permalink":"http://catx.me/tags/NLP/","postCount":1},{"name":"SAE","slug":"SAE","path":"tags/SAE/","permalink":"http://catx.me/tags/SAE/","postCount":1}],"categories":[]},"sha1":"2a38b9b80efc468c318e80d2c42591a723bf3fd8","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2014/08/26/html5-sound-visualization-experiment-with-processingjs.json","path":"2014/08/26/html5-sound-visualization-experiment-with-processingjs/","data":{"title":"HTML5音频可视化试验","content":"<p><img src=\"/images/d36ba1d28266e9eea9e0bc73cf32b53557e2ed21.gif\" alt=\"\"></p>\n<p>上周末脑洞大开的想到能否完全用HTML5的Web Audio API实现一个吉他调音器，折腾过后这个主要的目标失败了，音频可视化的部分倒是相对完整，实现了音量、频谱图以及音高的可视化。</p>\n<h2 id=\"u97F3_u9AD8_u68C0_u6D4B_u7B97_u6CD5\"><a href=\"#u97F3_u9AD8_u68C0_u6D4B_u7B97_u6CD5\" class=\"headerlink\" title=\"音高检测算法\"></a>音高检测算法</h2><p>调音器的原理其实很简单，本质上就是音高检测算法(pitch detection algorithm)，实现的方式有很多<a href=\"http://strum.googlecode.com/svn/trunk/Research/Efficient%20Pitch%20Detection%20Techniques%20For%20Interactive%20Music.pdf\" target=\"_blank\" rel=\"external\">[1]</a>，时域方法和频域方法都有。</p>\n<p>乐音最基本的特征就是由一系列谐波组成，包含一个基本频率$f$，以及一系列基本频率的整数倍的子波$2f, 3f, 4f, …, nf$，基础频率$f$的值就是乐音的音调。</p>\n<p><img src=\"/images/f8919d6d536b1edcc0cfd78bbf6b1da1554330b1.png\" alt=\"\"></p>\n<p>所以一种简单的频域音高检测算法就是HPS(harmonic product spectrum)：</p>\n<p>$$Y(\\omega) = \\prod_{r = 1}^R|X(\\omega r)|$$<br>$$\\hat{Y} = \\max_{\\omega_i}{Y(\\omega_i)}$$</p>\n<p>其中$X$是音频在频域空间的向量表示（通常通过FFT得到），HPS就是求一个频率的$R$个整数数倍位置的信号强度的乘积，形成一个新的频谱图$Y$。</p>\n<p>谐波的基础频率就会在$Y$中形成波峰：</p>\n<p><img src=\"/images/5282b104e2e419c83c659f2507bdd849410f8093.png\" alt=\"\"></p>\n<p>这个方法的缺点很明显，高频信号由于已经没有多少谐波被采样，因此在高频并不可靠。不过对于音乐而言，这并不是问题，钢琴的最高音C8不过才4186.01Hz，而音乐文件的采样率普遍是kHz级别。</p>\n<h2 id=\"HTML5_Audio_API\"><a href=\"#HTML5_Audio_API\" class=\"headerlink\" title=\"HTML5 Audio API\"></a>HTML5 Audio API</h2><p>用Audio API做音频可视化至少会创建三个对象：<code>AudioContext</code>, <code>AudioSource</code>和<code>AnalyzerNode</code>。<br>前两者的作用很显然不用多说，<code>AnalyzerNode</code>提供实时的FFT数据。</p>\n<p>首先当然是创建一个<code>context</code>，绑定一个<code>analyzer</code>:</p>\n<figure class=\"highlight coffee\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context = <span class=\"keyword\">new</span> AudioContext()</span><br><span class=\"line\">analyzer = context.createAnalyser()</span><br><span class=\"line\">analyzer.smoothingTimeConstant = <span class=\"number\">0.3</span></span><br><span class=\"line\">analyzer.fftSize = <span class=\"number\">2048</span></span><br></pre></td></tr></table></figure>\n<p>其中<code>fftSize</code>指定把频域空间平均分成多少份.</p>\n<p>接着是创建<code>source</code>，可以是麦克风的输入：</p>\n<figure class=\"highlight coffee\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">navigator.getUserMedia <span class=\"attribute\">audio</span>: <span class=\"literal\">true</span>, <span class=\"function\">(<span class=\"params\">(stream)</span> -&gt;</span></span><br><span class=\"line\">  source = context.createMediaStreamSource stream</span><br><span class=\"line\">  mic_stream = stream</span><br><span class=\"line\">  source.connect analyzer</span><br><span class=\"line\">  analyzer.connect context.destination</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log <span class=\"string\">\"Microphone open. Sample rate: <span class=\"subst\">#&#123;context.sampleRate&#125;</span> Hz\"</span></span><br><span class=\"line\">  ), <span class=\"function\"><span class=\"params\">(err)</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error <span class=\"string\">\"Fail to access microphone: <span class=\"subst\">#&#123;err&#125;</span>\"</span></span><br></pre></td></tr></table></figure>\n<p>也可以是载入一个音频文件：</p>\n<figure class=\"highlight coffee\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source = context.createBufferSource()</span><br><span class=\"line\"></span><br><span class=\"line\">source.connect analyzer</span><br><span class=\"line\">analyzer.connect context.destination</span><br><span class=\"line\"></span><br><span class=\"line\">xhr = <span class=\"keyword\">new</span> XMLHttpRequest()</span><br><span class=\"line\">xhr.onload = <span class=\"function\">=&gt;</span></span><br><span class=\"line\">  context.decodeAudioData xhr.response, <span class=\"function\">(<span class=\"params\">(b)</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log <span class=\"string\">\"Audio loaded: <span class=\"subst\">#&#123;url&#125;</span>, Sample rate: <span class=\"subst\">#&#123;context.sampleRate&#125;</span>Hz\"</span></span><br><span class=\"line\">    source.buffer = b</span><br><span class=\"line\">    source.<span class=\"keyword\">loop</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">    source.start <span class=\"number\">0.0</span></span><br><span class=\"line\">    ), <span class=\"function\"><span class=\"params\">(err)</span> -&gt;</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error <span class=\"string\">\"Fail to load audio: <span class=\"subst\">#&#123;url&#125;</span>\"</span></span><br><span class=\"line\">xhr.open <span class=\"string\">\"GET\"</span>, url, <span class=\"literal\">true</span></span><br><span class=\"line\">xhr.responseType = <span class=\"string\">'arraybuffer'</span></span><br><span class=\"line\">xhr.send()</span><br></pre></td></tr></table></figure>\n<p>然后需要创建一个<code>ScriptProcessorNode</code>，和<code>analyzer</code>链接，这样在每帧数据可用时会执行前者的<code>onaudioprocess</code>，音频处理算法一般都放在这里：</p>\n<figure class=\"highlight coffee\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node = context.createScriptProcessor <span class=\"number\">2048</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span></span><br><span class=\"line\">node.onaudioprocess = <span class=\"function\">-&gt;</span></span><br><span class=\"line\">  <span class=\"comment\"># <span class=\"doctag\">TODO:</span> process audio</span></span><br><span class=\"line\">node.connect context.destination</span><br><span class=\"line\">analyzer.connect node</span><br></pre></td></tr></table></figure>\n<p>读取FFT数据：</p>\n<figure class=\"highlight coffee\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node.onaudioprocess = <span class=\"function\">-&gt;</span></span><br><span class=\"line\">  n = analyzer.frequencyBinCount</span><br><span class=\"line\">  arr = <span class=\"keyword\">new</span> Uint8Array(n)</span><br><span class=\"line\">  analyzer.getByteFrequencyData arr</span><br><span class=\"line\">  <span class=\"comment\"># <span class=\"doctag\">TODO:</span> Draw</span></span><br></pre></td></tr></table></figure>\n<p>读出来的数组里包含了从低频到高频的强度，可以直接用于绘制频谱图，求和平均就是音量，也可以作为频域处理算法的输入。</p>\n<p>数组里元素$i$对应的频率为$f_i = \\frac{Sample Rate}{FFT Size} i$。</p>\n<p>在调音器这个应用中，最大的问题就是精度，Audio API里最大取值只能是<code>2048</code>，在48kHz采样率时，频率分辨率只能到23.43Hz。<br>这个精度是无法接受的，如$E4 = 329.628, F4 = 349.228$之间只相差了19.6Hz，完全无法区分。</p>\n<h2 id=\"u53EF_u89C6_u5316\"><a href=\"#u53EF_u89C6_u5316\" class=\"headerlink\" title=\"可视化\"></a>可视化</h2><p>在这个项目里尝试了下<a href=\"/processingjs.org/\">processing.js</a>，虽然API很清晰，但是绘图功能不足，没有原生的gradient，blur支持，只能人肉实现，于是性能一不小心就惨淡了。</p>\n<h2 id=\"u6E90_u7801\"><a href=\"#u6E90_u7801\" class=\"headerlink\" title=\"源码\"></a>源码</h2><ul>\n<li><a href=\"http://catx.me/not-a-tuner-yet\">Demo</a></li>\n</ul>\n<div id=\"badge-container-akfish-not-a-tuner-yet-a34a7d\" class=\"hexo-github\" style=\"width: 100%\"></div>\n<script src=\"/hexo-github/badge.js\"></script>\n<script type=\"text/javascript\">\n  loadStyle(\"/hexo-github/style.css\");\n  loadStyle(\"/hexo-github/octicons/octicons.css\");\n  new Badge(\"#badge-container-akfish-not-a-tuner-yet-a34a7d\", \"akfish\", \"not-a-tuner-yet\", \"a34a7d\", false);\n</script>\n\n<p>建议使用Chrome打开，FireFox上性能很惨淡。</p>\n","date":"2014-08-26T01:06:16.000Z","path":"2014/08/26/html5-sound-visualization-experiment-with-processingjs/","isDark":true,"featureColor":"#146ca4","featureImage":"/images/sound-visualization-exp.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#146ca4","isDark":true,"contrast":5.665104928657267},"Muted":{"color":"#8db3c8","isDark":false,"contrast":2.230575663094013},"DarkVibrant":{"color":"#146498","isDark":true,"contrast":10.975361372213726},"DarkMuted":{"color":"#617784","isDark":true,"contrast":5.125568077118013},"LightVibrant":{"color":"#609bbd","isDark":true,"contrast":3.2074486961643944},"LightMuted":{"color":"#b5bfc6","isDark":false,"contrast":1.869572315096829}},"permalink":"http://catx.me/2014/08/26/html5-sound-visualization-experiment-with-processingjs/","json":"data/posts/2014/08/26/html5-sound-visualization-experiment-with-processingjs.json","tags":[{"name":"GitHub","slug":"GitHub","path":"tags/GitHub/","permalink":"http://catx.me/tags/GitHub/","postCount":6},{"name":"HTML5","slug":"HTML5","path":"tags/HTML5/","permalink":"http://catx.me/tags/HTML5/","postCount":2},{"name":"Music","slug":"Music","path":"tags/Music/","permalink":"http://catx.me/tags/Music/","postCount":1},{"name":"Visualization","slug":"Visualization","path":"tags/Visualization/","permalink":"http://catx.me/tags/Visualization/","postCount":1},{"name":"processing.js","slug":"processing-js","path":"tags/processing-js/","permalink":"http://catx.me/tags/processing-js/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":17}]},"sha1":"61b12ebc3afa2712e2db4cee11edd44f5b8daf27","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2014/08/11/china-weather-radar-crawler.json","path":"2014/08/11/china-weather-radar-crawler/","data":{"title":"中国区气象雷达数据爬虫","content":"<p>作为一个数据控，爱好各种实时数据，比如中央气象台的<a href=\"http://www.nmc.gov.cn/publish/radar/stations-chongqing.htm\" target=\"_blank\" rel=\"external\">气象雷达</a>数据。最近在进行的一个HTML5项目，就是利用Canvas和WebGL，把外观土鳖的官方数据，变成洋气+实用的交互式地图。由于HTML5 Canvas CORS的限制，在没有服务器配合的情况下，无法跨域载入图片，然后<code>getImageData</code>，因此就做了一个爬虫。</p>\n<p>经过一番试验，发现国外的免费云服务只有GAE能够访问nmc.gov.cn，确定爬虫在GAE上安家了。大致计算了下数据量，全国167个雷达站，平均10分钟更新1帧，每帧是一幅约35KB的GIF图像，一天下来就至少800+M的数据，放GAE上不现实。同时前端也需要<code>.json</code>文件，描述雷达站信息以及数据帧列表，所以还需要数据库存储，而GAE坑爹的datastore quota，一天只能5w次读写，爬虫大概跑3圈就爆了。在这样一些约束下，最后脑洞大开的结合GitHub API，把数据全存到一个GitHub repository里，然后再把git tree拖回来当数据库用，解决问题。</p>\n<p>目前在GAE上部署了两个实例，分时运行，因为bandwidth quota大概只能支撑半天，然后每天删除repository重建一次，避免超过GitHub的quota。</p>\n<p>除了爬图片，地图叠加层的对其需要知道雷达站的坐标，以及数据的范围（即图片上的“数据范围：xxx km”），前者通过之前人肉爬到的一个包含全国雷达站坐标的xml文件解决问题。<br>至于数据范围没有找到官方的数据，最后写了一个简单的OCR算法直接从图片上识别。</p>\n<h2 id=\"u9644_u8BB0_uFF1A_u7528GitHub_API_u521B_u5EFAcommit_u6D41_u7A0B\"><a href=\"#u9644_u8BB0_uFF1A_u7528GitHub_API_u521B_u5EFAcommit_u6D41_u7A0B\" class=\"headerlink\" title=\"附记：用GitHub API创建commit流程\"></a>附记：用GitHub API创建commit流程</h2><p>GitHub提供了<a href=\"https://developer.github.com/v3/repos/contents/\" target=\"_blank\" rel=\"external\">Content API</a>，可以方便的对单个文件进行CRUD操作，每次操作产生1个commit。<br>如果需要一次commit多个文件（比如这个爬虫每次cron会新增数百文件），这样显然不实际。<br>更好的做法是通过<a href=\"https://developer.github.com/v3/git/\" target=\"_blank\" rel=\"external\">Git Data API</a>，模拟git创建一次commit的过程。<br>之前做git私有传输协议的经验立即发挥作，轻车熟路的解决，流程如下：</p>\n<ol>\n<li>用<a href=\"https://developer.github.com/v3/git/blobs/\" target=\"_blank\" rel=\"external\">Blob API</a>为每个文件创建一个blob</li>\n<li>用<a href=\"https://developer.github.com/v3/git/trees/\" target=\"_blank\" rel=\"external\">Tree API</a>为每个子文件夹创建一个tree，并添加其中文件对应的blob</li>\n<li>用<a href=\"https://developer.github.com/v3/git/commits/\" target=\"_blank\" rel=\"external\">Commit API</a>读出要commit分支最新的commit，以及commit对应的tree</li>\n<li>创建root tree，未改变的文件/文件夹需要原封不动的在tree里面保留，插入/替换新增的blob/tree</li>\n<li>创建commit，tree指向新的root tree，parent指向分支最新commit</li>\n<li>用<a href=\"https://developer.github.com/v3/git/refs/\" target=\"_blank\" rel=\"external\">Reference API</a>更新分支的ref，指向新创建的commit</li>\n</ol>\n<p>如果操作中断或重复操作，blob/tree都不会导致多余的数据产生（纯浪费上传带宽而已）。<br>因为git用SHA1 Digest作为所有git object的文件名，同内容的blob/tree不会重复。<br>需要注意一个例外，commit由于包含了时间戳，会重复创建。</p>\n<p>当然最好封装好的library，会省不少事。<br>比如我在这个项目里用到的python library是<a href=\"https://github.com/jacquev6/PyGithub\" target=\"_blank\" rel=\"external\">PyGitHub</a>，几个月前给这个项目发过pull request增加了些功能，比较熟悉用起来顺手。</p>\n<h2 id=\"u94FE_u63A5\"><a href=\"#u94FE_u63A5\" class=\"headerlink\" title=\"链接\"></a>链接</h2><ul>\n<li>源码: <a href=\"https://github.com/catx-weather/radar-bot\" target=\"_blank\" rel=\"external\">radar-bot</a></li>\n<li>爬到的数据：<a href=\"https://github.com/catx-weather/data\" target=\"_blank\" rel=\"external\">data</a></li>\n<li>OCR工具：<a href=\"https://github.com/catx-weather/frame-range-ocr\" target=\"_blank\" rel=\"external\">Frame Range OCR</a></li>\n</ul>\n","date":"2014-08-10T16:14:12.000Z","path":"2014/08/11/china-weather-radar-crawler/","isDark":false,"featureColor":"#caa084","featureImage":"/images/tornado.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#caa084","isDark":false,"contrast":2.3667779450941966},"Muted":{"color":"#785541","isDark":true,"contrast":9.562217921145681},"DarkVibrant":{"color":"#9c5c3d","isDark":true,"contrast":7.395012998220232},"DarkMuted":{"color":"#4b3a32","isDark":true,"contrast":15.322594218985449},"LightVibrant":{"color":"#d8bba5","isDark":false,"contrast":1.814844701319505},"LightMuted":{"color":"#dcd9d6","isDark":false,"contrast":1.4056903887271448}},"permalink":"http://catx.me/2014/08/11/china-weather-radar-crawler/","json":"data/posts/2014/08/11/china-weather-radar-crawler.json","tags":[{"name":"Crawler","slug":"Crawler","path":"tags/Crawler/","permalink":"http://catx.me/tags/Crawler/","postCount":1},{"name":"Fun","slug":"Fun","path":"tags/Fun/","permalink":"http://catx.me/tags/Fun/","postCount":2},{"name":"GAE","slug":"GAE","path":"tags/GAE/","permalink":"http://catx.me/tags/GAE/","postCount":1},{"name":"GitHub","slug":"GitHub","path":"tags/GitHub/","permalink":"http://catx.me/tags/GitHub/","postCount":6},{"name":"Python","slug":"Python","path":"tags/Python/","permalink":"http://catx.me/tags/Python/","postCount":1},{"name":"Weather","slug":"Weather","path":"tags/Weather/","permalink":"http://catx.me/tags/Weather/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":17}]},"sha1":"51bbd8638566a9085ff42646b5ba3e139feba9c1","isDigest":true}],"sha1":"2ccbc5f0ff03357fa50b4ff266cdde364615f810"}
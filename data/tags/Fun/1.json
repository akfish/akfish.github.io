{"tag":"Fun","isDark":false,"type":"tag","path":"tags/Fun/","json_base":"data/tags/Fun/","json":"data/tags/Fun/1.json","current":1,"total":1,"posts":[{"type":"post","json_base":"data/posts","json":"data/posts/2014/08/11/china-weather-radar-crawler.json","path":"2014/08/11/china-weather-radar-crawler/","data":{"title":"中国区气象雷达数据爬虫","content":"<p>作为一个数据控，爱好各种实时数据，比如中央气象台的<a href=\"http://www.nmc.gov.cn/publish/radar/stations-chongqing.htm\" target=\"_blank\" rel=\"external\">气象雷达</a>数据。最近在进行的一个HTML5项目，就是利用Canvas和WebGL，把外观土鳖的官方数据，变成洋气+实用的交互式地图。由于HTML5 Canvas CORS的限制，在没有服务器配合的情况下，无法跨域载入图片，然后<code>getImageData</code>，因此就做了一个爬虫。</p>\n<p>经过一番试验，发现国外的免费云服务只有GAE能够访问nmc.gov.cn，确定爬虫在GAE上安家了。大致计算了下数据量，全国167个雷达站，平均10分钟更新1帧，每帧是一幅约35KB的GIF图像，一天下来就至少800+M的数据，放GAE上不现实。同时前端也需要<code>.json</code>文件，描述雷达站信息以及数据帧列表，所以还需要数据库存储，而GAE坑爹的datastore quota，一天只能5w次读写，爬虫大概跑3圈就爆了。在这样一些约束下，最后脑洞大开的结合GitHub API，把数据全存到一个GitHub repository里，然后再把git tree拖回来当数据库用，解决问题。</p>\n<p>目前在GAE上部署了两个实例，分时运行，因为bandwidth quota大概只能支撑半天，然后每天删除repository重建一次，避免超过GitHub的quota。</p>\n<p>除了爬图片，地图叠加层的对其需要知道雷达站的坐标，以及数据的范围（即图片上的“数据范围：xxx km”），前者通过之前人肉爬到的一个包含全国雷达站坐标的xml文件解决问题。<br>至于数据范围没有找到官方的数据，最后写了一个简单的OCR算法直接从图片上识别。</p>\n<h2 id=\"u9644_u8BB0_uFF1A_u7528GitHub_API_u521B_u5EFAcommit_u6D41_u7A0B\"><a href=\"#u9644_u8BB0_uFF1A_u7528GitHub_API_u521B_u5EFAcommit_u6D41_u7A0B\" class=\"headerlink\" title=\"附记：用GitHub API创建commit流程\"></a>附记：用GitHub API创建commit流程</h2><p>GitHub提供了<a href=\"https://developer.github.com/v3/repos/contents/\" target=\"_blank\" rel=\"external\">Content API</a>，可以方便的对单个文件进行CRUD操作，每次操作产生1个commit。<br>如果需要一次commit多个文件（比如这个爬虫每次cron会新增数百文件），这样显然不实际。<br>更好的做法是通过<a href=\"https://developer.github.com/v3/git/\" target=\"_blank\" rel=\"external\">Git Data API</a>，模拟git创建一次commit的过程。<br>之前做git私有传输协议的经验立即发挥作，轻车熟路的解决，流程如下：</p>\n<ol>\n<li>用<a href=\"https://developer.github.com/v3/git/blobs/\" target=\"_blank\" rel=\"external\">Blob API</a>为每个文件创建一个blob</li>\n<li>用<a href=\"https://developer.github.com/v3/git/trees/\" target=\"_blank\" rel=\"external\">Tree API</a>为每个子文件夹创建一个tree，并添加其中文件对应的blob</li>\n<li>用<a href=\"https://developer.github.com/v3/git/commits/\" target=\"_blank\" rel=\"external\">Commit API</a>读出要commit分支最新的commit，以及commit对应的tree</li>\n<li>创建root tree，未改变的文件/文件夹需要原封不动的在tree里面保留，插入/替换新增的blob/tree</li>\n<li>创建commit，tree指向新的root tree，parent指向分支最新commit</li>\n<li>用<a href=\"https://developer.github.com/v3/git/refs/\" target=\"_blank\" rel=\"external\">Reference API</a>更新分支的ref，指向新创建的commit</li>\n</ol>\n<p>如果操作中断或重复操作，blob/tree都不会导致多余的数据产生（纯浪费上传带宽而已）。<br>因为git用SHA1 Digest作为所有git object的文件名，同内容的blob/tree不会重复。<br>需要注意一个例外，commit由于包含了时间戳，会重复创建。</p>\n<p>当然最好封装好的library，会省不少事。<br>比如我在这个项目里用到的python library是<a href=\"https://github.com/jacquev6/PyGithub\" target=\"_blank\" rel=\"external\">PyGitHub</a>，几个月前给这个项目发过pull request增加了些功能，比较熟悉用起来顺手。</p>\n<h2 id=\"u94FE_u63A5\"><a href=\"#u94FE_u63A5\" class=\"headerlink\" title=\"链接\"></a>链接</h2><ul>\n<li>源码: <a href=\"https://github.com/catx-weather/radar-bot\" target=\"_blank\" rel=\"external\">radar-bot</a></li>\n<li>爬到的数据：<a href=\"https://github.com/catx-weather/data\" target=\"_blank\" rel=\"external\">data</a></li>\n<li>OCR工具：<a href=\"https://github.com/catx-weather/frame-range-ocr\" target=\"_blank\" rel=\"external\">Frame Range OCR</a></li>\n</ul>\n","date":"2014-08-10T16:14:12.000Z","path":"2014/08/11/china-weather-radar-crawler/","isDark":true,"featureColor":"#2b6a7d","featureImage":"/image/stock/3.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#2b6a7d","isDark":true,"contrast":6.152506571402196},"Muted":{"color":"#628d9b","isDark":true,"contrast":3.8818866665042275},"DarkVibrant":{"color":"#08536a","isDark":true,"contrast":13.30121420712154},"DarkMuted":{"color":"#4d7e8e","isDark":true,"contrast":4.693454244598322},"LightVibrant":{"color":"#74d4e4","isDark":false,"contrast":1.7100585291773622},"LightMuted":{"color":"#769ca9","isDark":false,"contrast":2.958324937392382}},"json":"data/posts/2014/08/11/china-weather-radar-crawler.json","tags":[{"name":"Crawler","slug":"Crawler","path":"tags/Crawler/","permalink":"http://catx.me/tags/Crawler/","postCount":1},{"name":"Fun","slug":"Fun","path":"tags/Fun/","permalink":"http://catx.me/tags/Fun/","postCount":2},{"name":"GAE","slug":"GAE","path":"tags/GAE/","permalink":"http://catx.me/tags/GAE/","postCount":1},{"name":"GitHub","slug":"GitHub","path":"tags/GitHub/","permalink":"http://catx.me/tags/GitHub/","postCount":9},{"name":"Python","slug":"Python","path":"tags/Python/","permalink":"http://catx.me/tags/Python/","postCount":1},{"name":"Weather","slug":"Weather","path":"tags/Weather/","permalink":"http://catx.me/tags/Weather/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]},"sha1":"c17ce423e8c15bf6aba00805b8daff91a090f939","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2014/03/20/beat-flappy-2048-with-q-learning.json","path":"2014/03/20/beat-flappy-2048-with-q-learning/","data":{"title":"Beat flappy 2048 with Q Learning","content":"<h2 id=\"u4ECB_u7ECD\"><a href=\"#u4ECB_u7ECD\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>2048这游戏已经被玩坏了，有人把它和Flappy Bird杂交，玩不过不能忍，于是写了个AI玩之。</p>\n<p><img src=\"/images/43e55b43715494ac817795932fe4ab2c5b34268a.png\" alt=\"\"></p>\n<h2 id=\"u6E38_u620F_u6E90_u7801_u4FEE_u6539\"><a href=\"#u6E38_u620F_u6E90_u7801_u4FEE_u6539\" class=\"headerlink\" title=\"游戏源码修改\"></a>游戏源码修改</h2><p>首先需要对游戏进行适当的修改，便于AI获取游戏状态，并输出控制量。</p>\n<p>修改<code>application.js</code>，将几个关键的对象放到<code>windows</code>命名空间中便于访问：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.requestAnimationFrame(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">window</span>.input = KeyboardInputManager;</span><br><span class=\"line\">\t<span class=\"built_in\">window</span>.actuator = HTMLActuator;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.score = LocalScoreManager;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.game = <span class=\"keyword\">new</span> GameManager(<span class=\"number\">4</span>, KeyboardInputManager, HTMLActuator, LocalScoreManager);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>游戏的逻辑主要在<code>game_manager.js</code>中实现：</p>\n<p>游戏中的“鸟”的css class是<code>tile-bird</code>，障碍物的css class是<code>tile-block</code>，在本文中分别简称为<code>bird</code>和<code>block</code>。</p>\n<ul>\n<li>使用<code>game.jump()</code>跳跃</li>\n<li>bird的状态：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>game.birdpos</code></td>\n<td>顶端的y坐标，$[0, 1]$之间，0为顶端</td>\n</tr>\n<tr>\n<td><code>game.birdspd</code></td>\n<td>y方向速度，向下为正</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>在任意时刻，只有4个<code>block</code>分别称为<code>a</code>, <code>b</code>, <code>c</code>和<code>d</code>，<code>a</code>与<code>b</code>,<code>c</code>与<code>d</code>成组，有相同的水平坐标，两组<code>block</code>之间一直保持2个tile的距离。每组block只有3种可能状态：全在上、全在下以及一上一下，因此block的状态由两个0~2之间的数字<code>game.ab</code>, <code>game.cd</code>确定。</li>\n</ul>\n<p>游戏由一个timer驱动，每一帧计算游戏状态的变化，最后调用<code>window.actuator.actuate()</code>方法计算元素位置，重绘游戏。</p>\n<p>在游戏计算出元素位置并重绘后获取状态，并由AI注入控制量是最为便捷的方式。</p>\n<p>修改<code>html_actuator.js</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTMLActuator.prototype.actuate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">grid, metadata</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//.. Other stuff</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Call AI</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.AI.play(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样对原游戏的改动就完成了，接下来只需要实现AI类，并把类对象赋值到<code>window.AI</code>即可。</p>\n<h2 id=\"Q-Learning\"><a href=\"#Q-Learning\" class=\"headerlink\" title=\"Q-Learning\"></a>Q-Learning</h2><p>Q-Learning是一种强化学习算法，能用于寻找Markov决策过程(MDP, Markov decision process)的最优解。<br>MDP问题模型由一个agent，状态$S$以及每个状态对应动作(action)集合$A$构成。Agent通过完成一个动作，从一个状态$S$跳转到另一个状态$S’$，获得一定的奖励。Agent的目标就是使奖励最大化，通过学习在每个状态下最优的动作，达到这个目的。</p>\n<p>算法的核心是矩阵$Q$，记录状态-动作对的奖励：</p>\n<p>$$Q: S \\times A \\rightarrow \\mathbb{R}$$</p>\n<p>算法初始时，$Q$取设计好的值，随后agent每执行一次动作，观察新状态以及获得的奖励，通过如下公式迭代更新：</p>\n<span>$$Q_{t+1}(s_t, a_t) = Q_{t}(s_t, a_t) + \\alpha_{t}(s_t, a_t) \\times [ R_{t+1} + \\gamma \\max Q_{t}(s_{t+1}, a) - Q_{t}(s_t, a_t) ]$$</span><!-- Has MathJax -->\n<p>其中：</p>\n<ul>\n<li>$Q_{t+1}(s_t, a_t)$: 新的$Q$值</li>\n<li>$Q_{t}(s_t, a_t)$: 上一时刻$Q$值</li>\n<li>$R_{t+1}$: 在$s_t$时执行$a_t$后获得的奖励</li>\n<li>$\\alpha \\in [0, 1]$: learning rate</li>\n<li>$\\gamma$: 折扣率</li>\n</ul>\n<h2 id=\"u7B97_u6CD5_u8BBE_u8BA1\"><a href=\"#u7B97_u6CD5_u8BBE_u8BA1\" class=\"headerlink\" title=\"算法设计\"></a>算法设计</h2><ul>\n<li><p>状态：</p>\n<ul>\n<li>$\\Delta y$: <code>bird</code>到能安全通过当前<code>block</code>最高点的垂直距离</li>\n<li>$\\Delta x$: <code>bird</code>到下一个block的水平方向距离</li>\n</ul>\n</li>\n<li><p>动作：</p>\n<ul>\n<li><code>jump</code>: 跳跃</li>\n<li><code>idle</code>: 不动作</li>\n</ul>\n</li>\n<li><p>奖励：</p>\n<ul>\n<li>死亡：<code>-100</code></li>\n<li>存活：<code>1</code></li>\n</ul>\n</li>\n<li><p>$Q$的初始化</p>\n</li>\n</ul>\n<p>虽然可以简单的把$Q$全初始化为0，但这样会延长学习时间。并且在很多情况下，会导致<code>bird</code>一直跳跃直到跳出顶端掉不下来，这样不管是<code>jump</code>还是<code>idle</code>都会被惩罚，这样永远无法学习到正确行为。另外在底部也会有同样的问题。</p>\n<p>实际实现时，加入了先验知识：</p>\n<ul>\n<li>对所有$\\Delta y &lt; y_{min}$的$s$，初始化<code>jump</code>的reward为<code>-100</code>。即在上端时禁止跳跃</li>\n<li><p>对所有$\\Delta y &gt; n * BirdHeight$的$s$，初始化<code>idle</code>的reward为<code>-5</code>，<code>n</code>接近<code>1</code>。即离最高点的距离小于<code>bird</code>自己高度的时候，倾向于跳跃。注意这里的reward值较小，是因为在某些组合下（如当前<code>block</code>在下，下一个<code>block</code>在上），跳跃会挂掉，值如果过大，$Q$值无法及时对惩罚做出反馈。</p>\n</li>\n<li><p>不定状态时的随机参数</p>\n</li>\n</ul>\n<p>在<code>jump</code>和<code>action</code>的reward相等时，无法通过$Q$做出决策，这个时候需要随机决定采取何种行为。</p>\n<p>实际实现时，同样没有简单的将这个概率设为<code>0.5</code>，而是让不跳跃的概率远大于跳跃。道理很简单，游戏的操作方式是不平衡的，玩家只能干预下落，而不能干预上升，掉得太低跳一下就行了，跳得太高就只有等死。</p>\n<h2 id=\"u6548_u679C\"><a href=\"#u6548_u679C\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p>目前实现的版本在未学习的情况下，可以一次跳跃到700+分，学习一小时后可以到1000分，到后面出错都是遇到比较极端的组合差之毫厘，重现概率不高，所以学习速度会变慢。</p>\n<p>玩：<a href=\"http://catx.me/Q-Learning-Flappy-2048/\">Q Learning Flappy 2048</a></p>\n<p>代码：<a href=\"https://github.com/akfish/Q-Learning-Flappy-2048\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n","date":"2014-03-20T10:53:10.000Z","path":"2014/03/20/beat-flappy-2048-with-q-learning/","isDark":true,"featureColor":"#2f5a75","featureImage":"/image/stock/2.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#2f5a75","isDark":true,"contrast":12.293085300100254},"Muted":{"color":"#64767c","isDark":true,"contrast":5.234975288978602},"DarkVibrant":{"color":"#1f4b68","isDark":true,"contrast":13.414009026295917},"DarkMuted":{"color":"#477084","isDark":true,"contrast":5.611238656641319},"LightVibrant":{"color":"#ecdabf","isDark":false,"contrast":1.3683052639522741},"LightMuted":{"color":"#95b1b5","isDark":false,"contrast":2.274202152883682}},"json":"data/posts/2014/03/20/beat-flappy-2048-with-q-learning.json","tags":[{"name":"AI","slug":"AI","path":"tags/AI/","permalink":"http://catx.me/tags/AI/","postCount":1},{"name":"CoffeeScript","slug":"CoffeeScript","path":"tags/CoffeeScript/","permalink":"http://catx.me/tags/CoffeeScript/","postCount":9},{"name":"Fun","slug":"Fun","path":"tags/Fun/","permalink":"http://catx.me/tags/Fun/","postCount":2},{"name":"JavaScript","slug":"JavaScript","path":"tags/JavaScript/","permalink":"http://catx.me/tags/JavaScript/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]},"sha1":"f43631a2a10f38572fe6bed16168d9e8a2d4d76d","isDigest":true}],"sha1":"9183f60b533d7960644aa156f9e3b3e9f92cd65f"}
{"tag":"Algorithm","isDark":false,"type":"tag","path":"tags/Algorithm/","json_base":"data/tags/Algorithm/","json":"data/tags/Algorithm/1.json","current":1,"total":1,"posts":[{"type":"post","json_base":"data/posts","json":"data/posts/2014/08/31/sae-chinese-keyword-extraction-service.json","path":"2014/08/31/sae-chinese-keyword-extraction-service/","data":{"title":"SAE中文关键字提取服务","content":"<p><img src=\"/images/ea44d54a8c5dfedd723e46cf537ac31ab84a791d.png\" alt=\"\"></p>\n<h2 id=\"u4ECB_u7ECD\"><a href=\"#u4ECB_u7ECD\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>SAE提供了效果不错的<a href=\"http://sae.sina.com.cn/doc/python/segment.html\" target=\"_blank\" rel=\"external\">中文分词服务</a>，于是花了点时间做了个基于TF-IDF的关键字提取算法。</p>\n<p>语料库来自<a href=\"http://www.cncorpus.org/\" target=\"_blank\" rel=\"external\">语料库在线</a>。</p>\n<h2 id=\"TF-IDF\"><a href=\"#TF-IDF\" class=\"headerlink\" title=\"TF-IDF\"></a>TF-IDF</h2><p>在把一篇文章分词过后，要从中提取出最能代表文章主题的关键字，最young最simple的办法就是基于词频(TF, term frequency)：</p>\n<p>$$TF(t, d) = f(t, d)$$</p>\n<p>其中$t$为一个单词，$d$为文档，$f(t, d)$为这个单词在文档中出现的频率。</p>\n<p>这样带来的问题很显然，即使通过停止词干掉一些频率极高，但对内容毫无贡献的词汇（如“的、地、得”），依然无法排除某些本身频率就很高的词汇。<br>比如在天朝，“中国”一词在所有文章里都有很高的出现概率，但并不见得所有文章都和天朝相关。</p>\n<p>假如有一个语料库，包含了大量具有代表性的文章。如果一个词汇在这个语料库里大量出现，则认为这个词汇本身就是个高频词；<br>如果一个词汇在语料库里出现频率不高，但在一篇文章里频繁出现，显然这个词汇是这篇文章里特有的。<br>基于这个想法，就引入了IDF(inverse document frequency):<br><span>$$IDF(t, D) = log \\frac{N}{ 1 + \\|\\{d \\in D: t \\in D\\}\\| }$$</span><!-- Has MathJax --></p>\n<p>TF-IDF值，就能用来判断一个词汇是否是一篇文章里的关键字：</p>\n<p>$$ TFIDF = w(t) * TF(t, d) * IDF(t, D) $$</p>\n<p>这里加入了一个权重函数，按词性对词汇进行过滤：<br><span>$$w(t) = \\left\\{\n  \\begin{array}{l l}\n    0.8 & t\\ is\\ v.\\ or\\ n.\\\\\n    0.6 & t\\ is\\ adv.\\ or\\ adj.\\\\\n    0 & other\n  \\end{array} \\right.$$</span><!-- Has MathJax --></p>\n<h2 id=\"u94FE_u63A5\"><a href=\"#u94FE_u63A5\" class=\"headerlink\" title=\"链接\"></a>链接</h2><ul>\n<li><a href=\"http://catx.me/seger-demo/\">Demo</a></li>\n</ul>\n<div id=\"badge-container-akfish-seger-demo-0b5e19\" class=\"hexo-github\" style=\"width: 100%\"></div>\n<script src=\"/hexo-github/badge.js\"></script>\n<script type=\"text/javascript\">\n  loadStyle(\"/hexo-github/style.css\");\n  loadStyle(\"/hexo-github/octicons/octicons.css\");\n  new Badge(\"#badge-container-akfish-seger-demo-0b5e19\", \"akfish\", \"seger-demo\", \"0b5e19\", false);\n</script>\n\n<div id=\"badge-container-akfish-seger-b64d75\" class=\"hexo-github\" style=\"width: 100%\"></div>\n<script src=\"/hexo-github/badge.js\"></script>\n<script type=\"text/javascript\">\n  loadStyle(\"/hexo-github/style.css\");\n  loadStyle(\"/hexo-github/octicons/octicons.css\");\n  new Badge(\"#badge-container-akfish-seger-b64d75\", \"akfish\", \"seger\", \"b64d75\", false);\n</script>\n\n<ul>\n<li><a href=\"https://github.com/akfish/seger-demo\" target=\"_blank\" rel=\"external\">GitHub - Seger Demo</a></li>\n<li><a href=\"https://github.com/akfish/seger\" target=\"_blank\" rel=\"external\">GitHub - Seger</a></li>\n</ul>\n","date":"2014-08-30T22:29:46.000Z","path":"2014/08/31/sae-chinese-keyword-extraction-service/","isDark":true,"featureColor":"#b66d48","featureImage":"/images/word.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#b66d48","isDark":true,"contrast":4.032235245651348},"Muted":{"color":"#846852","isDark":true,"contrast":5.253713678379464},"DarkVibrant":{"color":"#462a1c","isDark":true,"contrast":16.342879549491663},"DarkMuted":{"color":"#3b3435","isDark":true,"contrast":15.84737578931552},"LightMuted":{"color":"#a28c7e","isDark":true,"contrast":3.187235771086366}},"permalink":"http://catx.me/2014/08/31/sae-chinese-keyword-extraction-service/","actions":[{"name":"GitHub","link":"https://github.com/akfish/seger"},{"name":"Demo","link":"http://catx.me/seger-demo/","type":"primary"}],"json":"data/posts/2014/08/31/sae-chinese-keyword-extraction-service.json","tags":[{"name":"Algorithm","slug":"Algorithm","path":"tags/Algorithm/","permalink":"http://catx.me/tags/Algorithm/","postCount":2},{"name":"GitHub","slug":"GitHub","path":"tags/GitHub/","permalink":"http://catx.me/tags/GitHub/","postCount":6},{"name":"NLP","slug":"NLP","path":"tags/NLP/","permalink":"http://catx.me/tags/NLP/","postCount":1},{"name":"SAE","slug":"SAE","path":"tags/SAE/","permalink":"http://catx.me/tags/SAE/","postCount":1}],"categories":[]},"sha1":"d089cdaf772614b3e0ea1cb9a092d818bbfc758c","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280.json","path":"2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280/","data":{"title":"JavaScript随机数生成算法中为什么要用9301, 49297, 233280作为Magic Number","content":"<p>今天在知乎上回答了这样一个问题：<a href=\"http://www.zhihu.com/question/22818104\" target=\"_blank\" rel=\"external\">网上常能见到的一段JS随机数生成算法如下，为什么用9301, 49297, 233280这三个数字做基数？</a></p>\n<p>问题中提到的代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rnd</span>(<span class=\"params\"> seed </span>)</span>&#123;</span><br><span class=\"line\">    seed = ( seed * <span class=\"number\">9301</span> + <span class=\"number\">49297</span> ) % <span class=\"number\">233280</span>; <span class=\"comment\">//Magic!</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> seed / ( <span class=\"number\">233280.0</span> );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rand</span>(<span class=\"params\">number</span>)</span>&#123;</span><br><span class=\"line\">    today = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); </span><br><span class=\"line\">    seed = today.getTime();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.ceil( rnd( seed ) * number );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myNum=(rand(<span class=\"number\">5</span>));</span><br></pre></td></tr></table></figure></p>\n<p>经过一系列的digging，最终找到了这个问题的答案，这三个数的选择是有数学依据的。</p>\n<p><strong>入门级的选择标准</strong><br>这种随机数生成器叫做线性同余生成器（LCG, Linear Congruential Generator)，几乎所有的运行库提供的rand都是采用的LCG，形如：<br><span>$I_{n+1}=aI_n + c\\ (mod\\ m)$</span><!-- Has MathJax --><br>生成的随机数序列最大周期m，生成0到m-1之间的随机数。要达到这个最大周期，必须满足</p>\n<ul>\n<li>c与m互质</li>\n<li>a - 1可以被m的所有质因数整除</li>\n<li>如果m是4的倍数，a - 1也必须是4的倍数<br>以上三条被称为Hull-Dobell定理。<br>作为一个随机数生成器，周期不够大是不好意思混的，所以这是要求之一。<br>可以看到，a=9301, c = 49297, m = 233280这组参数，以上三条全部满足。</li>\n</ul>\n<p><strong>进阶级的选择标准</strong><br>要在随机数生成器界混，仅仅入门是不够的。<br>从工程的角度来讲，$(m - 1)a + c$的值要（在合理的范围内）足够小，以避免溢出的问题。<br>从安全（实用）性的角度来讲，还要满足良好的随机性，这一点可以通过Knunth’s Spectral Test来评估（见[2]），要通过2,3,4,5以及6维的Spectral Test才行。Spectral Test考察的就是生成的随机数序列在超空间的网格结构（lattice structure），当年IBM的RANDU子程序闹出的乌龙，连3维的Spectral Test就不能通过，上图嘲讽下：</p>\n<p><a href=\"http://catx.me/wordpress/wp-content/uploads/2014/02/800px-Randu.png\"><img src=\"/images/bb1858cc61e6b2f8335f68221d141e0f5b289d68.png\" alt=\"800px-Randu\"></a></p>\n<p>其中每个点代表三个连续的RANDU生成的随机数值，可以看到所有随机数分布在了15个二维平面上。</p>\n<p>在这种要求面前，c的值最好：</p>\n<ul>\n<li>是质数 （c = 49297就是质数）</li>\n<li>接近<span>$(\\frac{1}{2}-\\frac{1}{6}\\sqrt{3})m$</span><!-- Has MathJax -->,(m = 233280时为49297.86460172205)<br>所以有了这样一些基本的标准，能够选择的参数范围就小了很多，弄个程序跑下Spectral Test，就能得到可选的参数组：</li>\n</ul>\n<p><a href=\"http://catx.me/wordpress/wp-content/uploads/2014/02/Unnamed-QQ-Screenshot20140222141315.png\"><img src=\"/images/5733d329521f86f7a2d59b5dc895f027ca119a83.png\" alt=\"Magic Number for LCG Random Generator\"></a></p>\n<p>参考资料：<a href=\"http://nuclear.fis.ucm.es/COMP-PHYS/RANDOM/RandomNumbers.pdf\" target=\"_blank\" rel=\"external\">[1]</a><a href=\"http://random.mat.sbg.ac.at/tests/theory/spectral/\" target=\"_blank\" rel=\"external\">[2]</a></p>\n","date":"2014-02-22T07:01:45.000Z","path":"2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280/","isDark":false,"featureColor":"#d19e40","featureImage":"/image/stock/5.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#d19e40","isDark":false,"contrast":2.433412395275077},"Muted":{"color":"#798249","isDark":true,"contrast":4.168289617634703},"DarkVibrant":{"color":"#97623d","isDark":true,"contrast":7.586487507499872},"DarkMuted":{"color":"#5a4e32","isDark":true,"contrast":14.22073373466042},"LightVibrant":{"color":"#d6c395","isDark":false,"contrast":1.7356438765314866},"LightMuted":{"color":"#aea18e","isDark":false,"contrast":2.5336980009663206}},"permalink":"http://catx.me/2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280/","json":"data/posts/2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280.json","tags":[{"name":"Algorithm","slug":"Algorithm","path":"tags/Algorithm/","permalink":"http://catx.me/tags/Algorithm/","postCount":2},{"name":"Magic Number","slug":"Magic-Number","path":"tags/Magic-Number/","permalink":"http://catx.me/tags/Magic-Number/","postCount":1},{"name":"Math","slug":"Math","path":"tags/Math/","permalink":"http://catx.me/tags/Math/","postCount":1},{"name":"Random","slug":"Random","path":"tags/Random/","permalink":"http://catx.me/tags/Random/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":17}]},"sha1":"4594b540043468ede1c7925a4006ccf0bbbaffce","isDigest":true}],"sha1":"7d40ed7c2bbcbef2127c1242675021168398ee90"}
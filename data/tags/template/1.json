{"tag":"template","isDark":false,"type":"tag","path":"tags/template/","json_base":"data/tags/template/","json":"data/tags/template/1.json","current":1,"total":1,"posts":[{"type":"post","json_base":"data/posts","json":"data/posts/2011/09/15/loop-unrolling-cpp.json","path":"2011/09/15/loop-unrolling-cpp/","data":{"title":"关于循环展开优化","content":"<p>这几天蛋疼，下手开始实现一个虚拟机，主要的参考书籍是Bill Blunden的&lt;Virtual Machine Design and Implementation in C/C++&gt;，书中实现了一个基本完整的HEC虚拟机。除了实践一下其中的知识以外，最主要的还是实际调查一下自己对原作者实现中不满意的地方，如果时间和精力足够，再添加没有实现的JIT以及配套的高级语言编译器。</p>\n<p>在Hec的实现中，有一个基本的功能，就是实现虚拟机字节码的endian与native code的endian之间的转换（如果相反），只是简单的颠倒字节顺序。主要在虚拟机加载字节码，开始执行之前调用，直接影响字节码加载到开始执行期间用户的等待时间。</p>\n<p>Blunden为了优化性能，在这部分应用了循环展开[<a href=\"http://en.wikipedia.org/wiki/Loop_unwinding\" title=\"Loop unwinding @ wikipedia\" target=\"_blank\" rel=\"external\">1</a>]技术。本文记录了在开发过程中采用的几种与Blunden不同的实现方法，以及初步的对比。</p>\n<a id=\"more\"></a>\n<p><strong>0. Blunden原始实现</strong></p>\n<p>原始实现提供了一系列单独的bytecodeToTypeName以及typeNameToBytecode全局函数：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">U2 <span class=\"title\">bytecodeToWord</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">U4 <span class=\"title\">bytecodeToDWord</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">U8 <span class=\"title\">bytecodeToQWord</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">F4 <span class=\"title\">bytecodeToFloat</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">F8 <span class=\"title\">bytecodeToDouble</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">wordToBytecode</span><span class=\"params\">(U2 word, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dwordToBytecode</span><span class=\"params\">(U4 dword, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">qwordToBytecode</span><span class=\"params\">(U8 qword, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">floatToBytecode</span><span class=\"params\">(F4 flt, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doubleToBytecode</span><span class=\"params\">(F8 dbl, U1 arr[])</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>其中U代表unsigned，后面的数字代表位长，在win32平台下的定义为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S1\tsigned char</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S2\tsigned short</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S4\tsigned long</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S8\tsigned __int64\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U1\tunsigned char</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U2\tunsigned short</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U4\tunsigned long</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U8\tunsigned __int64</span></span><br></pre></td></tr></table></figure>\n<p>以下仅列举U8版本的qwordToBytecode实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">qwordToBytecode</span><span class=\"params\">(U8 qword, U1 arr[])</span></span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">\tU1 *buffer;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbuffer = (U1*)&amp;amp;qword;</span><br><span class=\"line\">\tarr[<span class=\"number\">0</span>] = buffer[<span class=\"number\">7</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">1</span>] = buffer[<span class=\"number\">6</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">2</span>] = buffer[<span class=\"number\">5</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">3</span>] = buffer[<span class=\"number\">4</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">4</span>] = buffer[<span class=\"number\">3</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">5</span>] = buffer[<span class=\"number\">2</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">6</span>] = buffer[<span class=\"number\">1</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">7</span>] = buffer[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;<span class=\"comment\">/*end qwordToBytecode*/</span></span><br></pre></td></tr></table></figure>\n<p>可以看出Blunden的实现是C Style的，基本上就是一大堆全局函数与变量，缺乏封装性。各个类型的转换函数没有统一的调用接口，而且由于采用了循环展开，导致对每一个类型转换的函数体都非常冗长，整个代码就变成了一大堆重复代码的组合。</p>\n<p>当然这主要是出于性能的考虑，不过考虑到现在的C++编译器的性能已经不再是当年的情况，C++完全可以做到与C相同甚至更好的性能，同时提供更易于维护的代码。实际上，很多C语言写的程序最后也是用C++编译器编译的。</p>\n<p><strong>1.实现一：For Loop</strong></p>\n<p>在讨论优化之前，要有个被优化的对象作为对比，以下是用For循环在一个struct中实现同样的功能：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">typename</span> T&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ForLoopAssign</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &amp;lt; <span class=\"keyword\">sizeof</span>(T); i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tdest[i] = src[<span class=\"keyword\">sizeof</span>(T) - i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里只是最主要的交换赋值部分，采用了模板类，为的是同一个接口实现不同类型转换功能的调用，而不是若干个单独的函数。</p>\n<p>模板类在编译时就会被展开，因此在运行时的性能损耗很小。</p>\n<p>可以看到这段代码的优点是简短，易于维护，几行代码实现了几十行代码的功能。缺点当然是For-Loop造成的性能损耗。</p>\n<p>调用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ForLoopAssign&amp;lt;T&amp;gt;::AssignBytes(src, dest);</span><br></pre></td></tr></table></figure>\n<p><strong>2.实现二：手动循环展开</strong></p>\n<p>Prototype：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">int</span> byteLen&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>特化：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">1</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">2</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">4</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">2</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">3</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">8</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">7</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">6</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">2</span>] = src[<span class=\"number\">5</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">3</span>] = src[<span class=\"number\">4</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">4</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">5</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">6</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">7</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其实就是对C Style实现的C++封装，性能接近原实现，调用只需要一句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExplicitUnrolling&amp;lt;<span class=\"keyword\">sizeof</span>(T)&amp;gt;::AssignBytes(src, dest);</span><br></pre></td></tr></table></figure>\n<p>显然，作为显示实现的代码，也是难于维护的。</p>\n<p><strong>3.实现3：模板元递归</strong></p>\n<p>递归模板：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">int</span> byteN, <span class=\"keyword\">int</span> byteLen&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> AssignByte</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Assign</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[byteN - <span class=\"number\">1</span>] = src[byteLen - byteN];</span><br><span class=\"line\">\t\tAssignByte&amp;lt;byteN - <span class=\"number\">1</span>, byteLen&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>递归边界：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">int</span> byteLen&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> AssignByte&amp;lt;<span class=\"number\">1</span>, byteLen&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Assign</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[byteLen - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AssignByte&amp;lt;<span class=\"keyword\">sizeof</span>(T), <span class=\"keyword\">sizeof</span>(T)&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>\n<p>和For Loop实现相比，这段代码只长了几句，但是却实现了循环展开。</p>\n<p>以U4为例，调用的时候实际上是：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">4</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>\n<p>在Assign函数体中形成递归调用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dest[<span class=\"number\">4</span> - byteLen] = src[<span class=\"number\">4</span> - byteLen];</span><br><span class=\"line\"><span class=\"comment\">//递归调用</span></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">4</span> - <span class=\"number\">1</span>, byteLen&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>\n<p>直到传入的byteN == 1到达递归边界。</p>\n<p>但这个递归是在编译时进行的，实际上是编译器递归的生成了如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">4</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">3</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\tAssignByte&amp;lt;<span class=\"number\">3</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">3</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">2</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\tAssignByte&amp;lt;<span class=\"number\">2</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">2</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">\tAssignByte&amp;lt;<span class=\"number\">1</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">1</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以在运行时没有任何递归，只是一系列的函数调用，但更妙的是对于足够短的函数体，编译器会自动进行inline优化，省略函数调用，以上代码最后编译后等效于人肉实现的循环展开。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dest[<span class=\"number\">0</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">dest[<span class=\"number\">1</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">dest[<span class=\"number\">2</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">dest[<span class=\"number\">3</span>] = src[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>这种方法最后做到了与For Loop相近长度的易于维护的代码，以及（理论上）与人肉循环展开一致的性能。</p>\n<p><strong>4.测试与结果分析</strong></p>\n<p>测试代码分别调用以上3种实现100000000、1000000000、10000000000次，记录执行时间。</p>\n<p>测试平台：Windows 7 Ultimate 32bit + Visual Studio 2010</p>\n<p>Release Build:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----------------------------------&#10;Test U2&#10;For-Loop x100000000: 207&#10;Template x100000000: 88&#10;Explicit x100000000: 119&#10;&#10;Test U4&#10;For-Loop x100000000: 183&#10;Template x100000000: 85&#10;Explicit x100000000: 93&#10;&#10;Test U8&#10;For-Loop x100000000: 182&#10;Template x100000000: 86&#10;Explicit x100000000: 86&#10;&#10;----------------------------------&#10;Test U2&#10;For-Loop x1000000000: 1768&#10;Template x1000000000: 878&#10;Explicit x1000000000: 1169&#10;&#10;Test U4&#10;For-Loop x1000000000: 1796&#10;Template x1000000000: 879&#10;Explicit x1000000000: 882&#10;&#10;Test U8&#10;For-Loop x1000000000: 1760&#10;Template x1000000000: 881&#10;Explicit x1000000000: 893&#10;&#10;----------------------------------&#10;Test U2&#10;For-Loop x10000000000: 13508&#10;Template x10000000000: 7648&#10;Explicit x10000000000: 13349&#10;&#10;Test U4&#10;For-Loop x10000000000: 12094&#10;Template x10000000000: 6005&#10;Explicit x10000000000: 6267&#10;&#10;Test U8&#10;For-Loop x10000000000: 12075&#10;Template x10000000000: 5914&#10;Explicit x10000000000: 6314</span><br></pre></td></tr></table></figure></p>\n<p>输出中For Loop为循环实现，Template为模板元递归实现，Explicit为人肉实现。</p>\n<p>可以看到，For loop不出意外的慢。</p>\n<p>在Release Build模式下，模板元递归的性能与人肉循环展开一致，甚至在位长等于2的类型中优于后者，这应该是编译器优化造成的（待考）。</p>\n<p>在Debug Build模式下出现了反常，模板元递归实现的执行时间意外的比人肉实现慢：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-------------------------------------------&#10;Test U2&#10;For-Loop x100000000: 5187&#10;Template x100000000: 9629&#10;Explicit x100000000: 3576&#10;&#10;Test U4&#10;For-Loop x100000000: 4821&#10;Template x100000000: 16005&#10;Explicit x100000000: 3533&#10;&#10;Test U8&#10;For-Loop x100000000: 7009&#10;Template x100000000: 28891&#10;Explicit x100000000: 4171&#10;&#10;-------------------------------------------</span><br></pre></td></tr></table></figure>\n<p>查看Disassemblely：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//static inline void Assign(const U1 src[], U1 dest[])&#10;//&#123;&#10;01156D30  push        ebp&#10;01156D31  mov         ebp,esp&#10;01156D33  sub         esp,0C0h&#10;01156D39  push        ebx&#10;01156D3A  push        esi&#10;01156D3B  push        edi&#10;01156D3C  lea         edi,[ebp-0C0h]&#10;01156D42  mov         ecx,30h&#10;01156D47  mov         eax,0CCCCCCCCh&#10;01156D4C  rep stos    dword ptr es:[edi]&#10;//&#9;dest[byteN - 1] = src[byteLen - byteN];&#10;01156D4E  mov         eax,dword ptr [dest]&#10;01156D51  mov         ecx,dword ptr [src]&#10;01156D54  mov         dl,byte ptr [ecx]&#10;01156D56  mov         byte ptr [eax+1],dl&#10;//&#9;AssignByte&#38;lt;byteN - 1, byteLen&#38;gt;::Assign(src, dest);&#10;01156D59  mov         eax,dword ptr [dest]&#10;01156D5C  push        eax&#10;01156D5D  mov         ecx,dword ptr [src]&#10;01156D60  push        ecx&#10;01156D61  call        AssignByte&#38;lt;1,2&#38;gt;::Assign (11511FEh)&#10;01156D66  add         esp,8&#10;//&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出造成反常的原因是编译器为了便于debug，并没有进行inline优化，依然是函数调用。</p>\n<p>另外Debug模式会插入许多额外代码方便调试器，因此造成了整体性能的下降。</p>\n<p><strong>5.小结</strong></p>\n<p>因为偷懒，本文并未比较C实现与C++实现之间的性能差异，虽然有理由相信实现一中结构体静态成员函数调用的成本与C全局函数调用成本不相上下，但仍然是不严密之处。</p>\n<p>仅就3种实现的对比而言，可以确定的是：</p>\n<p>a.循环展开优化是有效果的</p>\n<p>b.执行成本：函数调用&gt;循环&gt;展开后代码</p>\n<p>c.实际优化结果结果依赖于编译器以及编译模式</p>\n<p>&nbsp;</p>\n","date":"2011-09-15T01:00:52.000Z","path":"2011/09/15/loop-unrolling-cpp/","isDark":false,"featureColor":"#a99a48","featureImage":"/image/stock/7.jpg","excerpt":"<p>这几天蛋疼，下手开始实现一个虚拟机，主要的参考书籍是Bill Blunden的&lt;Virtual Machine Design and Implementation in C/C++&gt;，书中实现了一个基本完整的HEC虚拟机。除了实践一下其中的知识以外，最主要的还是实际调查一下自己对原作者实现中不满意的地方，如果时间和精力足够，再添加没有实现的JIT以及配套的高级语言编译器。</p>\n<p>在Hec的实现中，有一个基本的功能，就是实现虚拟机字节码的endian与native code的endian之间的转换（如果相反），只是简单的颠倒字节顺序。主要在虚拟机加载字节码，开始执行之前调用，直接影响字节码加载到开始执行期间用户的等待时间。</p>\n<p>Blunden为了优化性能，在这部分应用了循环展开[<a href=\"http://en.wikipedia.org/wiki/Loop_unwinding\" title=\"Loop unwinding @ wikipedia\">1</a>]技术。本文记录了在开发过程中采用的几种与Blunden不同的实现方法，以及初步的对比。</p>","featureSwatch":{"Vibrant":{"color":"#a99a48","isDark":false,"contrast":2.8607233160176517},"Muted":{"color":"#b7ac6a","isDark":false,"contrast":2.3019786002998246},"DarkVibrant":{"color":"#8a7133","isDark":true,"contrast":4.70318580028283},"DarkMuted":{"color":"#534c37","isDark":true,"contrast":14.371837375676147},"LightVibrant":{"color":"#e4dcc3","isDark":false,"contrast":1.3703902496024831},"LightMuted":{"color":"#aba790","isDark":false,"contrast":2.4244396488445554}},"json":"data/posts/2011/09/15/loop-unrolling-cpp.json","tags":[{"name":"C++","slug":"C","path":"tags/C/","permalink":"http://catx.me/tags/C/","postCount":2},{"name":"VM","slug":"VM","path":"tags/VM/","permalink":"http://catx.me/tags/VM/","postCount":1},{"name":"optimization","slug":"optimization","path":"tags/optimization/","permalink":"http://catx.me/tags/optimization/","postCount":1},{"name":"template","slug":"template","path":"tags/template/","permalink":"http://catx.me/tags/template/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":17}]},"sha1":"ea9379cd2e10f9c71db1660d917b96bb7ab96696","isDigest":true}],"sha1":"8d6380e0e993e793ab724f01f9b189b62d14b4ec"}
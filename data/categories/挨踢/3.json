{"category":"挨踢","isDark":false,"type":"category","path":"categories/挨踢/page/3/","json_base":"data/categories/挨踢/","json":"data/categories/挨踢/3.json","prev":"data/categories/挨踢/2.json","current":3,"total":3,"posts":[{"type":"post","json_base":"data/posts","json":"data/posts/2013/09/30/douban-fm-api.json","path":"2013/09/30/douban-fm-api/","data":{"title":"豆瓣电台API分析","content":"<p>前几天看到命令行版的电台<a href=\"http://cmd.fm\" target=\"_blank\" rel=\"external\">cmd.fm</a>，表示键盘党最爱。<br>可惜音乐都是来自sound cloud，大天朝的重口味和网速各种水土不服，于是首先想到的就是要山寨个用豆瓣电台音乐的版本。<br>豆瓣毫无悬念的没有公开API，不过这个完全不影响抓包分析，完整的文档放在GitHub <a href=\"https://github.com/akfish/fm-terminal/blob/develop/douban-fm-api.md\" target=\"_blank\" rel=\"external\">Douban FM API Documentation</a>。</p>\n<p>现在已经用这个API做了一个命令行风格豆瓣电台的Chrome插件，<a href=\"http://fm.catx.me\" target=\"_blank\" rel=\"external\">FM Terminal</a>。</p>\n<p>所有的音乐都是防盗链的，所以Web应用的可能性不大。略诡异的是放出红心的概率比较低，不像官方版的那么容易陷入红心无法自拔。</p>\n<p>其中比较有意思的是两点，一是广告很容易和其它普通、二逼或者文艺的音乐区分开来。<br>另一个是豆瓣<a href=\"https://github.com/akfish/fm-terminal/blob/develop/douban-fm-api.md#discussion-of-history-parameter\" target=\"_blank\" rel=\"external\">追踪用户播放行为的方式</a>，正常播放完成的音乐豆瓣不关心，只对加红心、丢垃圾桶和跳过这样的“异常”行为感兴趣。传回去的记录是时序的，说明后台的算法应该是和时序有关的。</p>\n<p>不过我只想说，敢不敢让广告也能加心拖垃圾桶，挖掘下用户爱看神马广告。</p>\n<p>&nbsp;</p>\n","date":"2013-09-30T03:27:48.000Z","path":"2013/09/30/douban-fm-api/","isDark":true,"featureColor":"#2b6a7d","featureImage":"/image/stock/3.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#2b6a7d","isDark":true,"contrast":6.152506571402196},"Muted":{"color":"#628d9b","isDark":true,"contrast":3.8818866665042275},"DarkVibrant":{"color":"#08536a","isDark":true,"contrast":13.30121420712154},"DarkMuted":{"color":"#4d7e8e","isDark":true,"contrast":4.693454244598322},"LightVibrant":{"color":"#74d4e4","isDark":false,"contrast":1.7100585291773622},"LightMuted":{"color":"#769ca9","isDark":false,"contrast":2.958324937392382}},"json":"data/posts/2013/09/30/douban-fm-api.json","tags":[{"name":"GitHub","slug":"GitHub","path":"tags/GitHub/","permalink":"http://catx.me/tags/GitHub/","postCount":9},{"name":"前端","slug":"前端","path":"tags/前端/","permalink":"http://catx.me/tags/前端/","postCount":2},{"name":"豆瓣","slug":"豆瓣","path":"tags/豆瓣/","permalink":"http://catx.me/tags/豆瓣/","postCount":1},{"name":"逆向","slug":"逆向","path":"tags/逆向/","permalink":"http://catx.me/tags/逆向/","postCount":1},{"name":"音乐","slug":"音乐","path":"tags/音乐/","permalink":"http://catx.me/tags/音乐/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]},"sha1":"7838c01ac683b065efd9d6a5b65c83b6fb2b80d3","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2013/02/05/cuda5-visual-studio-2012-fix.json","path":"2013/02/05/cuda5-visual-studio-2012-fix/","data":{"title":"GPU并行编程CUDA5.0+Visual Studio 2012环境配置","content":"<h1 id=\"u95EE_u9898\"><a href=\"#u95EE_u9898\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>CUDA5.0并不支持Visual Studio 2012的v110 toolchain，所以在安装后尝试编译，会先后遇到如下的错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvcc : fatal error : &#39;-ccbin&#39;: expected a number&#10;**nvcc fatal : nvcc cannot find a supported cl version. Only MSVC 8.0 and MSVC 9.0 are supported**</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"u89E3_u51B3_u65B9_u6848_uFF1A\"><a href=\"#u89E3_u51B3_u65B9_u6848_uFF1A\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h1><h2 id=\"1-_u90E8_u7F72/_u4FEE_u6539_u914D_u7F6E_u6587_u4EF6\"><a href=\"#1-_u90E8_u7F72/_u4FEE_u6539_u914D_u7F6E_u6587_u4EF6\" class=\"headerlink\" title=\"1.部署/修改配置文件\"></a>1.部署/修改配置文件</h2><p>在C\\:\\Program Files (x86)\\MSBuild\\Microsoft.Cpp\\v4.0\\V110\\BuildCustomizations文件夹中是MSBuild要完成编译的自定义配置文件，需要手动部署（拷贝）到C:\\Program Files (x86)\\MSBuild\\Microsoft.Cpp\\v4.0\\V110\\BuildCustomizations文件夹下。本文中路径为Win7 64bit默认安装后的路径，根据自己的安装情况调整。</p>\n<p>在这之前需要修改如下文件：</p>\n<p><strong>CUDA5.0.props中</strong></p>\n<p>找到如下行：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;lt;CudaClVersion Condition=\"'$(PlatformToolset)' == 'v90'\"&amp;gt;2008&amp;lt;/CudaClVersion&amp;gt;</span><br><span class=\"line\">&amp;lt;CudaClVersion Condition=\"'$(PlatformToolset)' == 'v100'\"&amp;gt;2010&amp;lt;/CudaClVersion&amp;gt;</span><br></pre></td></tr></table></figure>\n<p>添加：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;lt;CudaClVersion Condition=\"'$(PlatformToolset)' == 'v110'\"&amp;gt;2010&amp;lt;/CudaClVersion&amp;gt;</span><br></pre></td></tr></table></figure>\n<p><strong>CUDA 5.0.targets中</strong></p>\n<p>找到CudaCleanDependsOn标签，改为：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;lt;CudaCleanDependsOn&amp;gt;</span><br><span class=\"line\">  $(CudaCompileDependsOn);</span><br><span class=\"line\">  _SelectedFiles;</span><br><span class=\"line\">  CudaFilterSelectedFiles;</span><br><span class=\"line\">  AddCudaCompileMetadata;</span><br><span class=\"line\">  AddCudaLinkMetadata;</span><br><span class=\"line\">  AddCudaCompileDeps;</span><br><span class=\"line\">  AddCudaCompilePropsDeps;</span><br><span class=\"line\">  ValidateCudaBuild;</span><br><span class=\"line\">  ValidateCudaCodeGeneration;</span><br><span class=\"line\">  ComputeCudaCompileOutput;</span><br><span class=\"line\">  PrepareForCudaBuild</span><br><span class=\"line\">&amp;lt;/CudaCleanDependsOn&amp;gt;</span><br></pre></td></tr></table></figure>\n<p>找到GenerateRelocatableDeviceCode，改为</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GenerateRelocatableDeviceCode=\"%(CudaCompile.GenerateRelocatableDeviceCode)\"</span><br></pre></td></tr></table></figure>\n<p>找到CodeGeneration，改为</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CodeGeneration=\"%(CudaCompile.CodeGenerationValues)\"</span><br></pre></td></tr></table></figure>\n<p>找到CommandLineTemplate，改为</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CommandLineTemplate=\"\"$(CudaToolkitNvccPath)\" %(CudaCompile.BuildCommandLineTemplate) %(CudaCompile.ApiCommandLineTemplate) %(CudaCompile.CleanCommandLineTemplate)\" /&amp;gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-__u4FEE_u6539_u5934_u6587_u4EF6\"><a href=\"#2-__u4FEE_u6539_u5934_u6587_u4EF6\" class=\"headerlink\" title=\"2. 修改头文件\"></a>2. 修改头文件</h2><p>C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.0\\include文件夹中，host_config.h文件。</p>\n<p>找到</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">if</span> _MSC_VER &amp;lt; <span class=\"number\">1400</span> || _MSC_VER &amp;gt; <span class=\"number\">1600</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">error</span> -- unsupported MSVC version! Only MSVC <span class=\"number\">8.0</span>, <span class=\"number\">9.0</span>, and <span class=\"number\">10.0</span> are supported!</span></span><br></pre></td></tr></table></figure>\n<p>修改为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">if</span> _MSC_VER &amp;lt; <span class=\"number\">1400</span> || _MSC_VER &amp;gt; <span class=\"number\">1700</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">error</span> -- unsupported MSVC version! Only MSVC <span class=\"number\">8.0</span>, <span class=\"number\">9.0</span>, and <span class=\"number\">10.0</span> are supported!</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-__u8BED_u6CD5_u9AD8_u4EAE_u652F_u6301\"><a href=\"#3-__u8BED_u6CD5_u9AD8_u4EAE_u652F_u6301\" class=\"headerlink\" title=\"3. 语法高亮支持\"></a>3. 语法高亮支持</h2><ol>\n<li>菜单“Tools-&gt;Options…”，展开左侧“Text Editor”，点击“File Extension”.</li>\n<li>在“Extension”框中输入“cu”, 选择“Microsoft Visual C++”，点击“Add”，捅“OK”。</li>\n<li>重新打开文件</li>\n</ol>\n<p>## </p>\n","date":"2013-02-05T03:37:57.000Z","path":"2013/02/05/cuda5-visual-studio-2012-fix/","isDark":true,"featureColor":"#947444","featureImage":"/image/stock/4.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#947444","isDark":true,"contrast":4.38675255709906},"Muted":{"color":"#8b704c","isDark":true,"contrast":4.720403801183811},"DarkVibrant":{"color":"#2c2214","isDark":true,"contrast":17.310047977134303},"DarkMuted":{"color":"#3e3121","isDark":true,"contrast":16.064607088557274},"LightVibrant":{"color":"#dcac74","isDark":false,"contrast":2.059564738834789}},"json":"data/posts/2013/02/05/cuda5-visual-studio-2012-fix.json","tags":[{"name":"CUDA","slug":"CUDA","path":"tags/CUDA/","permalink":"http://catx.me/tags/CUDA/","postCount":1},{"name":"GPU","slug":"GPU","path":"tags/GPU/","permalink":"http://catx.me/tags/GPU/","postCount":1},{"name":"Visual Studio 2012","slug":"Visual-Studio-2012","path":"tags/Visual-Studio-2012/","permalink":"http://catx.me/tags/Visual-Studio-2012/","postCount":2}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]},"sha1":"39ec1ac0fa60b1476d4dc20d9d1ac52eb6cdc4fe","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2012/05/11/windows-sudo-batch.json","path":"2012/05/11/windows-sudo-batch/","data":{"title":"用批处理在Windows下实现sudo命令","content":"<p>在Windows下运行某些命令的时候，必须要管理员权限。每次要重新选择“以管理员权限运行”很不方便而且没有效率，于是写了一个批处理文件，实现类似Linux下的sudo命令。</p>\n<p>保存为sudo.bat，放在环境变量PATH中指定的任意一个文件夹下，在命令行窗口中输入：</p>\n<blockquote>\n<p>sudo [command line]</p>\n</blockquote>\n<p>就会出现UAC对话框，确认后就会以管理员权限执行指定的命令。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Echo off&#10;:: Check for permissions&#10;&#38;gt;nul 2&#38;gt;&#38;amp;1 &#34;%SYSTEMROOT%\\system32\\cacls.exe&#34; &#34;%SYSTEMROOT%\\system32\\config\\system&#34;&#10;&#10;:: If error flag set, we do not have admin.&#10;if &#39;%errorlevel%&#39; NEQ &#39;0&#39; (&#10;Echo Requesting administrative privileges...&#10;goto UACPrompt&#10;) else ( goto gotAdmin )&#10;&#10;:UACPrompt&#10;Echo Set UAC = CreateObject^(&#34;Shell.Application&#34;^) &#38;gt; &#34;%temp%\\getadmin.vbs&#34;&#10;Echo UAC.ShellExecute &#34;%~s0&#34;, &#34;%*&#34;, &#34;&#34;, &#34;runas&#34;, 1 &#38;gt;&#38;gt; &#34;%temp%\\getadmin.vbs&#34;&#10;&#10;&#34;%temp%\\getadmin.vbs&#34;&#10;Exit &#10;&#10;:gotAdmin&#10;if exist &#34;%temp%\\getadmin.vbs&#34; ( Del &#34;%temp%\\getadmin.vbs&#34; )&#10;Pushd &#34;%CD%&#34;&#10;CD /D &#34;%~dp0&#34;&#10;:--------------------------------------&#10;cmd.exe /k %*</span><br></pre></td></tr></table></figure>\n<p>类似的也可以用ls.bat来模拟Linux的ls命令，就不用担心习惯ls手抖打错了：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@echo off&#10;dir %*</span><br></pre></td></tr></table></figure>\n","date":"2012-05-11T04:00:43.000Z","path":"2012/05/11/windows-sudo-batch/","isDark":true,"featureColor":"#266cb4","featureImage":"/image/stock/1.jpg","excerpt":"<p>在Windows下运行某些命令的时候，必须要管理员权限。每次要重新选择“以管理员权限运行”很不方便而且没有效率，于是写了一个批处理文件，实现类似Linux下的sudo命令。</p>\n<p>保存为sudo.bat，放在环境变量PATH中指定的任意一个文件夹下，在命令行窗口中输入：</p>\n<blockquote>\n<p>sudo [command line]</p>\n</blockquote>\n<p>就会出现UAC对话框，确认后就会以管理员权限执行指定的命令。</p>","featureSwatch":{"Vibrant":{"color":"#266cb4","isDark":true,"contrast":5.450121616568956},"Muted":{"color":"#4b70a6","isDark":true,"contrast":5.296212493095912},"DarkVibrant":{"color":"#3260a1","isDark":true,"contrast":10.521199995853594},"DarkMuted":{"color":"#515787","isDark":true,"contrast":11.462157427934459},"LightVibrant":{"color":"#5791c6","isDark":true,"contrast":3.512948192359975},"LightMuted":{"color":"#9bb4cc","isDark":false,"contrast":2.144138719552091}},"json":"data/posts/2012/05/11/windows-sudo-batch.json","tags":[{"name":"Linux","slug":"Linux","path":"tags/Linux/","permalink":"http://catx.me/tags/Linux/","postCount":1},{"name":"sudo","slug":"sudo","path":"tags/sudo/","permalink":"http://catx.me/tags/sudo/","postCount":1},{"name":"命令行","slug":"命令行","path":"tags/命令行/","permalink":"http://catx.me/tags/命令行/","postCount":1},{"name":"管理","slug":"管理","path":"tags/管理/","permalink":"http://catx.me/tags/管理/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]},"sha1":"872807fe615e745e86f8f737f22de590a48520f0","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2011/09/15/loop-unrolling-cpp.json","path":"2011/09/15/loop-unrolling-cpp/","data":{"title":"关于循环展开优化","content":"<p>这几天蛋疼，下手开始实现一个虚拟机，主要的参考书籍是Bill Blunden的&lt;Virtual Machine Design and Implementation in C/C++&gt;，书中实现了一个基本完整的HEC虚拟机。除了实践一下其中的知识以外，最主要的还是实际调查一下自己对原作者实现中不满意的地方，如果时间和精力足够，再添加没有实现的JIT以及配套的高级语言编译器。</p>\n<p>在Hec的实现中，有一个基本的功能，就是实现虚拟机字节码的endian与native code的endian之间的转换（如果相反），只是简单的颠倒字节顺序。主要在虚拟机加载字节码，开始执行之前调用，直接影响字节码加载到开始执行期间用户的等待时间。</p>\n<p>Blunden为了优化性能，在这部分应用了循环展开[<a href=\"http://en.wikipedia.org/wiki/Loop_unwinding\" title=\"Loop unwinding @ wikipedia\" target=\"_blank\" rel=\"external\">1</a>]技术。本文记录了在开发过程中采用的几种与Blunden不同的实现方法，以及初步的对比。</p>\n<a id=\"more\"></a>\n<p><strong>0. Blunden原始实现</strong></p>\n<p>原始实现提供了一系列单独的bytecodeToTypeName以及typeNameToBytecode全局函数：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">U2 <span class=\"title\">bytecodeToWord</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">U4 <span class=\"title\">bytecodeToDWord</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">U8 <span class=\"title\">bytecodeToQWord</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">F4 <span class=\"title\">bytecodeToFloat</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">F8 <span class=\"title\">bytecodeToDouble</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">wordToBytecode</span><span class=\"params\">(U2 word, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dwordToBytecode</span><span class=\"params\">(U4 dword, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">qwordToBytecode</span><span class=\"params\">(U8 qword, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">floatToBytecode</span><span class=\"params\">(F4 flt, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doubleToBytecode</span><span class=\"params\">(F8 dbl, U1 arr[])</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>其中U代表unsigned，后面的数字代表位长，在win32平台下的定义为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S1\tsigned char</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S2\tsigned short</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S4\tsigned long</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S8\tsigned __int64\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U1\tunsigned char</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U2\tunsigned short</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U4\tunsigned long</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U8\tunsigned __int64</span></span><br></pre></td></tr></table></figure>\n<p>以下仅列举U8版本的qwordToBytecode实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">qwordToBytecode</span><span class=\"params\">(U8 qword, U1 arr[])</span></span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">\tU1 *buffer;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbuffer = (U1*)&amp;amp;qword;</span><br><span class=\"line\">\tarr[<span class=\"number\">0</span>] = buffer[<span class=\"number\">7</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">1</span>] = buffer[<span class=\"number\">6</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">2</span>] = buffer[<span class=\"number\">5</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">3</span>] = buffer[<span class=\"number\">4</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">4</span>] = buffer[<span class=\"number\">3</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">5</span>] = buffer[<span class=\"number\">2</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">6</span>] = buffer[<span class=\"number\">1</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">7</span>] = buffer[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;<span class=\"comment\">/*end qwordToBytecode*/</span></span><br></pre></td></tr></table></figure>\n<p>可以看出Blunden的实现是C Style的，基本上就是一大堆全局函数与变量，缺乏封装性。各个类型的转换函数没有统一的调用接口，而且由于采用了循环展开，导致对每一个类型转换的函数体都非常冗长，整个代码就变成了一大堆重复代码的组合。</p>\n<p>当然这主要是出于性能的考虑，不过考虑到现在的C++编译器的性能已经不再是当年的情况，C++完全可以做到与C相同甚至更好的性能，同时提供更易于维护的代码。实际上，很多C语言写的程序最后也是用C++编译器编译的。</p>\n<p><strong>1.实现一：For Loop</strong></p>\n<p>在讨论优化之前，要有个被优化的对象作为对比，以下是用For循环在一个struct中实现同样的功能：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">typename</span> T&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ForLoopAssign</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &amp;lt; <span class=\"keyword\">sizeof</span>(T); i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tdest[i] = src[<span class=\"keyword\">sizeof</span>(T) - i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里只是最主要的交换赋值部分，采用了模板类，为的是同一个接口实现不同类型转换功能的调用，而不是若干个单独的函数。</p>\n<p>模板类在编译时就会被展开，因此在运行时的性能损耗很小。</p>\n<p>可以看到这段代码的优点是简短，易于维护，几行代码实现了几十行代码的功能。缺点当然是For-Loop造成的性能损耗。</p>\n<p>调用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ForLoopAssign&amp;lt;T&amp;gt;::AssignBytes(src, dest);</span><br></pre></td></tr></table></figure>\n<p><strong>2.实现二：手动循环展开</strong></p>\n<p>Prototype：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">int</span> byteLen&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>特化：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">1</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">2</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">4</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">2</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">3</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">8</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">7</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">6</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">2</span>] = src[<span class=\"number\">5</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">3</span>] = src[<span class=\"number\">4</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">4</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">5</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">6</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">7</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其实就是对C Style实现的C++封装，性能接近原实现，调用只需要一句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExplicitUnrolling&amp;lt;<span class=\"keyword\">sizeof</span>(T)&amp;gt;::AssignBytes(src, dest);</span><br></pre></td></tr></table></figure>\n<p>显然，作为显示实现的代码，也是难于维护的。</p>\n<p><strong>3.实现3：模板元递归</strong></p>\n<p>递归模板：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">int</span> byteN, <span class=\"keyword\">int</span> byteLen&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> AssignByte</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Assign</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[byteN - <span class=\"number\">1</span>] = src[byteLen - byteN];</span><br><span class=\"line\">\t\tAssignByte&amp;lt;byteN - <span class=\"number\">1</span>, byteLen&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>递归边界：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">int</span> byteLen&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> AssignByte&amp;lt;<span class=\"number\">1</span>, byteLen&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Assign</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[byteLen - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AssignByte&amp;lt;<span class=\"keyword\">sizeof</span>(T), <span class=\"keyword\">sizeof</span>(T)&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>\n<p>和For Loop实现相比，这段代码只长了几句，但是却实现了循环展开。</p>\n<p>以U4为例，调用的时候实际上是：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">4</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>\n<p>在Assign函数体中形成递归调用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dest[<span class=\"number\">4</span> - byteLen] = src[<span class=\"number\">4</span> - byteLen];</span><br><span class=\"line\"><span class=\"comment\">//递归调用</span></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">4</span> - <span class=\"number\">1</span>, byteLen&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>\n<p>直到传入的byteN == 1到达递归边界。</p>\n<p>但这个递归是在编译时进行的，实际上是编译器递归的生成了如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">4</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">3</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\tAssignByte&amp;lt;<span class=\"number\">3</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">3</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">2</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\tAssignByte&amp;lt;<span class=\"number\">2</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">2</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">\tAssignByte&amp;lt;<span class=\"number\">1</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">1</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以在运行时没有任何递归，只是一系列的函数调用，但更妙的是对于足够短的函数体，编译器会自动进行inline优化，省略函数调用，以上代码最后编译后等效于人肉实现的循环展开。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dest[<span class=\"number\">0</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">dest[<span class=\"number\">1</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">dest[<span class=\"number\">2</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">dest[<span class=\"number\">3</span>] = src[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>这种方法最后做到了与For Loop相近长度的易于维护的代码，以及（理论上）与人肉循环展开一致的性能。</p>\n<p><strong>4.测试与结果分析</strong></p>\n<p>测试代码分别调用以上3种实现100000000、1000000000、10000000000次，记录执行时间。</p>\n<p>测试平台：Windows 7 Ultimate 32bit + Visual Studio 2010</p>\n<p>Release Build:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----------------------------------&#10;Test U2&#10;For-Loop x100000000: 207&#10;Template x100000000: 88&#10;Explicit x100000000: 119&#10;&#10;Test U4&#10;For-Loop x100000000: 183&#10;Template x100000000: 85&#10;Explicit x100000000: 93&#10;&#10;Test U8&#10;For-Loop x100000000: 182&#10;Template x100000000: 86&#10;Explicit x100000000: 86&#10;&#10;----------------------------------&#10;Test U2&#10;For-Loop x1000000000: 1768&#10;Template x1000000000: 878&#10;Explicit x1000000000: 1169&#10;&#10;Test U4&#10;For-Loop x1000000000: 1796&#10;Template x1000000000: 879&#10;Explicit x1000000000: 882&#10;&#10;Test U8&#10;For-Loop x1000000000: 1760&#10;Template x1000000000: 881&#10;Explicit x1000000000: 893&#10;&#10;----------------------------------&#10;Test U2&#10;For-Loop x10000000000: 13508&#10;Template x10000000000: 7648&#10;Explicit x10000000000: 13349&#10;&#10;Test U4&#10;For-Loop x10000000000: 12094&#10;Template x10000000000: 6005&#10;Explicit x10000000000: 6267&#10;&#10;Test U8&#10;For-Loop x10000000000: 12075&#10;Template x10000000000: 5914&#10;Explicit x10000000000: 6314</span><br></pre></td></tr></table></figure></p>\n<p>输出中For Loop为循环实现，Template为模板元递归实现，Explicit为人肉实现。</p>\n<p>可以看到，For loop不出意外的慢。</p>\n<p>在Release Build模式下，模板元递归的性能与人肉循环展开一致，甚至在位长等于2的类型中优于后者，这应该是编译器优化造成的（待考）。</p>\n<p>在Debug Build模式下出现了反常，模板元递归实现的执行时间意外的比人肉实现慢：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-------------------------------------------&#10;Test U2&#10;For-Loop x100000000: 5187&#10;Template x100000000: 9629&#10;Explicit x100000000: 3576&#10;&#10;Test U4&#10;For-Loop x100000000: 4821&#10;Template x100000000: 16005&#10;Explicit x100000000: 3533&#10;&#10;Test U8&#10;For-Loop x100000000: 7009&#10;Template x100000000: 28891&#10;Explicit x100000000: 4171&#10;&#10;-------------------------------------------</span><br></pre></td></tr></table></figure>\n<p>查看Disassemblely：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//static inline void Assign(const U1 src[], U1 dest[])&#10;//&#123;&#10;01156D30  push        ebp&#10;01156D31  mov         ebp,esp&#10;01156D33  sub         esp,0C0h&#10;01156D39  push        ebx&#10;01156D3A  push        esi&#10;01156D3B  push        edi&#10;01156D3C  lea         edi,[ebp-0C0h]&#10;01156D42  mov         ecx,30h&#10;01156D47  mov         eax,0CCCCCCCCh&#10;01156D4C  rep stos    dword ptr es:[edi]&#10;//&#9;dest[byteN - 1] = src[byteLen - byteN];&#10;01156D4E  mov         eax,dword ptr [dest]&#10;01156D51  mov         ecx,dword ptr [src]&#10;01156D54  mov         dl,byte ptr [ecx]&#10;01156D56  mov         byte ptr [eax+1],dl&#10;//&#9;AssignByte&#38;lt;byteN - 1, byteLen&#38;gt;::Assign(src, dest);&#10;01156D59  mov         eax,dword ptr [dest]&#10;01156D5C  push        eax&#10;01156D5D  mov         ecx,dword ptr [src]&#10;01156D60  push        ecx&#10;01156D61  call        AssignByte&#38;lt;1,2&#38;gt;::Assign (11511FEh)&#10;01156D66  add         esp,8&#10;//&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出造成反常的原因是编译器为了便于debug，并没有进行inline优化，依然是函数调用。</p>\n<p>另外Debug模式会插入许多额外代码方便调试器，因此造成了整体性能的下降。</p>\n<p><strong>5.小结</strong></p>\n<p>因为偷懒，本文并未比较C实现与C++实现之间的性能差异，虽然有理由相信实现一中结构体静态成员函数调用的成本与C全局函数调用成本不相上下，但仍然是不严密之处。</p>\n<p>仅就3种实现的对比而言，可以确定的是：</p>\n<p>a.循环展开优化是有效果的</p>\n<p>b.执行成本：函数调用&gt;循环&gt;展开后代码</p>\n<p>c.实际优化结果结果依赖于编译器以及编译模式</p>\n<p>&nbsp;</p>\n","date":"2011-09-15T01:00:52.000Z","path":"2011/09/15/loop-unrolling-cpp/","isDark":false,"featureColor":"#d19e40","featureImage":"/image/stock/5.jpg","excerpt":"<p>这几天蛋疼，下手开始实现一个虚拟机，主要的参考书籍是Bill Blunden的&lt;Virtual Machine Design and Implementation in C/C++&gt;，书中实现了一个基本完整的HEC虚拟机。除了实践一下其中的知识以外，最主要的还是实际调查一下自己对原作者实现中不满意的地方，如果时间和精力足够，再添加没有实现的JIT以及配套的高级语言编译器。</p>\n<p>在Hec的实现中，有一个基本的功能，就是实现虚拟机字节码的endian与native code的endian之间的转换（如果相反），只是简单的颠倒字节顺序。主要在虚拟机加载字节码，开始执行之前调用，直接影响字节码加载到开始执行期间用户的等待时间。</p>\n<p>Blunden为了优化性能，在这部分应用了循环展开[<a href=\"http://en.wikipedia.org/wiki/Loop_unwinding\" title=\"Loop unwinding @ wikipedia\">1</a>]技术。本文记录了在开发过程中采用的几种与Blunden不同的实现方法，以及初步的对比。</p>","featureSwatch":{"Vibrant":{"color":"#d19e40","isDark":false,"contrast":2.433412395275077},"Muted":{"color":"#798249","isDark":true,"contrast":4.168289617634703},"DarkVibrant":{"color":"#97623d","isDark":true,"contrast":7.586487507499872},"DarkMuted":{"color":"#5a4e32","isDark":true,"contrast":14.22073373466042},"LightVibrant":{"color":"#d6c395","isDark":false,"contrast":1.7356438765314866},"LightMuted":{"color":"#aea18e","isDark":false,"contrast":2.5336980009663206}},"json":"data/posts/2011/09/15/loop-unrolling-cpp.json","tags":[{"name":"C++","slug":"C","path":"tags/C/","permalink":"http://catx.me/tags/C/","postCount":2},{"name":"VM","slug":"VM","path":"tags/VM/","permalink":"http://catx.me/tags/VM/","postCount":1},{"name":"optimization","slug":"optimization","path":"tags/optimization/","permalink":"http://catx.me/tags/optimization/","postCount":1},{"name":"template","slug":"template","path":"tags/template/","permalink":"http://catx.me/tags/template/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]},"sha1":"f1b0b4b5a32f68a9d635407277293dfdde221d7e","isDigest":true}],"sha1":"20c92a89769742cc73dac3a550a2436765514a22"}
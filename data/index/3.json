{"type":"index","path":"page/3/","json_base":"data/index/","json":"data/index/3.json","prev":"data/index/2.json","current":3,"total":3,"posts":[{"type":"post","json_base":"data/posts","json":"data/posts/2014/02/25/the-making-of-sarcasm-1.json","path":"2014/02/25/the-making-of-sarcasm-1/","data":{"title":"The Making Of Sarcasm (1) - Design Goals And Grammar","content":"<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>This is not a tutorial on how to use <a href=\"https://irony.codeplex.com/\" target=\"_blank\" rel=\"external\">Irony.net</a>. When I am done with this series of articles, hopefully we will never need to deal with Irony directly ever again.</p>\n<p>In case you didn’t know what Irony is, here is the introduction on its official site:</p>\n<blockquote>\n<p><strong>Irony</strong> is a development kit for implementing languages on .NET platform. Unlike most existing yacc/lex-style solutions Irony does not employ any scanner or parser code generation from grammar specifications written in a specialized meta-language. In Irony the target language grammar is coded directly in c# using operator overloading to express grammar constructs. Irony’s scanner and parser modules use the grammar encoded as c# class to control the parsing process.</p>\n</blockquote>\n<p>Looks fantastic. However, after I tried for days to implement CoffeeScript grammar with it, I encountered some issues:</p>\n<ul>\n<li>While constructing grammar with C# directly sounds cool, the syntax is just not as clean and efficient as a special design DSL would be.</li>\n<li>There are absolutely no compile-time checking on grammar. You have to compile it into dll first, then load it with Irony.GrammarExplorer.</li>\n<li>It is extremely hard, if not impossible, to track any grammar errors back to source code.</li>\n<li>On top of that, debug information on Shift-Reduce and Reduce-Reduce conflict is almost unreadable for a complex grammar.</li>\n</ul>\n<p>It’s a nice concept with poor tooling, which makes it scale poorly as the complexity of grammar grows. After some painstaking efforts to make my CoffeeScript parser to work, I finally begin to do something about it. I decide to create:</p>\n<blockquote>\n<p><strong>Sarcasm</strong>, an EBNF-like DSL that generates Irony.</p>\n</blockquote>\n<p>The design goals are to:</p>\n<ul>\n<li>Implement a DSL that allow developers to define grammar in a more clean and efficient syntax that looks very much like EBNF notation.</li>\n<li>Generate Irony grammar implementation (in C#) and a nice formatted grammar specification document (in MarkDown)</li>\n<li>Enable compile-time error checking and grammar validation</li>\n<li>Trace any errors back to the source code</li>\n<li>Improve the readability of debug information for grammar conflicts</li>\n<li>Provide necessary Visual Studio languages services, templates and tools</li>\n</ul>\n<h2 id=\"Sarcasm_Workflow\"><a href=\"#Sarcasm_Workflow\" class=\"headerlink\" title=\"Sarcasm Workflow\"></a>Sarcasm Workflow</h2><ol>\n<li>Developer writes grammar specification file (.sarc)</li>\n<li>Compiler checks for syntax error and generates both Irony grammar class (in C#) and spec docs (in MarkDown)</li>\n<li>VS continues build process</li>\n<li>If build failed, Sarcasm tools filters though all error messages, and map related errors back to specific tokens in .sarc file.</li>\n<li>If build succeeded,Sarcasm toolsloads the assembly and validates grammar.</li>\n<li>Sarcasm toolstranslates any grammar conflicts, errors into a readable format and trace back to specific rule in .sarc file.<br>The entire workflow should be seamlessly integrated with Visual Studio.</li>\n</ol>\n<h2 id=\"Sarcasm_Grammar\"><a href=\"#Sarcasm_Grammar\" class=\"headerlink\" title=\"Sarcasm Grammar\"></a>Sarcasm Grammar</h2><p>In a nutshell, the Sarcasm grammar is a hybrid of MakeDown and modified EBNF notation. Here’s a quick snippet:<span style=\"line-height: 1.5em;\"></span></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"header\"># H1</span></span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">Block comment</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">// Single Line Comment</span><br><span class=\"line\"></span><br><span class=\"line\">// Directive</span><br><span class=\"line\">@class SarcasmGrammar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"header\">## H2</span></span><br><span class=\"line\"></span><br><span class=\"line\">// Declarations</span><br><span class=\"line\">ID      = new IdentifierTerminal(\"ID\");</span><br><span class=\"line\">STRING  = new StringLiteral(\"STRING\", \"\\\"\", StringOptions.AllowsAllEscapes);</span><br><span class=\"line\"></span><br><span class=\"line\">// Production Rules</span><br><span class=\"line\">SimpleValue := STRING | ID;  </span><br><span class=\"line\"></span><br><span class=\"line\">// Repeat</span><br><span class=\"line\">Ids := ID&#123;&#125;;</span><br><span class=\"line\">Ids := ID*;</span><br><span class=\"line\">Ids := ID?;</span><br><span class=\"line\">Ids := ID+;</span><br><span class=\"line\"></span><br><span class=\"line\">// Repeat with delimiters</span><br><span class=\"line\">Ids := ID&#123;\",\"&#125;;</span><br><span class=\"line\">Ids := ID*(\".\");</span><br><span class=\"line\">Ids := ID+(\",\");</span><br><span class=\"line\"><span class=\"header\">### H3</span></span><br></pre></td></tr></table></figure>\n<p>As you can see, the grammar consists of:</p>\n<ul>\n<li>MarkDown headers (start with one or more <span style=\"text-decoration: underline;\">#</span>). Directly used for outlining.</li>\n<li>Comments (single line and block). All other text contents go into comments. MarkDown syntax can be used in comments.</li>\n<li>Directives (starting with <span style=\"text-decoration: underline;\">@)</span>. Configures compiler behaviors like generated class names.</li>\n<li>Declarations. Declare and initialize grammar terminals.</li>\n<li>Production rules. Specifies the grammar rules.<br>I won’t go into full details here. But you can see for yourself:</li>\n</ul>\n<p>Here is the <a href=\"https://gist.github.com/akfish/9167407#file-sarcasm-sarc\" target=\"_blank\" rel=\"external\">full grammar of Sarcasm writing in Sarcasm</a>.</p>\n<p>And here is the <a href=\"https://gist.github.com/akfish/9167407#file-sarcasm-md\" target=\"_blank\" rel=\"external\">MarkDownspecification documentation generated from that file</a></p>\n<p>While the<a href=\"https://github.com/akfish/Sarcasm\" target=\"_blank\" rel=\"external\">project</a>is still in early developing stage, the grammar is mostly completed. I should be able to bootstrap it in a day or two.</p>\n","date":"2014-02-24T20:13:46.000Z","path":"2014/02/25/the-making-of-sarcasm-1/","isDark":true,"featureColor":"#e46753","featureImage":"/image/stock/1.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#e46753","isDark":true,"contrast":3.3464676687814303},"Muted":{"color":"#676767","isDark":true,"contrast":5.656311837697813},"DarkVibrant":{"color":"#721f11","isDark":true,"contrast":11.305374415421051},"DarkMuted":{"color":"#393939","isDark":true,"contrast":15.601542416452443},"LightVibrant":{"color":"#e5826f","isDark":false,"contrast":2.7082115476623927},"LightMuted":{"color":"#a4a4a4","isDark":false,"contrast":2.4926545004666014}},"permalink":"http://catx.me/2014/02/25/the-making-of-sarcasm-1/","json":"data/posts/2014/02/25/the-making-of-sarcasm-1.json","tags":[{"name":".Net","slug":"Net","path":"tags/Net/","permalink":"http://catx.me/tags/Net/","postCount":4},{"name":"compiler","slug":"compiler","path":"tags/compiler/","permalink":"http://catx.me/tags/compiler/","postCount":4}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":17}]},"sha1":"e936f343ff95742801692bc8c01ea5902fcf0fda","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280.json","path":"2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280/","data":{"title":"JavaScript随机数生成算法中为什么要用9301, 49297, 233280作为Magic Number","content":"<p>今天在知乎上回答了这样一个问题：<a href=\"http://www.zhihu.com/question/22818104\" target=\"_blank\" rel=\"external\">网上常能见到的一段JS随机数生成算法如下，为什么用9301, 49297, 233280这三个数字做基数？</a></p>\n<p>问题中提到的代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rnd</span>(<span class=\"params\"> seed </span>)</span>&#123;</span><br><span class=\"line\">    seed = ( seed * <span class=\"number\">9301</span> + <span class=\"number\">49297</span> ) % <span class=\"number\">233280</span>; <span class=\"comment\">//Magic!</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> seed / ( <span class=\"number\">233280.0</span> );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rand</span>(<span class=\"params\">number</span>)</span>&#123;</span><br><span class=\"line\">    today = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); </span><br><span class=\"line\">    seed = today.getTime();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.ceil( rnd( seed ) * number );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myNum=(rand(<span class=\"number\">5</span>));</span><br></pre></td></tr></table></figure></p>\n<p>经过一系列的digging，最终找到了这个问题的答案，这三个数的选择是有数学依据的。</p>\n<p><strong>入门级的选择标准</strong><br>这种随机数生成器叫做线性同余生成器（LCG, Linear Congruential Generator)，几乎所有的运行库提供的rand都是采用的LCG，形如：<br><span>$I_{n+1}=aI_n + c\\ (mod\\ m)$</span><!-- Has MathJax --><br>生成的随机数序列最大周期m，生成0到m-1之间的随机数。要达到这个最大周期，必须满足</p>\n<ul>\n<li>c与m互质</li>\n<li>a - 1可以被m的所有质因数整除</li>\n<li>如果m是4的倍数，a - 1也必须是4的倍数<br>以上三条被称为Hull-Dobell定理。<br>作为一个随机数生成器，周期不够大是不好意思混的，所以这是要求之一。<br>可以看到，a=9301, c = 49297, m = 233280这组参数，以上三条全部满足。</li>\n</ul>\n<p><strong>进阶级的选择标准</strong><br>要在随机数生成器界混，仅仅入门是不够的。<br>从工程的角度来讲，$(m - 1)a + c$的值要（在合理的范围内）足够小，以避免溢出的问题。<br>从安全（实用）性的角度来讲，还要满足良好的随机性，这一点可以通过Knunth’s Spectral Test来评估（见[2]），要通过2,3,4,5以及6维的Spectral Test才行。Spectral Test考察的就是生成的随机数序列在超空间的网格结构（lattice structure），当年IBM的RANDU子程序闹出的乌龙，连3维的Spectral Test就不能通过，上图嘲讽下：</p>\n<p><a href=\"http://catx.me/wordpress/wp-content/uploads/2014/02/800px-Randu.png\"><img src=\"/images/bb1858cc61e6b2f8335f68221d141e0f5b289d68.png\" alt=\"800px-Randu\"></a></p>\n<p>其中每个点代表三个连续的RANDU生成的随机数值，可以看到所有随机数分布在了15个二维平面上。</p>\n<p>在这种要求面前，c的值最好：</p>\n<ul>\n<li>是质数 （c = 49297就是质数）</li>\n<li>接近<span>$(\\frac{1}{2}-\\frac{1}{6}\\sqrt{3})m$</span><!-- Has MathJax -->,(m = 233280时为49297.86460172205)<br>所以有了这样一些基本的标准，能够选择的参数范围就小了很多，弄个程序跑下Spectral Test，就能得到可选的参数组：</li>\n</ul>\n<p><a href=\"http://catx.me/wordpress/wp-content/uploads/2014/02/Unnamed-QQ-Screenshot20140222141315.png\"><img src=\"/images/5733d329521f86f7a2d59b5dc895f027ca119a83.png\" alt=\"Magic Number for LCG Random Generator\"></a></p>\n<p>参考资料：<a href=\"http://nuclear.fis.ucm.es/COMP-PHYS/RANDOM/RandomNumbers.pdf\" target=\"_blank\" rel=\"external\">[1]</a><a href=\"http://random.mat.sbg.ac.at/tests/theory/spectral/\" target=\"_blank\" rel=\"external\">[2]</a></p>\n","date":"2014-02-22T07:01:45.000Z","path":"2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280/","isDark":false,"featureColor":"#d19e40","featureImage":"/image/stock/5.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#d19e40","isDark":false,"contrast":2.433412395275077},"Muted":{"color":"#798249","isDark":true,"contrast":4.168289617634703},"DarkVibrant":{"color":"#97623d","isDark":true,"contrast":7.586487507499872},"DarkMuted":{"color":"#5a4e32","isDark":true,"contrast":14.22073373466042},"LightVibrant":{"color":"#d6c395","isDark":false,"contrast":1.7356438765314866},"LightMuted":{"color":"#aea18e","isDark":false,"contrast":2.5336980009663206}},"permalink":"http://catx.me/2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280/","json":"data/posts/2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280.json","tags":[{"name":"Algorithm","slug":"Algorithm","path":"tags/Algorithm/","permalink":"http://catx.me/tags/Algorithm/","postCount":2},{"name":"Magic Number","slug":"Magic-Number","path":"tags/Magic-Number/","permalink":"http://catx.me/tags/Magic-Number/","postCount":1},{"name":"Math","slug":"Math","path":"tags/Math/","permalink":"http://catx.me/tags/Math/","postCount":1},{"name":"Random","slug":"Random","path":"tags/Random/","permalink":"http://catx.me/tags/Random/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":17}]},"sha1":"4594b540043468ede1c7925a4006ccf0bbbaffce","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2014/02/06/get-and-visualize-grammar-definition-of-coffee-script-from-source-code.json","path":"2014/02/06/get-and-visualize-grammar-definition-of-coffee-script-from-source-code/","data":{"title":"从CoffeeScript源代码中获取文法并可视化","content":"<p>最近在研究把CoffeeScript编译到.Net CLR环境上运行的可能性，在几个CoffeeScript compiler的实现中，没有发现对文法定义的specification，如果要人肉重建不仅工作量忧桑，还有可能导致兼容性问题。于是看了下源代码，发现略施小计就能解决这个问题。</p>\n<p>CoffeeScript的Parser使用jison生成的，所有的文法都在<a href=\"http://coffeescript.org/documentation/docs/grammar.html\" target=\"_blank\" rel=\"external\">grammar.coffee</a>里定义了。这个代码非常好改，去掉对jison的调用，把语法定义用JSON.stringify() format了再输出，执行<a href=\"https://gist.github.com/akfish/8827385\" target=\"_blank\" rel=\"external\">修改后的代码</a>：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">coffee grammar.coffee</span><br></pre></td></tr></table></figure></p>\n<p>就会得到一大串jison格式的文法定义：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"tokens\"</span>:<span class=\"string\">\" TERMINATOR TERMINATOR TERMINATOR STATEMENT INDENT OUTDENT INDENT OUTDENT IDENTIFIER NUMBER STRING JS REGEX BOOL = = INDENT OUTDENT : : INDENT OUTDENT RETURN RETURN HERECOMMENT PARAM_START PARAM_END -&amp;gt; =&amp;gt;  ,  , ... = ... . ?. :: :: INDEX_START INDEX_END INDEX_SOAK &#123; &#125;  , TERMINATOR INDENT OUTDENT CLASS CLASS CLASS EXTENDS CLASS EXTENDS CLASS CLASS CLASS EXTENDS CLASS EXTENDS SUPER SUPER  FUNC_EXIST CALL_START CALL_END CALL_START CALL_END THIS @ @ [ ] [ ] .. ... [ ] , TERMINATOR INDENT OUTDENT INDENT OUTDENT , TRY TRY TRY FINALLY TRY FINALLY CATCH THROW ( ) ( INDENT OUTDENT ) WHILE WHILE WHEN UNTIL UNTIL WHEN LOOP LOOP FOR FOR FOR OWN , FORIN FOROF FORIN WHEN FOROF WHEN FORIN BY FORIN WHEN BY FORIN BY WHEN SWITCH INDENT OUTDENT SWITCH INDENT ELSE OUTDENT SWITCH INDENT OUTDENT SWITCH INDENT ELSE OUTDENT LEADING_WHEN LEADING_WHEN TERMINATOR IF ELSE IF ELSE POST_IF POST_IF UNARY - + -- ++ -- ++ ? + - MATH SHIFT COMPARE LOGIC RELATION COMPOUND_ASSIGN COMPOUND_ASSIGN INDENT OUTDENT EXTENDS\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"bnf\"</span>:</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"string\">\"Root\"</span>:</span><br><span class=\"line\">    [</span><br><span class=\"line\">      [<span class=\"string\">\"\"</span>,<span class=\"string\">\"return $$ = new yy.Block;\"</span>,<span class=\"literal\">null</span>],</span><br><span class=\"line\">      [<span class=\"string\">\"Body\"</span>,<span class=\"string\">\"return $$ = $1;\"</span>,<span class=\"literal\">null</span>],</span><br><span class=\"line\">      [<span class=\"string\">\"Block TERMINATOR\"</span>,<span class=\"string\">\"return $$ = $1;\"</span>,<span class=\"literal\">null</span>]</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"Body\"</span>:</span><br><span class=\"line\">    [</span><br><span class=\"line\">      [<span class=\"string\">\"Line\"</span>,<span class=\"string\">\"$$ = yy.Block.wrap([$1]);\"</span>,<span class=\"literal\">null</span>],</span><br><span class=\"line\">      [<span class=\"string\">\"Body TERMINATOR Line\"</span>,<span class=\"string\">\"$$ = $1.push($3);\"</span>,<span class=\"literal\">null</span>],</span><br><span class=\"line\">      [<span class=\"string\">\"Body TERMINATOR\"</span>,<span class=\"string\">\"$$ = $1;\"</span>,<span class=\"literal\">null</span>]</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"Line\"</span>:</span><br><span class=\"line\">    [</span><br><span class=\"line\">      [<span class=\"string\">\"Expression\"</span>,<span class=\"string\">\"$$ = $1;\"</span>,<span class=\"literal\">null</span>],</span><br><span class=\"line\">      [<span class=\"string\">\"Statement\"</span>,<span class=\"string\">\"$$ = $1;\"</span>,<span class=\"literal\">null</span>]</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure></p>\n<p>这样已经算是可用了，但可读性依然不高，经过一番搜索发现一个jison-to-w3c文法标记格式的<a href=\"http://bottlecaps.de/convert/\" target=\"_blank\" rel=\"external\">转换器</a>，得到<a href=\"https://gist.github.com/akfish/8827385\" target=\"_blank\" rel=\"external\">文法</a>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Root     ::= Body?&#10;Body     ::= Line ( TERMINATOR Line | TERMINATOR )*&#10;Line     ::= Expression&#10;           | Statement&#10;Statement&#10;         ::= Return&#10;           | Comment&#10;           | STATEMENT&#10;Expression&#10;         ::= Value&#10;           | Invocation&#10;           | Code&#10;           | Operation&#10;           | Assign&#10;           | If&#10;           | Try&#10;           | While&#10;           | For&#10;           | Switch&#10;           | Class&#10;           | Throw&#10;...</span><br></pre></td></tr></table></figure></p>\n<p>最后找到一个可视化文法的网站<a href=\"http://bottlecaps.de/rr/ui\" target=\"_blank\" rel=\"external\">Railroad Diagram Generator</a>将其可视化，just for fun:</p>\n<p><a href=\"http://catx.me/wordpress/wp-content/uploads/2014/02/coffee-grammar.png\"><img src=\"/images/064306e5ca2ed757a42cd94fd214d22e49fc19c8.png\" alt=\"coffee-grammar\"></a></p>\n<p>完整的图在：<a href=\"http://project.catx.me/other/coffee-grammar.xhtml\" target=\"_blank\" rel=\"external\">http://project.catx.me/other/coffee-grammar.xhtml</a></p>\n<p>源代码+完整的文法定义：<a href=\"https://gist.github.com/akfish/8827385\" target=\"_blank\" rel=\"external\">https://gist.github.com/akfish/8827385</a></p>\n","date":"2014-02-05T16:55:24.000Z","path":"2014/02/06/get-and-visualize-grammar-definition-of-coffee-script-from-source-code/","isDark":true,"featureColor":"#254277","featureImage":"/image/stock/3.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#254277","isDark":true,"contrast":13.119400726558645},"Muted":{"color":"#526c95","isDark":true,"contrast":5.699027819875463},"DarkVibrant":{"color":"#113a74","isDark":true,"contrast":13.761948622251554},"DarkMuted":{"color":"#425c7b","isDark":true,"contrast":11.860230374565882},"LightVibrant":{"color":"#f4f7fc","isDark":false,"contrast":1.0738073817947642},"LightMuted":{"color":"#8e9db6","isDark":false,"contrast":2.745663409490839}},"permalink":"http://catx.me/2014/02/06/get-and-visualize-grammar-definition-of-coffee-script-from-source-code/","json":"data/posts/2014/02/06/get-and-visualize-grammar-definition-of-coffee-script-from-source-code.json","tags":[{"name":".Net","slug":"Net","path":"tags/Net/","permalink":"http://catx.me/tags/Net/","postCount":4},{"name":"CoffeeScript","slug":"CoffeeScript","path":"tags/CoffeeScript/","permalink":"http://catx.me/tags/CoffeeScript/","postCount":6},{"name":"compiler","slug":"compiler","path":"tags/compiler/","permalink":"http://catx.me/tags/compiler/","postCount":4}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":17}]},"sha1":"3aace89593d9c6e293761a13505ac6b4cd3143d5","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2014/01/15/run-msbuild-and-mstest-from-git-pre-commit-hook.json","path":"2014/01/15/run-msbuild-and-mstest-from-git-pre-commit-hook/","data":{"title":"通过Git Pre-Commit Hook执行MSBuild和MSTest","content":"<p>Git的pre-commit hook会在commit之前执行，当脚本的返回值不为0的时候，终止commit过程，因此可以把编译、测试、lint等workflow放到这一hook中，减少引入到版本库中的bug。</p>\n<p>以下脚本用于调用MSBuild和MSTest对C#工程在commit前进行build和test。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh&#10; &#10;# Helper&#10;safeRunCommand() &#123;&#10;    typeset cmd=&#34;$*&#34;&#10;    typeset ret_code&#10; &#10;    echo cmd=$cmd&#10;    eval $cmd&#10;    ret_code=$?&#10;    if [ $ret_code != 0 ]; then&#10;        printf &#34;Error : [%d] when executing command: &#39;$cmd&#39;&#34; $ret_code&#10;        exit $ret_code&#10;    fi&#10;&#125;&#10; &#10;# Path To MSBuild.exe&#10;MSBuild=&#34;/c/Windows/Microsoft.NET/Framework/v4.0.30319/MSBuild.exe&#34;&#10;# Path To MSTest.exe&#10;MSTest=&#34;/d/Program\\ Files\\ \\(x86\\)/Microsoft\\ Visual\\ Studio\\ 11.0/Common7/IDE/MSTest.exe&#34;&#10;# Get Project root path (without tailing /)&#10;ProjectRoot=&#34;$(git rev-parse --show-toplevel)&#34;&#10; &#10;# Test Containers (without leading /)&#10;Tests=(&#10;    &#34;ConsoleSharp.Tests/bin/Debug/ConsoleSharp.Tests.dll&#34; &#10;    &#34;Mirror.Test/bin/Debug/Mirror.Test.dll&#34;&#10;)&#10; &#10; &#10;# Build&#10;safeRunCommand $MSBuild $ProjectRoot/ConsoleSharp.sln&#10; &#10;# Test&#10;Args=(&#34;$&#123;Tests[@]/#//testcontainer:$ProjectRoot/&#125;&#34;)&#10;safeRunCommand $MSTest $(eval &#39;echo &#34;$&#123;Args[*]&#125;&#34;&#39;)</span><br></pre></td></tr></table></figure>\n","date":"2014-01-15T13:06:56.000Z","path":"2014/01/15/run-msbuild-and-mstest-from-git-pre-commit-hook/","isDark":false,"featureColor":"#d19e40","featureImage":"/image/stock/5.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#d19e40","isDark":false,"contrast":2.433412395275077},"Muted":{"color":"#798249","isDark":true,"contrast":4.168289617634703},"DarkVibrant":{"color":"#97623d","isDark":true,"contrast":7.586487507499872},"DarkMuted":{"color":"#5a4e32","isDark":true,"contrast":14.22073373466042},"LightVibrant":{"color":"#d6c395","isDark":false,"contrast":1.7356438765314866},"LightMuted":{"color":"#aea18e","isDark":false,"contrast":2.5336980009663206}},"permalink":"http://catx.me/2014/01/15/run-msbuild-and-mstest-from-git-pre-commit-hook/","json":"data/posts/2014/01/15/run-msbuild-and-mstest-from-git-pre-commit-hook.json","tags":[{"name":"Shell","slug":"Shell","path":"tags/Shell/","permalink":"http://catx.me/tags/Shell/","postCount":1},{"name":"git","slug":"git","path":"tags/git/","permalink":"http://catx.me/tags/git/","postCount":2},{"name":"测试","slug":"测试","path":"tags/测试/","permalink":"http://catx.me/tags/测试/","postCount":2}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":17}]},"sha1":"b656efe3d8f51b7e9c22900b0a6a6b8fcc45107b","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2013/10/19/git-custom-transfer-protocol-1.json","path":"2013/10/19/git-custom-transfer-protocol-1/","data":{"title":"Git私有传输协议实现-接口篇(1)","content":"<p>Git默认支持http, https, ssh协议，同时也提供了扩展私有协议的方法，文档<a href=\"https://www.kernel.org/pub/software/scm/git/docs/git-remote-helpers.html\" target=\"_blank\" rel=\"external\">git-remote-helpers</a>给出了详细的spec。</p>\n<p>比如要实现一种协议，把git repository存储（可加密）到私人的email邮箱中，以存储一些不便于host到GitHub的私人repo，同时免去购买主机/服务器的成本和维护带来的麻烦，Repository的clone url格式定义为<code>mail://your@email.com:repo_name</code>。</p>\n<h2 id=\"u8C03_u7528\"><a href=\"#u8C03_u7528\" class=\"headerlink\" title=\"调用\"></a>调用</h2><p>使用git命令clone, 现在什么都没实现，所以理所当然的报错：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone mail://akfish@gmail.com:foo&#10;fatal: Unable to find remote helper for &#39;mail&#39;</span><br></pre></td></tr></table></figure></p>\n<p>根据文档的描述：</p>\n<blockquote>\n<p>When git encounters a URL of the form &lt;transport&gt;://&lt;address&gt;, where &lt;transport&gt; is a protocol that it cannot handle natively, it automatically invokes git remote-&lt;transport&gt; with the full URL as the second argument. If such a URL is encountered directly on the command line, the first argument is the same as the second, and if it is encountered in a configured remote, the first argument is the name of that remote.</p>\n</blockquote>\n<p>即git会把url中<code>mail://</code>映射到调用命令<code>git-remote-mail</code>，所以只需要用任何开发语言实现一个标准输入输出的命令行程序，满足文档中定义的命令格式，放在git能搜寻到的位置，就能让git支持私有协议（注意python在windows下存在stdout无法被重定向的问题，无法和git正确通信）。本例中用C#实现，创建控制台程序git-remote-mail：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Linq;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Text;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">git_remote_mail</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"keyword\">string</span>[] args</span>)</span><br><span class=\"line\">        </span>&#123;</span><br><span class=\"line\">            Logger logger = <span class=\"keyword\">new</span> Logger(<span class=\"string\">\"git-remote-mail.txt\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            logger.Log(<span class=\"string\">\"args: \"</span> + String.Join(<span class=\"string\">\", \"</span>, args));</span><br><span class=\"line\"></span><br><span class=\"line\">            logger.Dispose();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再次执行clone，错误提示消失，由于这个脚本什么事情也没做，所以当然也就什么都不会发生。stdin和stdout被用于与git通信，不会显示出来。如果需要输出消息，write到stderr，或者产生一个日志文件来记录，Logger类实现了相应的功能，具体代码见<a href=\"https://github.com/akfish/git-mail/blob/master/git-remote-mail/Logger.cs\" target=\"_blank\" rel=\"external\">Logger.cs</a>。执行clone命令后，输出为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[2013/10/20 22:07:02]Open log file git-remote-mail.txt&#10;[2013/10/20 22:07:02]args: origin, mail://akfish@gmail.com:foo&#10;[2013/10/20 22:07:02]Close log file</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，在调用的时候，还传入了两个参数：origin和mail://akfish@gmail.com:foo，根据文档：</p>\n<blockquote>\n<p>Remote helper programs are invoked with one or (optionally) two arguments. The first argument specifies a remote repository as in git; it is either the name of a configured remote or a URL. The second argument specifies a URL; it is usually of the form &lt;transport&gt;://&lt;address&gt;, but any arbitrary string is possible.</p>\n</blockquote>\n<p>参数的数量为1~2个，第一个参数为repo的名字或者url，第二个参数如果存在，为repo的url。</p>\n<h2 id=\"u547D_u4EE4_u6D41\"><a href=\"#u547D_u4EE4_u6D41\" class=\"headerlink\" title=\"命令流\"></a>命令流</h2><p>Git通过stdin向remote helper发送命令，一行一个，第一个命令总是<em>capabilities</em>。Remote helper需要通过stdout返回支持的capabilities，每行一个，以空行结束。Capabilities代表helper支持哪些命令子集，如fetch需要支持<em>connect, fetch, import</em>，详细的列表在文档里有列出。</p>\n<p>命令流通常以空行结束，但在某些情况下空行后会跟着其它协议的payload（如pack），具体参见command的具体说明。要注意的是命令流用的是linux-style line ending，即以<em>\\n</em>结尾，如果使用<em>Console.WriteLine</em>产生的是DOS line ending（<em>\\r\\n</em>），则不能正确工作。<em>\n</em></p>\n<p>增加代码响应capabilities命令：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.... </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"keyword\">string</span>[] args</span>)</span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">    Logger logger = <span class=\"keyword\">new</span> Logger(<span class=\"string\">\"git-remote-mail.txt\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    logger.Log(<span class=\"string\">\"args: \"</span> + String.Join(<span class=\"string\">\", \"</span>, args));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">string</span> line;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> exitCode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line = Console.ReadLine();</span><br><span class=\"line\"></span><br><span class=\"line\">        logger.Log(<span class=\"string\">\"&amp;gt;&amp;gt;\"</span> + line);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">string</span>.IsNullOrEmpty(line))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            logger.Log(<span class=\"string\">\"Command stream terminated\"</span>);</span><br><span class=\"line\">            exitCode = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (line.StartsWith(<span class=\"string\">\"capabilities\"</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Console.Write(<span class=\"string\">\"connect\\n\"</span>);</span><br><span class=\"line\">            Console.Write(<span class=\"string\">\"fetch\\n\"</span>);</span><br><span class=\"line\">            Console.Write(<span class=\"string\">\"import\\n\"</span>);</span><br><span class=\"line\">            Console.Write(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">            logger.Log(<span class=\"string\">\"&amp;lt;&amp;lt;connect, fetch, import\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            logger.Log(<span class=\"string\">\"Unhandled command. Exit\"</span>);</span><br><span class=\"line\">            exitCode = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    logger.Dispose();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> exitCode;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure>\n<p>输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[2013/10/20 22:28:53]Open log file git-remote-mail.txt&#10;[2013/10/20 22:28:53]args: origin, mail://akfish@gmail.com:foo&#10;[2013/10/20 22:28:53]&#38;gt;&#38;gt;capabilities&#10;[2013/10/20 22:28:53]&#38;lt;&#38;lt;connect, fetch, import&#10;[2013/10/20 22:28:53]&#38;gt;&#38;gt;connect git-upload-pack&#10;[2013/10/20 22:28:53]Unhandled command. Exit&#10;[2013/10/20 22:28:53]Close log file</span><br></pre></td></tr></table></figure>\n<p>表明命令流已经成功初始化，git继续发出connect命令开始clone的工作。</p>\n<p>接口部分就这么简单，接下来的工作就是根据文档的描述，响应具体的命令，完成协议的具体设计。</p>\n<h2 id=\"u66F4_u591A_u53C2_u8003_u8D44_u6599\"><a href=\"#u66F4_u591A_u53C2_u8003_u8D44_u6599\" class=\"headerlink\" title=\"更多参考资料\"></a>更多参考资料</h2><p>Git的repo中包含了大量文档，都是很好的参考资料</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/git/git&#10;$ cd git/Documentation&#10;$ grep -nRHI &#34;receive-pack&#34; *</span><br></pre></td></tr></table></figure>\n<p>会给出这些文档：</p>\n<ul>\n<li><a href=\"https://github.com/git/git/blob/master/Documentation/technical/http-protocol.txt\" target=\"_blank\" rel=\"external\">http-protocol</a></li>\n<li><a href=\"https://github.com/git/git/blob/master/Documentation/technical/pack-heuristics.txt\" target=\"_blank\" rel=\"external\">pack-heuristics</a></li>\n<li><a href=\"https://github.com/git/git/blob/master/Documentation/technical/pack-protocol.txt\" target=\"_blank\" rel=\"external\">pack-protocol</a></li>\n<li><a href=\"https://github.com/git/git/blob/master/Documentation/technical/protocol-capabilities.txt\" target=\"_blank\" rel=\"external\">protocol capabilities</a></li>\n<li><a href=\"https://github.com/git/git/blob/master/Documentation/technical/send-pack-pipeline.txt\" target=\"_blank\" rel=\"external\"><code>send-pack</code> pipeline</a></li>\n</ul>\n<p>以下文档是相关的后端命令，作为补充：</p>\n<ul>\n<li><a href=\"https://github.com/git/git/blob/master/Documentation/git-http-backend.txt\" target=\"_blank\" rel=\"external\"><code>git-http-backend</code></a></li>\n<li><a href=\"https://github.com/git/git/blob/master/Documentation/git-receive-pack.txt\" target=\"_blank\" rel=\"external\"><code>git-receive-pack</code></a></li>\n<li><a href=\"https://github.com/git/git/blob/master/Documentation/git-remote-ext.txt\" target=\"_blank\" rel=\"external\"><code>git-remote-ext</code></a></li>\n<li><a href=\"https://github.com/git/git/blob/master/Documentation/git-send-pack.txt\" target=\"_blank\" rel=\"external\"><code>git-send-pack</code></a></li>\n<li><a href=\"https://github.com/git/git/blob/master/Documentation/gitremote-helpers.txt\" target=\"_blank\" rel=\"external\"><code>git-remote-helpers</code></a></li>\n</ul>\n<p>查看源代码中与传输协议相关的commit：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/git/git&#10;$ cd git&#10;$ git log -Stransfer</span><br></pre></td></tr></table></figure>\n<p>可以参见以下commits：</p>\n<ul>\n<li><a href=\"http://github.com/git/git/commit/4bc444eb64173f770c1d1dba2ed3db393c2a9b18\" target=\"_blank\" rel=\"external\">commit 4bc444</a> (Support FTP-over-SSL/TLS for regular FTP)</li>\n<li><a href=\"https://github.com/git/git/commit/daebaa78137d59693a808c1f0bdec0ecb40fc12e\" target=\"_blank\" rel=\"external\">commit daebaa</a> (upload/receive-pack: allow hiding ref hierarchies )</li>\n<li><a href=\"http://github.com/git/git/commit/745f7a8cacae55df3e00507344d8db2a31eb57e8\" target=\"_blank\" rel=\"external\">commit 745f7a</a> (fetch-pack: move core code to libgit.a)</li>\n<li><a href=\"http://github.com/git/git/commit/fe0435011cfc5f0c15bbd4548ce0015f5b8ad430\" target=\"_blank\" rel=\"external\">commit fe0435</a> (Add persistent-https to contrib)<br>&nbsp;</li>\n</ul>\n","date":"2013-10-19T10:47:12.000Z","path":"2013/10/19/git-custom-transfer-protocol-1/","isDark":true,"featureColor":"#254277","featureImage":"/image/stock/3.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#254277","isDark":true,"contrast":13.119400726558645},"Muted":{"color":"#526c95","isDark":true,"contrast":5.699027819875463},"DarkVibrant":{"color":"#113a74","isDark":true,"contrast":13.761948622251554},"DarkMuted":{"color":"#425c7b","isDark":true,"contrast":11.860230374565882},"LightVibrant":{"color":"#f4f7fc","isDark":false,"contrast":1.0738073817947642},"LightMuted":{"color":"#8e9db6","isDark":false,"contrast":2.745663409490839}},"permalink":"http://catx.me/2013/10/19/git-custom-transfer-protocol-1/","json":"data/posts/2013/10/19/git-custom-transfer-protocol-1.json","tags":[{"name":"git","slug":"git","path":"tags/git/","permalink":"http://catx.me/tags/git/","postCount":2},{"name":"gmail","slug":"gmail","path":"tags/gmail/","permalink":"http://catx.me/tags/gmail/","postCount":1},{"name":"python","slug":"python","path":"tags/python/","permalink":"http://catx.me/tags/python/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":17}]},"sha1":"ee0558eb63a9941311f470d53d2d24c21c635d46","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2011/09/15/loop-unrolling-cpp.json","path":"2011/09/15/loop-unrolling-cpp/","data":{"title":"关于循环展开优化","content":"<p>这几天蛋疼，下手开始实现一个虚拟机，主要的参考书籍是Bill Blunden的&lt;Virtual Machine Design and Implementation in C/C++&gt;，书中实现了一个基本完整的HEC虚拟机。除了实践一下其中的知识以外，最主要的还是实际调查一下自己对原作者实现中不满意的地方，如果时间和精力足够，再添加没有实现的JIT以及配套的高级语言编译器。</p>\n<p>在Hec的实现中，有一个基本的功能，就是实现虚拟机字节码的endian与native code的endian之间的转换（如果相反），只是简单的颠倒字节顺序。主要在虚拟机加载字节码，开始执行之前调用，直接影响字节码加载到开始执行期间用户的等待时间。</p>\n<p>Blunden为了优化性能，在这部分应用了循环展开[<a href=\"http://en.wikipedia.org/wiki/Loop_unwinding\" title=\"Loop unwinding @ wikipedia\" target=\"_blank\" rel=\"external\">1</a>]技术。本文记录了在开发过程中采用的几种与Blunden不同的实现方法，以及初步的对比。</p>\n<a id=\"more\"></a>\n<p><strong>0. Blunden原始实现</strong></p>\n<p>原始实现提供了一系列单独的bytecodeToTypeName以及typeNameToBytecode全局函数：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">U2 <span class=\"title\">bytecodeToWord</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">U4 <span class=\"title\">bytecodeToDWord</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">U8 <span class=\"title\">bytecodeToQWord</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">F4 <span class=\"title\">bytecodeToFloat</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">F8 <span class=\"title\">bytecodeToDouble</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">wordToBytecode</span><span class=\"params\">(U2 word, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dwordToBytecode</span><span class=\"params\">(U4 dword, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">qwordToBytecode</span><span class=\"params\">(U8 qword, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">floatToBytecode</span><span class=\"params\">(F4 flt, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doubleToBytecode</span><span class=\"params\">(F8 dbl, U1 arr[])</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>其中U代表unsigned，后面的数字代表位长，在win32平台下的定义为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S1\tsigned char</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S2\tsigned short</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S4\tsigned long</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S8\tsigned __int64\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U1\tunsigned char</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U2\tunsigned short</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U4\tunsigned long</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U8\tunsigned __int64</span></span><br></pre></td></tr></table></figure>\n<p>以下仅列举U8版本的qwordToBytecode实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">qwordToBytecode</span><span class=\"params\">(U8 qword, U1 arr[])</span></span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">\tU1 *buffer;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbuffer = (U1*)&amp;amp;qword;</span><br><span class=\"line\">\tarr[<span class=\"number\">0</span>] = buffer[<span class=\"number\">7</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">1</span>] = buffer[<span class=\"number\">6</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">2</span>] = buffer[<span class=\"number\">5</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">3</span>] = buffer[<span class=\"number\">4</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">4</span>] = buffer[<span class=\"number\">3</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">5</span>] = buffer[<span class=\"number\">2</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">6</span>] = buffer[<span class=\"number\">1</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">7</span>] = buffer[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;<span class=\"comment\">/*end qwordToBytecode*/</span></span><br></pre></td></tr></table></figure>\n<p>可以看出Blunden的实现是C Style的，基本上就是一大堆全局函数与变量，缺乏封装性。各个类型的转换函数没有统一的调用接口，而且由于采用了循环展开，导致对每一个类型转换的函数体都非常冗长，整个代码就变成了一大堆重复代码的组合。</p>\n<p>当然这主要是出于性能的考虑，不过考虑到现在的C++编译器的性能已经不再是当年的情况，C++完全可以做到与C相同甚至更好的性能，同时提供更易于维护的代码。实际上，很多C语言写的程序最后也是用C++编译器编译的。</p>\n<p><strong>1.实现一：For Loop</strong></p>\n<p>在讨论优化之前，要有个被优化的对象作为对比，以下是用For循环在一个struct中实现同样的功能：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">typename</span> T&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ForLoopAssign</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &amp;lt; <span class=\"keyword\">sizeof</span>(T); i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tdest[i] = src[<span class=\"keyword\">sizeof</span>(T) - i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里只是最主要的交换赋值部分，采用了模板类，为的是同一个接口实现不同类型转换功能的调用，而不是若干个单独的函数。</p>\n<p>模板类在编译时就会被展开，因此在运行时的性能损耗很小。</p>\n<p>可以看到这段代码的优点是简短，易于维护，几行代码实现了几十行代码的功能。缺点当然是For-Loop造成的性能损耗。</p>\n<p>调用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ForLoopAssign&amp;lt;T&amp;gt;::AssignBytes(src, dest);</span><br></pre></td></tr></table></figure>\n<p><strong>2.实现二：手动循环展开</strong></p>\n<p>Prototype：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">int</span> byteLen&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>特化：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">1</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">2</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">4</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">2</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">3</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">8</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">7</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">6</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">2</span>] = src[<span class=\"number\">5</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">3</span>] = src[<span class=\"number\">4</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">4</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">5</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">6</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">7</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其实就是对C Style实现的C++封装，性能接近原实现，调用只需要一句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExplicitUnrolling&amp;lt;<span class=\"keyword\">sizeof</span>(T)&amp;gt;::AssignBytes(src, dest);</span><br></pre></td></tr></table></figure>\n<p>显然，作为显示实现的代码，也是难于维护的。</p>\n<p><strong>3.实现3：模板元递归</strong></p>\n<p>递归模板：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">int</span> byteN, <span class=\"keyword\">int</span> byteLen&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> AssignByte</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Assign</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[byteN - <span class=\"number\">1</span>] = src[byteLen - byteN];</span><br><span class=\"line\">\t\tAssignByte&amp;lt;byteN - <span class=\"number\">1</span>, byteLen&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>递归边界：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">int</span> byteLen&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> AssignByte&amp;lt;<span class=\"number\">1</span>, byteLen&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Assign</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[byteLen - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AssignByte&amp;lt;<span class=\"keyword\">sizeof</span>(T), <span class=\"keyword\">sizeof</span>(T)&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>\n<p>和For Loop实现相比，这段代码只长了几句，但是却实现了循环展开。</p>\n<p>以U4为例，调用的时候实际上是：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">4</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>\n<p>在Assign函数体中形成递归调用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dest[<span class=\"number\">4</span> - byteLen] = src[<span class=\"number\">4</span> - byteLen];</span><br><span class=\"line\"><span class=\"comment\">//递归调用</span></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">4</span> - <span class=\"number\">1</span>, byteLen&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>\n<p>直到传入的byteN == 1到达递归边界。</p>\n<p>但这个递归是在编译时进行的，实际上是编译器递归的生成了如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">4</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">3</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\tAssignByte&amp;lt;<span class=\"number\">3</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">3</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">2</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\tAssignByte&amp;lt;<span class=\"number\">2</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">2</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">\tAssignByte&amp;lt;<span class=\"number\">1</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">1</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以在运行时没有任何递归，只是一系列的函数调用，但更妙的是对于足够短的函数体，编译器会自动进行inline优化，省略函数调用，以上代码最后编译后等效于人肉实现的循环展开。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dest[<span class=\"number\">0</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">dest[<span class=\"number\">1</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">dest[<span class=\"number\">2</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">dest[<span class=\"number\">3</span>] = src[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>这种方法最后做到了与For Loop相近长度的易于维护的代码，以及（理论上）与人肉循环展开一致的性能。</p>\n<p><strong>4.测试与结果分析</strong></p>\n<p>测试代码分别调用以上3种实现100000000、1000000000、10000000000次，记录执行时间。</p>\n<p>测试平台：Windows 7 Ultimate 32bit + Visual Studio 2010</p>\n<p>Release Build:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----------------------------------&#10;Test U2&#10;For-Loop x100000000: 207&#10;Template x100000000: 88&#10;Explicit x100000000: 119&#10;&#10;Test U4&#10;For-Loop x100000000: 183&#10;Template x100000000: 85&#10;Explicit x100000000: 93&#10;&#10;Test U8&#10;For-Loop x100000000: 182&#10;Template x100000000: 86&#10;Explicit x100000000: 86&#10;&#10;----------------------------------&#10;Test U2&#10;For-Loop x1000000000: 1768&#10;Template x1000000000: 878&#10;Explicit x1000000000: 1169&#10;&#10;Test U4&#10;For-Loop x1000000000: 1796&#10;Template x1000000000: 879&#10;Explicit x1000000000: 882&#10;&#10;Test U8&#10;For-Loop x1000000000: 1760&#10;Template x1000000000: 881&#10;Explicit x1000000000: 893&#10;&#10;----------------------------------&#10;Test U2&#10;For-Loop x10000000000: 13508&#10;Template x10000000000: 7648&#10;Explicit x10000000000: 13349&#10;&#10;Test U4&#10;For-Loop x10000000000: 12094&#10;Template x10000000000: 6005&#10;Explicit x10000000000: 6267&#10;&#10;Test U8&#10;For-Loop x10000000000: 12075&#10;Template x10000000000: 5914&#10;Explicit x10000000000: 6314</span><br></pre></td></tr></table></figure></p>\n<p>输出中For Loop为循环实现，Template为模板元递归实现，Explicit为人肉实现。</p>\n<p>可以看到，For loop不出意外的慢。</p>\n<p>在Release Build模式下，模板元递归的性能与人肉循环展开一致，甚至在位长等于2的类型中优于后者，这应该是编译器优化造成的（待考）。</p>\n<p>在Debug Build模式下出现了反常，模板元递归实现的执行时间意外的比人肉实现慢：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-------------------------------------------&#10;Test U2&#10;For-Loop x100000000: 5187&#10;Template x100000000: 9629&#10;Explicit x100000000: 3576&#10;&#10;Test U4&#10;For-Loop x100000000: 4821&#10;Template x100000000: 16005&#10;Explicit x100000000: 3533&#10;&#10;Test U8&#10;For-Loop x100000000: 7009&#10;Template x100000000: 28891&#10;Explicit x100000000: 4171&#10;&#10;-------------------------------------------</span><br></pre></td></tr></table></figure>\n<p>查看Disassemblely：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//static inline void Assign(const U1 src[], U1 dest[])&#10;//&#123;&#10;01156D30  push        ebp&#10;01156D31  mov         ebp,esp&#10;01156D33  sub         esp,0C0h&#10;01156D39  push        ebx&#10;01156D3A  push        esi&#10;01156D3B  push        edi&#10;01156D3C  lea         edi,[ebp-0C0h]&#10;01156D42  mov         ecx,30h&#10;01156D47  mov         eax,0CCCCCCCCh&#10;01156D4C  rep stos    dword ptr es:[edi]&#10;//&#9;dest[byteN - 1] = src[byteLen - byteN];&#10;01156D4E  mov         eax,dword ptr [dest]&#10;01156D51  mov         ecx,dword ptr [src]&#10;01156D54  mov         dl,byte ptr [ecx]&#10;01156D56  mov         byte ptr [eax+1],dl&#10;//&#9;AssignByte&#38;lt;byteN - 1, byteLen&#38;gt;::Assign(src, dest);&#10;01156D59  mov         eax,dword ptr [dest]&#10;01156D5C  push        eax&#10;01156D5D  mov         ecx,dword ptr [src]&#10;01156D60  push        ecx&#10;01156D61  call        AssignByte&#38;lt;1,2&#38;gt;::Assign (11511FEh)&#10;01156D66  add         esp,8&#10;//&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出造成反常的原因是编译器为了便于debug，并没有进行inline优化，依然是函数调用。</p>\n<p>另外Debug模式会插入许多额外代码方便调试器，因此造成了整体性能的下降。</p>\n<p><strong>5.小结</strong></p>\n<p>因为偷懒，本文并未比较C实现与C++实现之间的性能差异，虽然有理由相信实现一中结构体静态成员函数调用的成本与C全局函数调用成本不相上下，但仍然是不严密之处。</p>\n<p>仅就3种实现的对比而言，可以确定的是：</p>\n<p>a.循环展开优化是有效果的</p>\n<p>b.执行成本：函数调用&gt;循环&gt;展开后代码</p>\n<p>c.实际优化结果结果依赖于编译器以及编译模式</p>\n<p>&nbsp;</p>\n","date":"2011-09-15T01:00:52.000Z","path":"2011/09/15/loop-unrolling-cpp/","isDark":false,"featureColor":"#a99a48","featureImage":"/image/stock/7.jpg","excerpt":"<p>这几天蛋疼，下手开始实现一个虚拟机，主要的参考书籍是Bill Blunden的&lt;Virtual Machine Design and Implementation in C/C++&gt;，书中实现了一个基本完整的HEC虚拟机。除了实践一下其中的知识以外，最主要的还是实际调查一下自己对原作者实现中不满意的地方，如果时间和精力足够，再添加没有实现的JIT以及配套的高级语言编译器。</p>\n<p>在Hec的实现中，有一个基本的功能，就是实现虚拟机字节码的endian与native code的endian之间的转换（如果相反），只是简单的颠倒字节顺序。主要在虚拟机加载字节码，开始执行之前调用，直接影响字节码加载到开始执行期间用户的等待时间。</p>\n<p>Blunden为了优化性能，在这部分应用了循环展开[<a href=\"http://en.wikipedia.org/wiki/Loop_unwinding\" title=\"Loop unwinding @ wikipedia\">1</a>]技术。本文记录了在开发过程中采用的几种与Blunden不同的实现方法，以及初步的对比。</p>","featureSwatch":{"Vibrant":{"color":"#a99a48","isDark":false,"contrast":2.8607233160176517},"Muted":{"color":"#b7ac6a","isDark":false,"contrast":2.3019786002998246},"DarkVibrant":{"color":"#8a7133","isDark":true,"contrast":4.70318580028283},"DarkMuted":{"color":"#534c37","isDark":true,"contrast":14.371837375676147},"LightVibrant":{"color":"#e4dcc3","isDark":false,"contrast":1.3703902496024831},"LightMuted":{"color":"#aba790","isDark":false,"contrast":2.4244396488445554}},"permalink":"http://catx.me/2011/09/15/loop-unrolling-cpp/","json":"data/posts/2011/09/15/loop-unrolling-cpp.json","tags":[{"name":"C++","slug":"C","path":"tags/C/","permalink":"http://catx.me/tags/C/","postCount":2},{"name":"VM","slug":"VM","path":"tags/VM/","permalink":"http://catx.me/tags/VM/","postCount":1},{"name":"optimization","slug":"optimization","path":"tags/optimization/","permalink":"http://catx.me/tags/optimization/","postCount":1},{"name":"template","slug":"template","path":"tags/template/","permalink":"http://catx.me/tags/template/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":17}]},"sha1":"353fd18a57fd3351d50cc21209d0214cdd210f69","isDigest":true}],"sha1":"ef6636840368fd1188a2a06e0d24ee747c106e6f"}
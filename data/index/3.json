{"type":"index","path":"page/3/","json_base":"data/index/","json":"data/index/3.json","prev":"data/index/2.json","current":3,"total":3,"posts":[{"type":"post","json_base":"data/posts","json":"data/posts/2013/10/04/emacs-coffee-script-auto-complete.json","path":"2013/10/04/emacs-coffee-script-auto-complete/","data":{"title":"CoffeeScript Emacs自动完成插件","content":"<p><a href=\"http://catx.me/wordpress/wp-content/uploads/2013/10/snapshoot.png\"><img src=\"/images/01c744b804dc7bc0fa68a56cca0d50206b090e62.png\" alt=\"ac-coffee-snapshot\"></a> Emacs CoffeeScript自动完成</p>\n<p>最近几个前端相关的应用，都用到了CoffeeScript。发现Emacs没有CoffeeScript的auto complete source，效率上略拖后腿，参考Emacs Auto Complete的<a href=\"http://cx4a.org/software/auto-complete/manual.html#Extend\" target=\"_blank\" rel=\"external\">文档</a>，自己写了一个。</p>\n<p>目前这个版本只是简单的基于<a href=\"http://coffeescript.org/documentation/docs/lexer.html\" target=\"_blank\" rel=\"external\">Lexer</a>，列出了所有identifier的名称，scope的信息是完全没有的，基本上够用。在后续的维护中，会基于<a href=\"http://coffeescript.org/documentation/docs/grammar.html\" target=\"_blank\" rel=\"external\">Grammar</a>，增加更多的feature。</p>\n<p>下载和安装说明都在Github上：<a href=\"http://project.catx.me/ac-coffee/\" target=\"_blank\" rel=\"external\">ac-coffee</a></p>\n","date":"2013-10-03T23:59:05.000Z","path":"2013/10/04/emacs-coffee-script-auto-complete/","isDark":true,"featureColor":"#947444","featureImage":"/image/stock/4.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#947444","isDark":true,"contrast":4.38675255709906},"Muted":{"color":"#8b704c","isDark":true,"contrast":4.720403801183811},"DarkVibrant":{"color":"#2c2214","isDark":true,"contrast":17.310047977134303},"DarkMuted":{"color":"#3e3121","isDark":true,"contrast":16.064607088557274},"LightVibrant":{"color":"#dcac74","isDark":false,"contrast":2.059564738834789}},"json":"data/posts/2013/10/04/emacs-coffee-script-auto-complete.json","tags":[{"name":"CoffeeScript","slug":"CoffeeScript","path":"tags/CoffeeScript/","permalink":"http://catx.me/tags/CoffeeScript/","postCount":9},{"name":"Emacs","slug":"Emacs","path":"tags/Emacs/","permalink":"http://catx.me/tags/Emacs/","postCount":1},{"name":"GitHub","slug":"GitHub","path":"tags/GitHub/","permalink":"http://catx.me/tags/GitHub/","postCount":9},{"name":"Lisp","slug":"Lisp","path":"tags/Lisp/","permalink":"http://catx.me/tags/Lisp/","postCount":1},{"name":"工具","slug":"工具","path":"tags/工具/","permalink":"http://catx.me/tags/工具/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]},"sha1":"b48841de0d3d2d2a5e4659703feae4334af179d3","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2013/09/30/douban-fm-api.json","path":"2013/09/30/douban-fm-api/","data":{"title":"豆瓣电台API分析","content":"<p>前几天看到命令行版的电台<a href=\"http://cmd.fm\" target=\"_blank\" rel=\"external\">cmd.fm</a>，表示键盘党最爱。<br>可惜音乐都是来自sound cloud，大天朝的重口味和网速各种水土不服，于是首先想到的就是要山寨个用豆瓣电台音乐的版本。<br>豆瓣毫无悬念的没有公开API，不过这个完全不影响抓包分析，完整的文档放在GitHub <a href=\"https://github.com/akfish/fm-terminal/blob/develop/douban-fm-api.md\" target=\"_blank\" rel=\"external\">Douban FM API Documentation</a>。</p>\n<p>现在已经用这个API做了一个命令行风格豆瓣电台的Chrome插件，<a href=\"http://fm.catx.me\" target=\"_blank\" rel=\"external\">FM Terminal</a>。</p>\n<p>所有的音乐都是防盗链的，所以Web应用的可能性不大。略诡异的是放出红心的概率比较低，不像官方版的那么容易陷入红心无法自拔。</p>\n<p>其中比较有意思的是两点，一是广告很容易和其它普通、二逼或者文艺的音乐区分开来。<br>另一个是豆瓣<a href=\"https://github.com/akfish/fm-terminal/blob/develop/douban-fm-api.md#discussion-of-history-parameter\" target=\"_blank\" rel=\"external\">追踪用户播放行为的方式</a>，正常播放完成的音乐豆瓣不关心，只对加红心、丢垃圾桶和跳过这样的“异常”行为感兴趣。传回去的记录是时序的，说明后台的算法应该是和时序有关的。</p>\n<p>不过我只想说，敢不敢让广告也能加心拖垃圾桶，挖掘下用户爱看神马广告。</p>\n<p>&nbsp;</p>\n","date":"2013-09-30T03:27:48.000Z","path":"2013/09/30/douban-fm-api/","isDark":true,"featureColor":"#2b6a7d","featureImage":"/image/stock/3.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#2b6a7d","isDark":true,"contrast":6.152506571402196},"Muted":{"color":"#628d9b","isDark":true,"contrast":3.8818866665042275},"DarkVibrant":{"color":"#08536a","isDark":true,"contrast":13.30121420712154},"DarkMuted":{"color":"#4d7e8e","isDark":true,"contrast":4.693454244598322},"LightVibrant":{"color":"#74d4e4","isDark":false,"contrast":1.7100585291773622},"LightMuted":{"color":"#769ca9","isDark":false,"contrast":2.958324937392382}},"json":"data/posts/2013/09/30/douban-fm-api.json","tags":[{"name":"GitHub","slug":"GitHub","path":"tags/GitHub/","permalink":"http://catx.me/tags/GitHub/","postCount":9},{"name":"前端","slug":"前端","path":"tags/前端/","permalink":"http://catx.me/tags/前端/","postCount":2},{"name":"豆瓣","slug":"豆瓣","path":"tags/豆瓣/","permalink":"http://catx.me/tags/豆瓣/","postCount":1},{"name":"逆向","slug":"逆向","path":"tags/逆向/","permalink":"http://catx.me/tags/逆向/","postCount":1},{"name":"音乐","slug":"音乐","path":"tags/音乐/","permalink":"http://catx.me/tags/音乐/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]},"sha1":"7838c01ac683b065efd9d6a5b65c83b6fb2b80d3","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2013/02/05/cuda5-visual-studio-2012-fix.json","path":"2013/02/05/cuda5-visual-studio-2012-fix/","data":{"title":"GPU并行编程CUDA5.0+Visual Studio 2012环境配置","content":"<h1 id=\"u95EE_u9898\"><a href=\"#u95EE_u9898\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>CUDA5.0并不支持Visual Studio 2012的v110 toolchain，所以在安装后尝试编译，会先后遇到如下的错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvcc : fatal error : &#39;-ccbin&#39;: expected a number&#10;**nvcc fatal : nvcc cannot find a supported cl version. Only MSVC 8.0 and MSVC 9.0 are supported**</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"u89E3_u51B3_u65B9_u6848_uFF1A\"><a href=\"#u89E3_u51B3_u65B9_u6848_uFF1A\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h1><h2 id=\"1-_u90E8_u7F72/_u4FEE_u6539_u914D_u7F6E_u6587_u4EF6\"><a href=\"#1-_u90E8_u7F72/_u4FEE_u6539_u914D_u7F6E_u6587_u4EF6\" class=\"headerlink\" title=\"1.部署/修改配置文件\"></a>1.部署/修改配置文件</h2><p>在C\\:\\Program Files (x86)\\MSBuild\\Microsoft.Cpp\\v4.0\\V110\\BuildCustomizations文件夹中是MSBuild要完成编译的自定义配置文件，需要手动部署（拷贝）到C:\\Program Files (x86)\\MSBuild\\Microsoft.Cpp\\v4.0\\V110\\BuildCustomizations文件夹下。本文中路径为Win7 64bit默认安装后的路径，根据自己的安装情况调整。</p>\n<p>在这之前需要修改如下文件：</p>\n<p><strong>CUDA5.0.props中</strong></p>\n<p>找到如下行：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;lt;CudaClVersion Condition=\"'$(PlatformToolset)' == 'v90'\"&amp;gt;2008&amp;lt;/CudaClVersion&amp;gt;</span><br><span class=\"line\">&amp;lt;CudaClVersion Condition=\"'$(PlatformToolset)' == 'v100'\"&amp;gt;2010&amp;lt;/CudaClVersion&amp;gt;</span><br></pre></td></tr></table></figure>\n<p>添加：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;lt;CudaClVersion Condition=\"'$(PlatformToolset)' == 'v110'\"&amp;gt;2010&amp;lt;/CudaClVersion&amp;gt;</span><br></pre></td></tr></table></figure>\n<p><strong>CUDA 5.0.targets中</strong></p>\n<p>找到CudaCleanDependsOn标签，改为：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;lt;CudaCleanDependsOn&amp;gt;</span><br><span class=\"line\">  $(CudaCompileDependsOn);</span><br><span class=\"line\">  _SelectedFiles;</span><br><span class=\"line\">  CudaFilterSelectedFiles;</span><br><span class=\"line\">  AddCudaCompileMetadata;</span><br><span class=\"line\">  AddCudaLinkMetadata;</span><br><span class=\"line\">  AddCudaCompileDeps;</span><br><span class=\"line\">  AddCudaCompilePropsDeps;</span><br><span class=\"line\">  ValidateCudaBuild;</span><br><span class=\"line\">  ValidateCudaCodeGeneration;</span><br><span class=\"line\">  ComputeCudaCompileOutput;</span><br><span class=\"line\">  PrepareForCudaBuild</span><br><span class=\"line\">&amp;lt;/CudaCleanDependsOn&amp;gt;</span><br></pre></td></tr></table></figure>\n<p>找到GenerateRelocatableDeviceCode，改为</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GenerateRelocatableDeviceCode=\"%(CudaCompile.GenerateRelocatableDeviceCode)\"</span><br></pre></td></tr></table></figure>\n<p>找到CodeGeneration，改为</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CodeGeneration=\"%(CudaCompile.CodeGenerationValues)\"</span><br></pre></td></tr></table></figure>\n<p>找到CommandLineTemplate，改为</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CommandLineTemplate=\"\"$(CudaToolkitNvccPath)\" %(CudaCompile.BuildCommandLineTemplate) %(CudaCompile.ApiCommandLineTemplate) %(CudaCompile.CleanCommandLineTemplate)\" /&amp;gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-__u4FEE_u6539_u5934_u6587_u4EF6\"><a href=\"#2-__u4FEE_u6539_u5934_u6587_u4EF6\" class=\"headerlink\" title=\"2. 修改头文件\"></a>2. 修改头文件</h2><p>C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v5.0\\include文件夹中，host_config.h文件。</p>\n<p>找到</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">if</span> _MSC_VER &amp;lt; <span class=\"number\">1400</span> || _MSC_VER &amp;gt; <span class=\"number\">1600</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">error</span> -- unsupported MSVC version! Only MSVC <span class=\"number\">8.0</span>, <span class=\"number\">9.0</span>, and <span class=\"number\">10.0</span> are supported!</span></span><br></pre></td></tr></table></figure>\n<p>修改为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">if</span> _MSC_VER &amp;lt; <span class=\"number\">1400</span> || _MSC_VER &amp;gt; <span class=\"number\">1700</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">error</span> -- unsupported MSVC version! Only MSVC <span class=\"number\">8.0</span>, <span class=\"number\">9.0</span>, and <span class=\"number\">10.0</span> are supported!</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-__u8BED_u6CD5_u9AD8_u4EAE_u652F_u6301\"><a href=\"#3-__u8BED_u6CD5_u9AD8_u4EAE_u652F_u6301\" class=\"headerlink\" title=\"3. 语法高亮支持\"></a>3. 语法高亮支持</h2><ol>\n<li>菜单“Tools-&gt;Options…”，展开左侧“Text Editor”，点击“File Extension”.</li>\n<li>在“Extension”框中输入“cu”, 选择“Microsoft Visual C++”，点击“Add”，捅“OK”。</li>\n<li>重新打开文件</li>\n</ol>\n<p>## </p>\n","date":"2013-02-05T03:37:57.000Z","path":"2013/02/05/cuda5-visual-studio-2012-fix/","isDark":true,"featureColor":"#947444","featureImage":"/image/stock/4.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#947444","isDark":true,"contrast":4.38675255709906},"Muted":{"color":"#8b704c","isDark":true,"contrast":4.720403801183811},"DarkVibrant":{"color":"#2c2214","isDark":true,"contrast":17.310047977134303},"DarkMuted":{"color":"#3e3121","isDark":true,"contrast":16.064607088557274},"LightVibrant":{"color":"#dcac74","isDark":false,"contrast":2.059564738834789}},"json":"data/posts/2013/02/05/cuda5-visual-studio-2012-fix.json","tags":[{"name":"CUDA","slug":"CUDA","path":"tags/CUDA/","permalink":"http://catx.me/tags/CUDA/","postCount":1},{"name":"GPU","slug":"GPU","path":"tags/GPU/","permalink":"http://catx.me/tags/GPU/","postCount":1},{"name":"Visual Studio 2012","slug":"Visual-Studio-2012","path":"tags/Visual-Studio-2012/","permalink":"http://catx.me/tags/Visual-Studio-2012/","postCount":2}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]},"sha1":"39ec1ac0fa60b1476d4dc20d9d1ac52eb6cdc4fe","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2012/05/11/windows-sudo-batch.json","path":"2012/05/11/windows-sudo-batch/","data":{"title":"用批处理在Windows下实现sudo命令","content":"<p>在Windows下运行某些命令的时候，必须要管理员权限。每次要重新选择“以管理员权限运行”很不方便而且没有效率，于是写了一个批处理文件，实现类似Linux下的sudo命令。</p>\n<p>保存为sudo.bat，放在环境变量PATH中指定的任意一个文件夹下，在命令行窗口中输入：</p>\n<blockquote>\n<p>sudo [command line]</p>\n</blockquote>\n<p>就会出现UAC对话框，确认后就会以管理员权限执行指定的命令。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Echo off&#10;:: Check for permissions&#10;&#38;gt;nul 2&#38;gt;&#38;amp;1 &#34;%SYSTEMROOT%\\system32\\cacls.exe&#34; &#34;%SYSTEMROOT%\\system32\\config\\system&#34;&#10;&#10;:: If error flag set, we do not have admin.&#10;if &#39;%errorlevel%&#39; NEQ &#39;0&#39; (&#10;Echo Requesting administrative privileges...&#10;goto UACPrompt&#10;) else ( goto gotAdmin )&#10;&#10;:UACPrompt&#10;Echo Set UAC = CreateObject^(&#34;Shell.Application&#34;^) &#38;gt; &#34;%temp%\\getadmin.vbs&#34;&#10;Echo UAC.ShellExecute &#34;%~s0&#34;, &#34;%*&#34;, &#34;&#34;, &#34;runas&#34;, 1 &#38;gt;&#38;gt; &#34;%temp%\\getadmin.vbs&#34;&#10;&#10;&#34;%temp%\\getadmin.vbs&#34;&#10;Exit &#10;&#10;:gotAdmin&#10;if exist &#34;%temp%\\getadmin.vbs&#34; ( Del &#34;%temp%\\getadmin.vbs&#34; )&#10;Pushd &#34;%CD%&#34;&#10;CD /D &#34;%~dp0&#34;&#10;:--------------------------------------&#10;cmd.exe /k %*</span><br></pre></td></tr></table></figure>\n<p>类似的也可以用ls.bat来模拟Linux的ls命令，就不用担心习惯ls手抖打错了：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@echo off&#10;dir %*</span><br></pre></td></tr></table></figure>\n","date":"2012-05-11T04:00:43.000Z","path":"2012/05/11/windows-sudo-batch/","isDark":true,"featureColor":"#266cb4","featureImage":"/image/stock/1.jpg","excerpt":"<p>在Windows下运行某些命令的时候，必须要管理员权限。每次要重新选择“以管理员权限运行”很不方便而且没有效率，于是写了一个批处理文件，实现类似Linux下的sudo命令。</p>\n<p>保存为sudo.bat，放在环境变量PATH中指定的任意一个文件夹下，在命令行窗口中输入：</p>\n<blockquote>\n<p>sudo [command line]</p>\n</blockquote>\n<p>就会出现UAC对话框，确认后就会以管理员权限执行指定的命令。</p>","featureSwatch":{"Vibrant":{"color":"#266cb4","isDark":true,"contrast":5.450121616568956},"Muted":{"color":"#4b70a6","isDark":true,"contrast":5.296212493095912},"DarkVibrant":{"color":"#3260a1","isDark":true,"contrast":10.521199995853594},"DarkMuted":{"color":"#515787","isDark":true,"contrast":11.462157427934459},"LightVibrant":{"color":"#5791c6","isDark":true,"contrast":3.512948192359975},"LightMuted":{"color":"#9bb4cc","isDark":false,"contrast":2.144138719552091}},"json":"data/posts/2012/05/11/windows-sudo-batch.json","tags":[{"name":"Linux","slug":"Linux","path":"tags/Linux/","permalink":"http://catx.me/tags/Linux/","postCount":1},{"name":"sudo","slug":"sudo","path":"tags/sudo/","permalink":"http://catx.me/tags/sudo/","postCount":1},{"name":"命令行","slug":"命令行","path":"tags/命令行/","permalink":"http://catx.me/tags/命令行/","postCount":1},{"name":"管理","slug":"管理","path":"tags/管理/","permalink":"http://catx.me/tags/管理/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]},"sha1":"872807fe615e745e86f8f737f22de590a48520f0","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2011/09/15/loop-unrolling-cpp.json","path":"2011/09/15/loop-unrolling-cpp/","data":{"title":"关于循环展开优化","content":"<p>这几天蛋疼，下手开始实现一个虚拟机，主要的参考书籍是Bill Blunden的&lt;Virtual Machine Design and Implementation in C/C++&gt;，书中实现了一个基本完整的HEC虚拟机。除了实践一下其中的知识以外，最主要的还是实际调查一下自己对原作者实现中不满意的地方，如果时间和精力足够，再添加没有实现的JIT以及配套的高级语言编译器。</p>\n<p>在Hec的实现中，有一个基本的功能，就是实现虚拟机字节码的endian与native code的endian之间的转换（如果相反），只是简单的颠倒字节顺序。主要在虚拟机加载字节码，开始执行之前调用，直接影响字节码加载到开始执行期间用户的等待时间。</p>\n<p>Blunden为了优化性能，在这部分应用了循环展开[<a href=\"http://en.wikipedia.org/wiki/Loop_unwinding\" title=\"Loop unwinding @ wikipedia\" target=\"_blank\" rel=\"external\">1</a>]技术。本文记录了在开发过程中采用的几种与Blunden不同的实现方法，以及初步的对比。</p>\n<a id=\"more\"></a>\n<p><strong>0. Blunden原始实现</strong></p>\n<p>原始实现提供了一系列单独的bytecodeToTypeName以及typeNameToBytecode全局函数：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">U2 <span class=\"title\">bytecodeToWord</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">U4 <span class=\"title\">bytecodeToDWord</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">U8 <span class=\"title\">bytecodeToQWord</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">F4 <span class=\"title\">bytecodeToFloat</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">F8 <span class=\"title\">bytecodeToDouble</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">wordToBytecode</span><span class=\"params\">(U2 word, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dwordToBytecode</span><span class=\"params\">(U4 dword, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">qwordToBytecode</span><span class=\"params\">(U8 qword, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">floatToBytecode</span><span class=\"params\">(F4 flt, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doubleToBytecode</span><span class=\"params\">(F8 dbl, U1 arr[])</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>其中U代表unsigned，后面的数字代表位长，在win32平台下的定义为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S1\tsigned char</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S2\tsigned short</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S4\tsigned long</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S8\tsigned __int64\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U1\tunsigned char</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U2\tunsigned short</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U4\tunsigned long</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U8\tunsigned __int64</span></span><br></pre></td></tr></table></figure>\n<p>以下仅列举U8版本的qwordToBytecode实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">qwordToBytecode</span><span class=\"params\">(U8 qword, U1 arr[])</span></span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">\tU1 *buffer;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbuffer = (U1*)&amp;amp;qword;</span><br><span class=\"line\">\tarr[<span class=\"number\">0</span>] = buffer[<span class=\"number\">7</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">1</span>] = buffer[<span class=\"number\">6</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">2</span>] = buffer[<span class=\"number\">5</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">3</span>] = buffer[<span class=\"number\">4</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">4</span>] = buffer[<span class=\"number\">3</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">5</span>] = buffer[<span class=\"number\">2</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">6</span>] = buffer[<span class=\"number\">1</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">7</span>] = buffer[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;<span class=\"comment\">/*end qwordToBytecode*/</span></span><br></pre></td></tr></table></figure>\n<p>可以看出Blunden的实现是C Style的，基本上就是一大堆全局函数与变量，缺乏封装性。各个类型的转换函数没有统一的调用接口，而且由于采用了循环展开，导致对每一个类型转换的函数体都非常冗长，整个代码就变成了一大堆重复代码的组合。</p>\n<p>当然这主要是出于性能的考虑，不过考虑到现在的C++编译器的性能已经不再是当年的情况，C++完全可以做到与C相同甚至更好的性能，同时提供更易于维护的代码。实际上，很多C语言写的程序最后也是用C++编译器编译的。</p>\n<p><strong>1.实现一：For Loop</strong></p>\n<p>在讨论优化之前，要有个被优化的对象作为对比，以下是用For循环在一个struct中实现同样的功能：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">typename</span> T&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ForLoopAssign</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &amp;lt; <span class=\"keyword\">sizeof</span>(T); i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tdest[i] = src[<span class=\"keyword\">sizeof</span>(T) - i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里只是最主要的交换赋值部分，采用了模板类，为的是同一个接口实现不同类型转换功能的调用，而不是若干个单独的函数。</p>\n<p>模板类在编译时就会被展开，因此在运行时的性能损耗很小。</p>\n<p>可以看到这段代码的优点是简短，易于维护，几行代码实现了几十行代码的功能。缺点当然是For-Loop造成的性能损耗。</p>\n<p>调用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ForLoopAssign&amp;lt;T&amp;gt;::AssignBytes(src, dest);</span><br></pre></td></tr></table></figure>\n<p><strong>2.实现二：手动循环展开</strong></p>\n<p>Prototype：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">int</span> byteLen&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>特化：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">1</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">2</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">4</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">2</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">3</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">8</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">7</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">6</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">2</span>] = src[<span class=\"number\">5</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">3</span>] = src[<span class=\"number\">4</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">4</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">5</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">6</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">7</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其实就是对C Style实现的C++封装，性能接近原实现，调用只需要一句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExplicitUnrolling&amp;lt;<span class=\"keyword\">sizeof</span>(T)&amp;gt;::AssignBytes(src, dest);</span><br></pre></td></tr></table></figure>\n<p>显然，作为显示实现的代码，也是难于维护的。</p>\n<p><strong>3.实现3：模板元递归</strong></p>\n<p>递归模板：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">int</span> byteN, <span class=\"keyword\">int</span> byteLen&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> AssignByte</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Assign</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[byteN - <span class=\"number\">1</span>] = src[byteLen - byteN];</span><br><span class=\"line\">\t\tAssignByte&amp;lt;byteN - <span class=\"number\">1</span>, byteLen&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>递归边界：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">int</span> byteLen&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> AssignByte&amp;lt;<span class=\"number\">1</span>, byteLen&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Assign</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[byteLen - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AssignByte&amp;lt;<span class=\"keyword\">sizeof</span>(T), <span class=\"keyword\">sizeof</span>(T)&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>\n<p>和For Loop实现相比，这段代码只长了几句，但是却实现了循环展开。</p>\n<p>以U4为例，调用的时候实际上是：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">4</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>\n<p>在Assign函数体中形成递归调用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dest[<span class=\"number\">4</span> - byteLen] = src[<span class=\"number\">4</span> - byteLen];</span><br><span class=\"line\"><span class=\"comment\">//递归调用</span></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">4</span> - <span class=\"number\">1</span>, byteLen&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>\n<p>直到传入的byteN == 1到达递归边界。</p>\n<p>但这个递归是在编译时进行的，实际上是编译器递归的生成了如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">4</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">3</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\tAssignByte&amp;lt;<span class=\"number\">3</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">3</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">2</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\tAssignByte&amp;lt;<span class=\"number\">2</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">2</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">\tAssignByte&amp;lt;<span class=\"number\">1</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">1</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以在运行时没有任何递归，只是一系列的函数调用，但更妙的是对于足够短的函数体，编译器会自动进行inline优化，省略函数调用，以上代码最后编译后等效于人肉实现的循环展开。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dest[<span class=\"number\">0</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">dest[<span class=\"number\">1</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">dest[<span class=\"number\">2</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">dest[<span class=\"number\">3</span>] = src[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>这种方法最后做到了与For Loop相近长度的易于维护的代码，以及（理论上）与人肉循环展开一致的性能。</p>\n<p><strong>4.测试与结果分析</strong></p>\n<p>测试代码分别调用以上3种实现100000000、1000000000、10000000000次，记录执行时间。</p>\n<p>测试平台：Windows 7 Ultimate 32bit + Visual Studio 2010</p>\n<p>Release Build:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----------------------------------&#10;Test U2&#10;For-Loop x100000000: 207&#10;Template x100000000: 88&#10;Explicit x100000000: 119&#10;&#10;Test U4&#10;For-Loop x100000000: 183&#10;Template x100000000: 85&#10;Explicit x100000000: 93&#10;&#10;Test U8&#10;For-Loop x100000000: 182&#10;Template x100000000: 86&#10;Explicit x100000000: 86&#10;&#10;----------------------------------&#10;Test U2&#10;For-Loop x1000000000: 1768&#10;Template x1000000000: 878&#10;Explicit x1000000000: 1169&#10;&#10;Test U4&#10;For-Loop x1000000000: 1796&#10;Template x1000000000: 879&#10;Explicit x1000000000: 882&#10;&#10;Test U8&#10;For-Loop x1000000000: 1760&#10;Template x1000000000: 881&#10;Explicit x1000000000: 893&#10;&#10;----------------------------------&#10;Test U2&#10;For-Loop x10000000000: 13508&#10;Template x10000000000: 7648&#10;Explicit x10000000000: 13349&#10;&#10;Test U4&#10;For-Loop x10000000000: 12094&#10;Template x10000000000: 6005&#10;Explicit x10000000000: 6267&#10;&#10;Test U8&#10;For-Loop x10000000000: 12075&#10;Template x10000000000: 5914&#10;Explicit x10000000000: 6314</span><br></pre></td></tr></table></figure></p>\n<p>输出中For Loop为循环实现，Template为模板元递归实现，Explicit为人肉实现。</p>\n<p>可以看到，For loop不出意外的慢。</p>\n<p>在Release Build模式下，模板元递归的性能与人肉循环展开一致，甚至在位长等于2的类型中优于后者，这应该是编译器优化造成的（待考）。</p>\n<p>在Debug Build模式下出现了反常，模板元递归实现的执行时间意外的比人肉实现慢：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-------------------------------------------&#10;Test U2&#10;For-Loop x100000000: 5187&#10;Template x100000000: 9629&#10;Explicit x100000000: 3576&#10;&#10;Test U4&#10;For-Loop x100000000: 4821&#10;Template x100000000: 16005&#10;Explicit x100000000: 3533&#10;&#10;Test U8&#10;For-Loop x100000000: 7009&#10;Template x100000000: 28891&#10;Explicit x100000000: 4171&#10;&#10;-------------------------------------------</span><br></pre></td></tr></table></figure>\n<p>查看Disassemblely：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//static inline void Assign(const U1 src[], U1 dest[])&#10;//&#123;&#10;01156D30  push        ebp&#10;01156D31  mov         ebp,esp&#10;01156D33  sub         esp,0C0h&#10;01156D39  push        ebx&#10;01156D3A  push        esi&#10;01156D3B  push        edi&#10;01156D3C  lea         edi,[ebp-0C0h]&#10;01156D42  mov         ecx,30h&#10;01156D47  mov         eax,0CCCCCCCCh&#10;01156D4C  rep stos    dword ptr es:[edi]&#10;//&#9;dest[byteN - 1] = src[byteLen - byteN];&#10;01156D4E  mov         eax,dword ptr [dest]&#10;01156D51  mov         ecx,dword ptr [src]&#10;01156D54  mov         dl,byte ptr [ecx]&#10;01156D56  mov         byte ptr [eax+1],dl&#10;//&#9;AssignByte&#38;lt;byteN - 1, byteLen&#38;gt;::Assign(src, dest);&#10;01156D59  mov         eax,dword ptr [dest]&#10;01156D5C  push        eax&#10;01156D5D  mov         ecx,dword ptr [src]&#10;01156D60  push        ecx&#10;01156D61  call        AssignByte&#38;lt;1,2&#38;gt;::Assign (11511FEh)&#10;01156D66  add         esp,8&#10;//&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出造成反常的原因是编译器为了便于debug，并没有进行inline优化，依然是函数调用。</p>\n<p>另外Debug模式会插入许多额外代码方便调试器，因此造成了整体性能的下降。</p>\n<p><strong>5.小结</strong></p>\n<p>因为偷懒，本文并未比较C实现与C++实现之间的性能差异，虽然有理由相信实现一中结构体静态成员函数调用的成本与C全局函数调用成本不相上下，但仍然是不严密之处。</p>\n<p>仅就3种实现的对比而言，可以确定的是：</p>\n<p>a.循环展开优化是有效果的</p>\n<p>b.执行成本：函数调用&gt;循环&gt;展开后代码</p>\n<p>c.实际优化结果结果依赖于编译器以及编译模式</p>\n<p>&nbsp;</p>\n","date":"2011-09-15T01:00:52.000Z","path":"2011/09/15/loop-unrolling-cpp/","isDark":false,"featureColor":"#d19e40","featureImage":"/image/stock/5.jpg","excerpt":"<p>这几天蛋疼，下手开始实现一个虚拟机，主要的参考书籍是Bill Blunden的&lt;Virtual Machine Design and Implementation in C/C++&gt;，书中实现了一个基本完整的HEC虚拟机。除了实践一下其中的知识以外，最主要的还是实际调查一下自己对原作者实现中不满意的地方，如果时间和精力足够，再添加没有实现的JIT以及配套的高级语言编译器。</p>\n<p>在Hec的实现中，有一个基本的功能，就是实现虚拟机字节码的endian与native code的endian之间的转换（如果相反），只是简单的颠倒字节顺序。主要在虚拟机加载字节码，开始执行之前调用，直接影响字节码加载到开始执行期间用户的等待时间。</p>\n<p>Blunden为了优化性能，在这部分应用了循环展开[<a href=\"http://en.wikipedia.org/wiki/Loop_unwinding\" title=\"Loop unwinding @ wikipedia\">1</a>]技术。本文记录了在开发过程中采用的几种与Blunden不同的实现方法，以及初步的对比。</p>","featureSwatch":{"Vibrant":{"color":"#d19e40","isDark":false,"contrast":2.433412395275077},"Muted":{"color":"#798249","isDark":true,"contrast":4.168289617634703},"DarkVibrant":{"color":"#97623d","isDark":true,"contrast":7.586487507499872},"DarkMuted":{"color":"#5a4e32","isDark":true,"contrast":14.22073373466042},"LightVibrant":{"color":"#d6c395","isDark":false,"contrast":1.7356438765314866},"LightMuted":{"color":"#aea18e","isDark":false,"contrast":2.5336980009663206}},"json":"data/posts/2011/09/15/loop-unrolling-cpp.json","tags":[{"name":"C++","slug":"C","path":"tags/C/","permalink":"http://catx.me/tags/C/","postCount":2},{"name":"VM","slug":"VM","path":"tags/VM/","permalink":"http://catx.me/tags/VM/","postCount":1},{"name":"optimization","slug":"optimization","path":"tags/optimization/","permalink":"http://catx.me/tags/optimization/","postCount":1},{"name":"template","slug":"template","path":"tags/template/","permalink":"http://catx.me/tags/template/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]},"sha1":"f1b0b4b5a32f68a9d635407277293dfdde221d7e","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2011/06/06/noctilucent-cloud.json","path":"2011/06/06/noctilucent-cloud/","data":{"title":"高纬度地区不只有极光 还有夜光云","content":"<p><img src=\"/images/46f0d466ca6404ea0257f79e81f4beab8cdb8245.jpg\" alt=\"\"></p>\n<p>高纬度地区的群众们，除了能看到下雪、极光、受全球变暖影响融化中的冰川甚至北极熊以外，还有一个著名的独有的现象就是极光。</p>\n<p>所以上个冬天成都飘雪的时候，见多识广的高纬度同学都对激动的南方围观群众的内牛满面表示不解与淡定。</p>\n<p>不过这些都不是本文重点，接下来要介绍的夜光云（Noctilucent cloud），又是一种高纬度地区的群众才能围观到的美丽景象。最近欧洲又进入了夜光云季节，各种围观群众纷纷45度仰望，在一些专业网站（如<a href=\"http://spaceweather.com/\" target=\"_blank\" rel=\"external\">spaceweather</a>）也能找到观光指南。</p>\n<a id=\"more\"></a>\n<p><img src=\"/images/aa171b8034c5f86713be6f26d07c13646d2a9541.jpg\" alt=\"\"></p>\n<p>夜光云，简单的说，是一种，夜光的，云。对于这种绝对正确的废话，软件工程的同学们是非常熟悉的。（软件工程是神马？I.工程化的，写软件。II.对I这句废话的研究）</p>\n<p>详细的说起来，夜光云的外观具有非常诡异的美感：天鹅绒一样的质感，蓝色电晕一样的颜色，而且只出现在高纬度地区（50°~70°，南北半球均有，但南半球太过暗淡）夏天日落后的黄昏。</p>\n<p>不过尽管和极光有那么一点神似，其实它真的是云。形成在距地面76~85公里高度的中间层，是地球上最高的云。</p>\n<p><img src=\"/images/91d7a75c79ae37bc643da5764e050f8de1d849e8.jpg\" alt=\"\"></p>\n<p>上图为普通云层与夜光云的区别，可以看到夜光云高度更高，而且是发光（反光）而不是吸收光线。</p>\n<p>关于夜光云的形成，目前认为其主体是中间层直径为100纳米左右的冰晶，平时非常暗淡不容易观察到，在夏天时中间层温度最低，冰晶密度增大，由于日落后阳光的照射而反光可见（此时低层大气和地面已经受不到阳光照射，故称其夜光）。</p>\n<p>关于夜光云最早的记载在1885年，喀拉喀托火山爆发后的2年。至于夜光云是因为火山的爆发才开始出现，还是因为火山爆发后，日落变得更加壮观，围观群众变多提高了它被发现的概率，这就不为人知了。</p>\n<p><img src=\"/images/9c3e2cf631191e1eba4a6263e7a64f73fb04cc82.jpg\" alt=\"\"></p>\n<p>夜光云的出现在工业革命后20世纪开始增多，并且最近几年越来越频繁并且范围也有所扩大，研究表明这与人类活动导致的全球变暖有密切联系（-_-又是你们人类干的好事）。气候模型指出，温室气体的增加导致中间层的温度降低，因为更多的太阳辐射被低层大气吸收。另有理论计算表明，畜牧业的发展所增加的甲烷排放在过去的一百年中翻了一倍，使得上层大气中的水蒸气含量大幅度增加。</p>\n<p>所以你们人类在组成观光团围观这一美景的时候，想想Windows死机时的蓝屏也差不多是这个颜色，好自为之吧。</p>\n","date":"2011-06-05T16:19:51.000Z","path":"2011/06/06/noctilucent-cloud/","isDark":true,"featureColor":"#2b6a7d","featureImage":"/image/stock/3.jpg","excerpt":"<p><img src=\"/images/46f0d466ca6404ea0257f79e81f4beab8cdb8245.jpg\" alt=\"\"></p>\n<p>高纬度地区的群众们，除了能看到下雪、极光、受全球变暖影响融化中的冰川甚至北极熊以外，还有一个著名的独有的现象就是极光。</p>\n<p>所以上个冬天成都飘雪的时候，见多识广的高纬度同学都对激动的南方围观群众的内牛满面表示不解与淡定。</p>\n<p>不过这些都不是本文重点，接下来要介绍的夜光云（Noctilucent cloud），又是一种高纬度地区的群众才能围观到的美丽景象。最近欧洲又进入了夜光云季节，各种围观群众纷纷45度仰望，在一些专业网站（如<a href=\"http://spaceweather.com/\">spaceweather</a>）也能找到观光指南。</p>","featureSwatch":{"Vibrant":{"color":"#2b6a7d","isDark":true,"contrast":6.152506571402196},"Muted":{"color":"#628d9b","isDark":true,"contrast":3.8818866665042275},"DarkVibrant":{"color":"#08536a","isDark":true,"contrast":13.30121420712154},"DarkMuted":{"color":"#4d7e8e","isDark":true,"contrast":4.693454244598322},"LightVibrant":{"color":"#74d4e4","isDark":false,"contrast":1.7100585291773622},"LightMuted":{"color":"#769ca9","isDark":false,"contrast":2.958324937392382}},"json":"data/posts/2011/06/06/noctilucent-cloud.json","tags":[{"name":"云","slug":"云","path":"tags/云/","permalink":"http://catx.me/tags/云/","postCount":1},{"name":"天文","slug":"天文","path":"tags/天文/","permalink":"http://catx.me/tags/天文/","postCount":1}],"categories":[{"name":"天文","slug":"天文","path":"categories/天文/","permalink":"http://catx.me/categories/天文/","postCount":1}]},"sha1":"448c3119fd08ed76bb614af7dd0e1c58e01aca7f","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2011/05/12/fan-study-2-rmt.json","path":"2011/05/12/fan-study-2-rmt/","data":{"title":"单片机控制笔记本风扇(2)-串口控制与测速","content":"<p>第二部分完成。</p>\n<p><strong>A.速度控制\n</strong></p>\n<p>首先增加电路方便调试：</p>\n<p>两个按钮连接到两个中断口INT0/P3.2和IN1/P3.3，一个加速一个减速。</p>\n<p>两个LED连接到P0.1和P0.3，显示速度是否为0或者是否最大。</p>\n<p>一个开关接到风扇和Vcc之间，出错的话可以快速杀掉风扇。</p>\n<a id=\"more\"></a>\n<p>剩的就是代码了，PWM部分：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化PWM0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PWM_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCON = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCMOD = <span class=\"number\">0x02</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCL = <span class=\"number\">0x00</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCH = <span class=\"number\">0x00</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAPM0 = <span class=\"number\">0x42</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAP0L = <span class=\"number\">0x80</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAP0H = <span class=\"number\">0x80</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCR = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置PWM0占空比实现速度控制</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PWM0_set</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> a)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAP0L = a;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAP0H = a;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//四个控速函数SPEED_UP(), SPEED_DOWN, SPEED_FULL, SPEED_STOP中调用PWM0_set，检查边界，处理LED，以UP为例</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> <span class=\"title\">SPEED_UP</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (PWM_VALUE &amp;gt; <span class=\"number\">0x00</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tPWM_VALUE --;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tPWM0_set(PWM_VALUE);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tLED_L = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tLED_R = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0x00</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tLED_R = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0x02</span>; <span class=\"comment\">//Top speed 0010,用于串口通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">两个按钮的中断响应函数</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//Left button</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">INT_1</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> interrupt 2 <span class=\"keyword\">using</span> 2 </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSPEED_DOWN();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Right button</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">INT_0</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> interrupt 0 <span class=\"keyword\">using</span> 1 </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSPEED_UP();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>B.串口通信\n</strong></p>\n<p>1.通信协议：</p>\n<p>波特率4800bps，停止位1。</p>\n<p>2.控制帧：</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HEAD(0xFE)</td>\n<td>CTRL(1 byte)</td>\n<td>PWM_VALUE(1 byte)</td>\n<td>END(0xFF)</td>\n</tr>\n</tbody>\n</table>\n<p>由电脑发出实现控制。</p>\n<p>CTRL取值 a,s,w,d的ascii码，分别代表停止、减速、加速、全速，虽然其实只需要占用2位就能完成编码，主要是为了兼容一开始时用终端人肉调试时的习惯懒得修改。</p>\n<p>计划增加一个x控制码，可以直接将PWM占空比设定到第三位的PWM_VALUE。</p>\n<p>3.数据帧：</p>\n<p>单片机向电脑发送的数据，有两种类型。</p>\n<p>a.响应帧：</p>\n<p>每收到一个控制帧，就会传回一个响应帧，如果需要，可附加执行结果。</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TAG(0xF1)</td>\n<td>CTRL(1 byte)</td>\n<td>EXTRA_DATA(1 byte)</td>\n<td>END(0xFF)</td>\n</tr>\n</tbody>\n</table>\n<p>TAG用于帧类型识别。</p>\n<p>CTRL与收到的控制帧相同。</p>\n<p>EXTRA_DATA为附加数据，目前只用到最后两位编码风扇是否达到最大或最小速度（0x02和0x01），便于电脑上客户端软件正确刷新UI。</p>\n<p>b.信息帧：</p>\n<p>每秒发送一帧，包含风扇转速。</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TAG(0xF0)</td>\n<td>SPEED (1 byte)</td>\n<td>SPEED(1 byte)</td>\n<td>END(0xFF)</td>\n</tr>\n</tbody>\n</table>\n<p>TAG用于帧类型识别。</p>\n<p>SPEED从高位到低位存储。</p>\n<p>4.代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//串口初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UART_init</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//EA = 1; //允许总中断</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tES = <span class=\"number\">1</span>; <span class=\"comment\">//允许UART串口的中断</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//TMOD = 0x20;    //定时器T/C1工作方式2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tSCON = <span class=\"number\">0x50</span>;    <span class=\"comment\">//串口工作方式1，允许串口接收（SCON = 0x40 时禁止串口接收）</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTH1 = <span class=\"number\">0xF3</span>;    <span class=\"comment\">//定时器初值高8位设置</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTL1 = <span class=\"number\">0xF3</span>;    <span class=\"comment\">//定时器初值低8位设置</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tPCON = <span class=\"number\">0x80</span>;    <span class=\"comment\">//波特率倍频（注销本句波特率为2400）</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTR1 = <span class=\"number\">1</span>;    <span class=\"comment\">//定时器启动</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发送一个byte数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UART_T</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> UART_data)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSBUF = UART_data;    <span class=\"comment\">//将接收的数据发送回去</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(TI == <span class=\"number\">0</span>);        <span class=\"comment\">//检查发送中断标志位</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTI = <span class=\"number\">0</span>;            <span class=\"comment\">//令发送中断标志位为0</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//中断响应数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UART_R</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span> interrupt 4 <span class=\"keyword\">using</span> 1</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> UART_data; <span class=\"comment\">//定义串口接收数据变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tRI = <span class=\"number\">0</span>;            <span class=\"comment\">//令接收中断标志位为0（软件清零）</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tUART_T(<span class=\"number\">0xF1</span>); <span class=\"comment\">//Response</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tUART_data = SBUF;    <span class=\"comment\">//将接收到的数据送入变量 UART_data</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//用户函数内容（用户可使用UART_data做数据处理）</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tUART_T(UART_data);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (UART_data) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">'a'</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUART_T(SPEED_STOP());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">'d'</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUART_T(SPEED_FULL());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">'w'</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUART_T(SPEED_UP());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">'s'</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUART_T(SPEED_DOWN());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUART_T(<span class=\"number\">0xFF</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>C.测速\n</strong></p>\n<p>风扇每转一圈输出2个脉冲，所以只要计算采样时间内脉冲数量就可以测速。要达到这个目的，需要一个计数器记录脉冲数量，一个定时器在固定的时间生成数据帧通过串口发送，然后清零计数器</p>\n<p>STC12C5A60S2有两个计时器/计数器T0和T1，T1已经被串口通信占用，所以只能使用T0作为计数器，将风扇黄色引脚连T0/P3.4</p>\n<p>还需要一个计时器，通过数据手册发现两个PWM口都可以被设置为定时器使用，于是用没有被占用的PWM1进行计时。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//计数器初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">T_C_init</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//TMOD = 0x11; //高4位控制T/C1 [ GATE，C/T，M1，M0，GATE，C/T，M1，M0 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//EA = 1;    //中断总开关</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTH0 = <span class=\"number\">0x00</span>; <span class=\"comment\">//16位计数寄存器T0高8位</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTL0 = <span class=\"number\">0x00</span>; <span class=\"comment\">//16位计数寄存器T0低8位s</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tET0 = <span class=\"number\">1</span>; <span class=\"comment\">//T/C0中断开关</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTR0 = <span class=\"number\">1</span>; <span class=\"comment\">//T/C0启动开关</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//计数器中断响应</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">T_C0</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span> interrupt 1 <span class=\"keyword\">using</span> 1</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTH0 = <span class=\"number\">0x00</span>; <span class=\"comment\">//重置计数器</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTL0 = <span class=\"number\">0x00</span>; <span class=\"comment\">//以风扇的转速，这段代码被执行的概率非常低</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//PWM1计时器模式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PCA_TIMER1_init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCON = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCL = <span class=\"number\">0</span>; <span class=\"comment\">//Reset PCA base time;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tCH = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCMOD = <span class=\"number\">0x00</span>;    <span class=\"comment\">//Timer clock source as Fosc/12</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tvalue = T100Hz;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAP1L = value;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAP1H = value &amp;gt;&amp;gt; <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvalue += T100Hz;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAPM1 = <span class=\"number\">0x49</span>;    <span class=\"comment\">//PCA 0 in 16bit timer mode and enable PCA interuppt</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tCR = <span class=\"number\">1</span>;    <span class=\"comment\">//PCA timer start</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//PWM1计时器中断，执行频率为100Hz，每1秒发送一个数据包</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PCA_TIMER1</span><span class=\"params\">()</span> interrupt 7 <span class=\"keyword\">using</span> 1 </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCF1 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAP1L = value;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAP1H = value &amp;gt;&amp;gt; <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvalue += T100Hz;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cnt == <span class=\"number\">100</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUART_T(<span class=\"number\">0xF0</span>); <span class=\"comment\">//Info</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUART_T(TH0);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUART_T(TL0);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUART_T(<span class=\"number\">0xFF</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tTH0 = <span class=\"number\">0x00</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tTL0 = <span class=\"number\">0x00</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后得事情就很简单了，用C#写了一个Windows Form Application来获取转速并实现控制：</p>\n<p><img src=\"/images/3007bf5075c98f7c0d519298341a6ea976d57243.jpg\" alt=\"\"></p>\n<p>最高转速为50RPS左右，约3000RPM，和在上一篇通过比特率估计的数量级一致。</p>\n<p>很有意思的一个发现是，风扇口被堵住时，转速会升高。</p>\n","date":"2011-05-12T15:23:02.000Z","path":"2011/05/12/fan-study-2-rmt/","isDark":true,"featureColor":"#947444","featureImage":"/image/stock/4.jpg","excerpt":"<p>第二部分完成。</p>\n<p><strong>A.速度控制\n</strong></p>\n<p>首先增加电路方便调试：</p>\n<p>两个按钮连接到两个中断口INT0/P3.2和IN1/P3.3，一个加速一个减速。</p>\n<p>两个LED连接到P0.1和P0.3，显示速度是否为0或者是否最大。</p>\n<p>一个开关接到风扇和Vcc之间，出错的话可以快速杀掉风扇。</p>","featureSwatch":{"Vibrant":{"color":"#947444","isDark":true,"contrast":4.38675255709906},"Muted":{"color":"#8b704c","isDark":true,"contrast":4.720403801183811},"DarkVibrant":{"color":"#2c2214","isDark":true,"contrast":17.310047977134303},"DarkMuted":{"color":"#3e3121","isDark":true,"contrast":16.064607088557274},"LightVibrant":{"color":"#dcac74","isDark":false,"contrast":2.059564738834789}},"json":"data/posts/2011/05/12/fan-study-2-rmt.json","tags":[{"name":"单片机","slug":"单片机","path":"tags/单片机/","permalink":"http://catx.me/tags/单片机/","postCount":2},{"name":"电子","slug":"电子","path":"tags/电子/","permalink":"http://catx.me/tags/电子/","postCount":2},{"name":"风扇","slug":"风扇","path":"tags/风扇/","permalink":"http://catx.me/tags/风扇/","postCount":2}],"categories":[{"name":"硬","slug":"硬","path":"categories/硬/","permalink":"http://catx.me/categories/硬/","postCount":2}]},"sha1":"d77b7da3399783d956345290eb9e23cdd48c1e4d","isDigest":true},{"type":"post","json_base":"data/posts","json":"data/posts/2011/05/11/fan-study-1-pin-de.json","path":"2011/05/11/fan-study-1-pin-de/","data":{"title":"单片机控制笔记本风扇(1)-引脚定义","content":"<p>由于今天照例失眠，顺手把前几天刚换下的老旧笔记本风扇拆开折腾，作为从软转硬的Hello world。</p>\n<p>采用的芯片是STC12C4052AD，用USP转ISP模块供电+串口通信。</p>\n<p>整个折腾的大致计划是：</p>\n<ol>\n<li>无刷风扇的引脚定义以及控制方法</li>\n<li>用单片机读取风扇转速并实现调速控制</li>\n</ol>\n<p><div><a id=\"more\"></a></div><br><img src=\"/images/e19f51b63051b973df9e04e2091b1c96e5dac72b.jpg\" alt=\"\"></p>\n<p>A. 首先观察单片机的引脚定义把ISP下载线搞好，在面包板上搭好了用12MHz外部晶振的最小系统。这部分毫无难度，没神马好说的。</p>\n<p>B. 然后拆风扇，有4条连线，颜色分别是红黑黄蓝。</p>\n<p>红色和黑色对于所有理科人类以及部分文科人类而言，一眼就能看出必然是负责供电的。</p>\n<p>黑色接GND，红色接Vcc，果断风扇就开始biubiu的转动了。</p>\n<p>黄色和蓝色其中之一必然是风扇转速输出，由于手里没有万用表或示波器，就分别用蓝线和黄线短接单片机的3号引脚（TXD），然后就可以在笔记本上通过串口助手查看通过ISP模块传回的串口电平变化。结果是黄色有稳定的数据输出，蓝色没有任何输出。几乎可以确定黄色就是转速信号的输出了。</p>\n<p>为了确定这一点，断掉风扇的电源然后人肉转动，结果神马都没发生。</p>\n<p>接下来研究蓝色了，首先接到Vcc上，没有任何变化，风扇依然biubiu的转；然后插到GND，风扇神奇的停止了转动，然后人肉转动风扇，发现黄色脚有数据输出，每一转两个脉冲。</p>\n<p>于是可以确定各个引脚的作用：</p>\n<table>\n<thead>\n<tr>\n<th>颜色</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>红</td>\n<td>Vcc （接公共正极）</td>\n</tr>\n<tr>\n<td>黑</td>\n<td>GND （接公共地）</td>\n</tr>\n<tr>\n<td>黄</td>\n<td>脉冲信号输出，一圈两次。（接TXD输出到串口）</td>\n</tr>\n<tr>\n<td>蓝</td>\n<td>控制信号，高电平正常转动，低电平停转。（接PWM0，见下文）</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/images/b17abc0595e4256524ee17d9e7f9b53535012d44.jpg\" alt=\"\"></p>\n<p>C.控制信号研究</p>\n<p>风扇的转速是可调的，所以蓝色信号线的作用不仅仅是开关。</p>\n<p>查阅STC12C4052AD的引脚定义，发现有两个能产生PWM信号的引脚，PWM0（11脚）和PWM1（9脚）。</p>\n<p>接下来就是对单片机编程产生一个PWM控制信号，当然作为一个死程序员，软的部分几乎可以说不是问题了。</p>\n<p>在对蓝色信号线输入一个频率按正弦规律变化的PWM信号以后，在笔记本上通过串口接收到的Raw Data（1/2控制信号周期）如下：</p>\n<p><img src=\"/images/f16c6566b3d4f480b8b47913948ae88b91306cc6.png\" alt=\"\"></p>\n<p>可以看出风扇转速大致按照控制信号的变化而变化，其中有一部分数值变小是因为软件按照一定的编码规则把字节截断了。</p>\n<p>值得一提的是，串口通信时有多种波特率可以选择，波特率直接决定软件如何截断字节流。</p>\n<p>在这个试验中，只有最低的波特率600bps能够得出可读的有意义数据，从这个结果可以估计出风扇的转速大概在10^3(rpm)的数量级，与实际情况下风扇的转速吻合，进一步验证了之前的结果。（以3000rpm为例，每秒钟50转，产生100个高电平脉冲，考虑两个脉冲信号之间的（低电平信号）距离会大于最小距离，输出信号的波特率数量级大概就是10^2bps）</p>\n","date":"2011-05-11T01:14:32.000Z","path":"2011/05/11/fan-study-1-pin-de/","isDark":false,"featureColor":"#d19e40","featureImage":"/image/stock/5.jpg","excerpt":"<p>由于今天照例失眠，顺手把前几天刚换下的老旧笔记本风扇拆开折腾，作为从软转硬的Hello world。</p>\n<p>采用的芯片是STC12C4052AD，用USP转ISP模块供电+串口通信。</p>\n<p>整个折腾的大致计划是：</p>\n<ol>\n<li>无刷风扇的引脚定义以及控制方法</li>\n<li>用单片机读取风扇转速并实现调速控制</li>\n</ol>\n<p><div>","featureSwatch":{"Vibrant":{"color":"#d19e40","isDark":false,"contrast":2.433412395275077},"Muted":{"color":"#798249","isDark":true,"contrast":4.168289617634703},"DarkVibrant":{"color":"#97623d","isDark":true,"contrast":7.586487507499872},"DarkMuted":{"color":"#5a4e32","isDark":true,"contrast":14.22073373466042},"LightVibrant":{"color":"#d6c395","isDark":false,"contrast":1.7356438765314866},"LightMuted":{"color":"#aea18e","isDark":false,"contrast":2.5336980009663206}},"json":"data/posts/2011/05/11/fan-study-1-pin-de.json","tags":[{"name":"单片机","slug":"单片机","path":"tags/单片机/","permalink":"http://catx.me/tags/单片机/","postCount":2},{"name":"电子","slug":"电子","path":"tags/电子/","permalink":"http://catx.me/tags/电子/","postCount":2},{"name":"风扇","slug":"风扇","path":"tags/风扇/","permalink":"http://catx.me/tags/风扇/","postCount":2}],"categories":[{"name":"硬","slug":"硬","path":"categories/硬/","permalink":"http://catx.me/categories/硬/","postCount":2}]},"sha1":"0059efdcacff42af53a508fc86277928feefa8bb","isDigest":true}],"sha1":"b433e057a942dbc5ce79e8489f6efaa940329443"}
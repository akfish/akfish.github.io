{"type":"post","json_base":"data/posts","json":"data/posts/2011/05/12/fan-study-2-rmt.json","path":"2011/05/12/fan-study-2-rmt/","data":{"title":"单片机控制笔记本风扇(2)-串口控制与测速","content":"<p>第二部分完成。</p>\n<p><strong>A.速度控制\n</strong></p>\n<p>首先增加电路方便调试：</p>\n<p>两个按钮连接到两个中断口INT0/P3.2和IN1/P3.3，一个加速一个减速。</p>\n<p>两个LED连接到P0.1和P0.3，显示速度是否为0或者是否最大。</p>\n<p>一个开关接到风扇和Vcc之间，出错的话可以快速杀掉风扇。</p>\n<a id=\"more\"></a>\n<p>剩的就是代码了，PWM部分：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化PWM0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PWM_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCON = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCMOD = <span class=\"number\">0x02</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCL = <span class=\"number\">0x00</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCH = <span class=\"number\">0x00</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAPM0 = <span class=\"number\">0x42</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAP0L = <span class=\"number\">0x80</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAP0H = <span class=\"number\">0x80</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCR = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置PWM0占空比实现速度控制</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PWM0_set</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> a)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAP0L = a;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAP0H = a;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//四个控速函数SPEED_UP(), SPEED_DOWN, SPEED_FULL, SPEED_STOP中调用PWM0_set，检查边界，处理LED，以UP为例</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> <span class=\"title\">SPEED_UP</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (PWM_VALUE &amp;gt; <span class=\"number\">0x00</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tPWM_VALUE --;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tPWM0_set(PWM_VALUE);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tLED_L = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tLED_R = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0x00</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tLED_R = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0x02</span>; <span class=\"comment\">//Top speed 0010,用于串口通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">两个按钮的中断响应函数</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//Left button</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">INT_1</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> interrupt 2 <span class=\"keyword\">using</span> 2 </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSPEED_DOWN();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Right button</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">INT_0</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> interrupt 0 <span class=\"keyword\">using</span> 1 </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSPEED_UP();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>B.串口通信\n</strong></p>\n<p>1.通信协议：</p>\n<p>波特率4800bps，停止位1。</p>\n<p>2.控制帧：</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HEAD(0xFE)</td>\n<td>CTRL(1 byte)</td>\n<td>PWM_VALUE(1 byte)</td>\n<td>END(0xFF)</td>\n</tr>\n</tbody>\n</table>\n<p>由电脑发出实现控制。</p>\n<p>CTRL取值 a,s,w,d的ascii码，分别代表停止、减速、加速、全速，虽然其实只需要占用2位就能完成编码，主要是为了兼容一开始时用终端人肉调试时的习惯懒得修改。</p>\n<p>计划增加一个x控制码，可以直接将PWM占空比设定到第三位的PWM_VALUE。</p>\n<p>3.数据帧：</p>\n<p>单片机向电脑发送的数据，有两种类型。</p>\n<p>a.响应帧：</p>\n<p>每收到一个控制帧，就会传回一个响应帧，如果需要，可附加执行结果。</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TAG(0xF1)</td>\n<td>CTRL(1 byte)</td>\n<td>EXTRA_DATA(1 byte)</td>\n<td>END(0xFF)</td>\n</tr>\n</tbody>\n</table>\n<p>TAG用于帧类型识别。</p>\n<p>CTRL与收到的控制帧相同。</p>\n<p>EXTRA_DATA为附加数据，目前只用到最后两位编码风扇是否达到最大或最小速度（0x02和0x01），便于电脑上客户端软件正确刷新UI。</p>\n<p>b.信息帧：</p>\n<p>每秒发送一帧，包含风扇转速。</p>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TAG(0xF0)</td>\n<td>SPEED (1 byte)</td>\n<td>SPEED(1 byte)</td>\n<td>END(0xFF)</td>\n</tr>\n</tbody>\n</table>\n<p>TAG用于帧类型识别。</p>\n<p>SPEED从高位到低位存储。</p>\n<p>4.代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//串口初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UART_init</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//EA = 1; //允许总中断</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tES = <span class=\"number\">1</span>; <span class=\"comment\">//允许UART串口的中断</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//TMOD = 0x20;    //定时器T/C1工作方式2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tSCON = <span class=\"number\">0x50</span>;    <span class=\"comment\">//串口工作方式1，允许串口接收（SCON = 0x40 时禁止串口接收）</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTH1 = <span class=\"number\">0xF3</span>;    <span class=\"comment\">//定时器初值高8位设置</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTL1 = <span class=\"number\">0xF3</span>;    <span class=\"comment\">//定时器初值低8位设置</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tPCON = <span class=\"number\">0x80</span>;    <span class=\"comment\">//波特率倍频（注销本句波特率为2400）</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTR1 = <span class=\"number\">1</span>;    <span class=\"comment\">//定时器启动</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发送一个byte数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UART_T</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> UART_data)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSBUF = UART_data;    <span class=\"comment\">//将接收的数据发送回去</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(TI == <span class=\"number\">0</span>);        <span class=\"comment\">//检查发送中断标志位</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTI = <span class=\"number\">0</span>;            <span class=\"comment\">//令发送中断标志位为0</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//中断响应数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UART_R</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span> interrupt 4 <span class=\"keyword\">using</span> 1</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> UART_data; <span class=\"comment\">//定义串口接收数据变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tRI = <span class=\"number\">0</span>;            <span class=\"comment\">//令接收中断标志位为0（软件清零）</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tUART_T(<span class=\"number\">0xF1</span>); <span class=\"comment\">//Response</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tUART_data = SBUF;    <span class=\"comment\">//将接收到的数据送入变量 UART_data</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//用户函数内容（用户可使用UART_data做数据处理）</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tUART_T(UART_data);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (UART_data) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">'a'</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUART_T(SPEED_STOP());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">'d'</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUART_T(SPEED_FULL());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">'w'</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUART_T(SPEED_UP());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">'s'</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUART_T(SPEED_DOWN());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUART_T(<span class=\"number\">0xFF</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>C.测速\n</strong></p>\n<p>风扇每转一圈输出2个脉冲，所以只要计算采样时间内脉冲数量就可以测速。要达到这个目的，需要一个计数器记录脉冲数量，一个定时器在固定的时间生成数据帧通过串口发送，然后清零计数器</p>\n<p>STC12C5A60S2有两个计时器/计数器T0和T1，T1已经被串口通信占用，所以只能使用T0作为计数器，将风扇黄色引脚连T0/P3.4</p>\n<p>还需要一个计时器，通过数据手册发现两个PWM口都可以被设置为定时器使用，于是用没有被占用的PWM1进行计时。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//计数器初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">T_C_init</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//TMOD = 0x11; //高4位控制T/C1 [ GATE，C/T，M1，M0，GATE，C/T，M1，M0 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//EA = 1;    //中断总开关</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTH0 = <span class=\"number\">0x00</span>; <span class=\"comment\">//16位计数寄存器T0高8位</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTL0 = <span class=\"number\">0x00</span>; <span class=\"comment\">//16位计数寄存器T0低8位s</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tET0 = <span class=\"number\">1</span>; <span class=\"comment\">//T/C0中断开关</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTR0 = <span class=\"number\">1</span>; <span class=\"comment\">//T/C0启动开关</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//计数器中断响应</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">T_C0</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span> interrupt 1 <span class=\"keyword\">using</span> 1</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTH0 = <span class=\"number\">0x00</span>; <span class=\"comment\">//重置计数器</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tTL0 = <span class=\"number\">0x00</span>; <span class=\"comment\">//以风扇的转速，这段代码被执行的概率非常低</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//PWM1计时器模式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PCA_TIMER1_init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCON = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCL = <span class=\"number\">0</span>; <span class=\"comment\">//Reset PCA base time;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tCH = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCMOD = <span class=\"number\">0x00</span>;    <span class=\"comment\">//Timer clock source as Fosc/12</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tvalue = T100Hz;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAP1L = value;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAP1H = value &amp;gt;&amp;gt; <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvalue += T100Hz;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAPM1 = <span class=\"number\">0x49</span>;    <span class=\"comment\">//PCA 0 in 16bit timer mode and enable PCA interuppt</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tCR = <span class=\"number\">1</span>;    <span class=\"comment\">//PCA timer start</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//PWM1计时器中断，执行频率为100Hz，每1秒发送一个数据包</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PCA_TIMER1</span><span class=\"params\">()</span> interrupt 7 <span class=\"keyword\">using</span> 1 </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCF1 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAP1L = value;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCCAP1H = value &amp;gt;&amp;gt; <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvalue += T100Hz;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cnt == <span class=\"number\">100</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUART_T(<span class=\"number\">0xF0</span>); <span class=\"comment\">//Info</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUART_T(TH0);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUART_T(TL0);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUART_T(<span class=\"number\">0xFF</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tTH0 = <span class=\"number\">0x00</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tTL0 = <span class=\"number\">0x00</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后得事情就很简单了，用C#写了一个Windows Form Application来获取转速并实现控制：</p>\n<p><img src=\"/images/3007bf5075c98f7c0d519298341a6ea976d57243.jpg\" alt=\"\"></p>\n<p>最高转速为50RPS左右，约3000RPM，和在上一篇通过比特率估计的数量级一致。</p>\n<p>很有意思的一个发现是，风扇口被堵住时，转速会升高。</p>\n","date":"2011-05-12T15:23:02.000Z","path":"2011/05/12/fan-study-2-rmt/","isDark":true,"featureColor":"#947444","featureImage":"/image/stock/4.jpg","excerpt":"<p>第二部分完成。</p>\n<p><strong>A.速度控制\n</strong></p>\n<p>首先增加电路方便调试：</p>\n<p>两个按钮连接到两个中断口INT0/P3.2和IN1/P3.3，一个加速一个减速。</p>\n<p>两个LED连接到P0.1和P0.3，显示速度是否为0或者是否最大。</p>\n<p>一个开关接到风扇和Vcc之间，出错的话可以快速杀掉风扇。</p>","featureSwatch":{"Vibrant":{"color":"#947444","isDark":true,"contrast":4.38675255709906},"Muted":{"color":"#8b704c","isDark":true,"contrast":4.720403801183811},"DarkVibrant":{"color":"#2c2214","isDark":true,"contrast":17.310047977134303},"DarkMuted":{"color":"#3e3121","isDark":true,"contrast":16.064607088557274},"LightVibrant":{"color":"#dcac74","isDark":false,"contrast":2.059564738834789}},"json":"data/posts/2011/05/12/fan-study-2-rmt.json","tags":[{"name":"单片机","slug":"单片机","path":"tags/单片机/","permalink":"http://catx.me/tags/单片机/","postCount":2},{"name":"电子","slug":"电子","path":"tags/电子/","permalink":"http://catx.me/tags/电子/","postCount":2},{"name":"风扇","slug":"风扇","path":"tags/风扇/","permalink":"http://catx.me/tags/风扇/","postCount":2}],"categories":[{"name":"硬","slug":"硬","path":"categories/硬/","permalink":"http://catx.me/categories/硬/","postCount":2}]},"sha1":"d77b7da3399783d956345290eb9e23cdd48c1e4d","prev":{"title":"用C# ILGenerator在运行时动态生成proxy","content":"<h2 id=\"u95EE_u9898_u63CF_u8FF0\"><a href=\"#u95EE_u9898_u63CF_u8FF0\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>C#中经常会遇到通过单一入口动态调用对象或服务的情况，形如：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title\">ProxyBase</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">object</span> <span class=\"title\">Invoke</span>(<span class=\"params\"><span class=\"keyword\">object</span> someMethodRelatedInfo, <span class=\"keyword\">object</span>[] arguments</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比如Reflection，远程服务，Host动态脚本引擎时从C#调用引擎context内的方法等等情况都可以归类于这样的模型。</p>\n<p>一种较好的工程实现就是把这些服务方法用接口定义，获得强类型的校验，避免出现不必要的bug，并便于维护。如：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IFooService</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MethodWithNoReturn</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MethodTakeParameterAndReturn</span>(<span class=\"params\"><span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于不同的后端，需要有具体的调用实现：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">FooProxyBase</span> : <span class=\"title\">ProxyBase</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> <span class=\"keyword\">object</span> <span class=\"title\">Invoke</span>(<span class=\"params\"><span class=\"keyword\">object</span> someMethodRelatedInfo, <span class=\"keyword\">object</span>[] arguments</span>)</span><br><span class=\"line\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Pack to JSON and send via http</span></span><br><span class=\"line\">    <span class=\"comment\">// Or adapte and call other classes</span></span><br><span class=\"line\">    <span class=\"comment\">// Or whatever</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终的Proxy类通过继承调用实现类，同时实现服务约定接口实现：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FooService : FooProxyBase, IFooService</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  #region Implement IFooService</span><br><span class=\"line\">  public void MethodWithNoReturn() </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    Invoke(\"MethodWithNoReturn\", new object[0]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public int MethodTakeParameterAndReturn(int a, int b)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    return Invoke(\"MethodTakeParameterAndReturn\", new object[] &#123; a, b &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  #endregion</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样一来有一个显然的问题，Proxy类包含大量重复的代码，方法越多实现起来越费劲。这个问题的point of interest就在于Proxy类的动态生成，实现以后只需要一行代码就能替代人肉实现一个巨大的Proxy类：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IFooService proxy = ProxyEmitter.CreateProxy&amp;lt;FooProxyBase, IFooService&amp;gt;(<span class=\"comment\">/*Constructor parameters are supported*/</span>);</span><br></pre></td></tr></table></figure>\n<p>要动态生成Proxy类有很多种方法（如生成源代码然后编译），这里采用在运行时通过Reflection获取服务接口的方法，动态生成Proxy类，最后用ILGenerator.Emit用.Net IL实现代码逻辑。</p>\n<h2 id=\"u5B9E_u73B0_u8981_u70B9\"><a href=\"#u5B9E_u73B0_u8981_u70B9\" class=\"headerlink\" title=\"实现要点\"></a>实现要点</h2><p>如何动态创建Assembly, Module, Type的框架性代码MSDN有详尽的walkthrough，不在本文讨论重点，具体实现可参考源代码。</p>\n<p>这一节记录在实现这个项目中几处逻辑的IL代码生成，有几点是必须要知道的：</p>\n<ul>\n<li>.Net CLR是基于栈的虚拟机</li>\n<li>.Net CLR（在生成C#类时）是强类型的</li>\n<li>参数顺序入栈</li>\n<li>非static method的第一个参数总是this指针</li>\n</ul>\n<p>1. 有参数的constructor</p>\n<p>在C#中很多涉及自动生成的情况（如serialization）都要求无参数的constructor，在有的情况下很让人忧桑，其实要支持有参数的constructor也是可行的。</p>\n<p>如果父类只有一个有参数的constructor，子类的constructor实现必须用足够的参数构造：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>: <span class=\"title\">Base</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Derived</span>(<span class=\"params\"><span class=\"keyword\">int</span> may, <span class=\"keyword\">string</span> para, <span class=\"keyword\">object</span>[] meters</span>): <span class=\"title\">base</span>(<span class=\"params\">may, para, meters</span>) </span>&#123;&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用IL实现上述代码，需要将参数重新压栈，然后call base的ctor指针：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">EmitCtor</span>(<span class=\"params\">TypeBuilder tBuilder, ConstructorInfo ctor</span>)</span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pTypes = ctor.GetParameters().Select(p =&amp;gt; p.ParameterType).ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> builder = Emitter.GetConstructor(</span><br><span class=\"line\">        tBuilder,</span><br><span class=\"line\">        MethodAttributes.Public |</span><br><span class=\"line\">        MethodAttributes.HideBySig |</span><br><span class=\"line\">        MethodAttributes.SpecialName |</span><br><span class=\"line\">        MethodAttributes.RTSpecialName,</span><br><span class=\"line\">        pTypes</span><br><span class=\"line\">        );</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ilGen = builder.GetILGenerator();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// No locals</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Load all args, note arg 0 is this pointer, so must emit one more</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &amp;lt;= pTypes.Length; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        DoEmit(ilGen, OpCodes.Ldarg_S, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Call base ctor</span></span><br><span class=\"line\">    DoEmit(ilGen, OpCodes.Call, ctor);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Return</span></span><br><span class=\"line\">    DoEmit(ilGen, OpCodes.Ret);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生成的IL形如：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IL_0000: ldarg.0</span><br><span class=\"line\">IL_0001: ldarg.1</span><br><span class=\"line\">IL_0002: ldarg.2</span><br><span class=\"line\">IL_0003: ldarg.3</span><br><span class=\"line\">IL_0004: call instance void Base::.ctor(int32, string, object)</span><br><span class=\"line\">IL_0009: ret</span><br></pre></td></tr></table></figure>\n<p>2. Array的初始化<br>由于Invoke的长相，决定了这个生成器中需要大量的生成object[]对象，并把参数装进去。<br>创建一个local variable，首先需要declare：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ilGen.DeclareLocal(<span class=\"keyword\">typeof</span>(<span class=\"keyword\">object</span>[]))</span><br></pre></td></tr></table></figure>\n<p>每个method的运行环境里维护了一个local列表，IL代码通过index把local入栈和出栈。<br>创建Array对象，并设置到local：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize array</span></span><br><span class=\"line\"><span class=\"comment\">// IL_0006:  ldc.i4.x</span></span><br><span class=\"line\">DoEmit(ilGen, OpCodes.Ldc_I4_S, pTypes.Length);</span><br><span class=\"line\"><span class=\"comment\">// IL_0007:  newarr     [mscorlib]System.Object</span></span><br><span class=\"line\">DoEmit(ilGen, OpCodes.Newarr, <span class=\"keyword\">typeof</span>(Object));</span><br><span class=\"line\"><span class=\"comment\">// IL_000c:  stloc.1</span></span><br><span class=\"line\">DoEmit(ilGen, OpCodes.Stloc_0);</span><br><span class=\"line\">``` </span><br><span class=\"line\">对Array元素的逐条赋值由<span class=\"number\">4</span>~<span class=\"number\">5</span>条机器指令完成：</span><br><span class=\"line\"></span><br><span class=\"line\">*   ldloc.?将array入栈</span><br><span class=\"line\">*   ldc_i4_?将当前元素的index入栈</span><br><span class=\"line\">*   将需要赋给元素的值入栈（本例中为参数用ldarg_s，注意参数<span class=\"number\">0</span>为<span class=\"keyword\">this</span>指针）</span><br><span class=\"line\">*   如果是<span class=\"keyword\">value</span> type需要box</span><br><span class=\"line\">*   stelem.<span class=\"keyword\">ref</span>指令完成赋值</span><br><span class=\"line\"></span><br><span class=\"line\">```cs</span><br><span class=\"line\"><span class=\"comment\">// Now fill the array</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &amp;lt; pTypes.Length; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Load the array first</span></span><br><span class=\"line\">    <span class=\"comment\">// IL_000X + 00: ldloc.0</span></span><br><span class=\"line\">    DoEmit(ilGen, OpCodes.Ldloc_0);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Push the index</span></span><br><span class=\"line\">    <span class=\"comment\">// IL_000X + 01: ldc_i4_x</span></span><br><span class=\"line\">    DoEmit(ilGen, OpCodes.Ldc_I4_S, i);</span><br><span class=\"line\">    <span class=\"comment\">// Load argument i + 1 (note that argument 0 is this pointer(?))</span></span><br><span class=\"line\">    <span class=\"comment\">// IL_000X + 02: ldarg_X</span></span><br><span class=\"line\">    DoEmit(ilGen, OpCodes.Ldarg_S, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Box value type</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pTypes[i].IsValueType)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// IL_000X + 03: box pTypes[i]</span></span><br><span class=\"line\">        DoEmit(ilGen, OpCodes.Box, pTypes[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Set arrary element</span></span><br><span class=\"line\">    <span class=\"comment\">// IL_00X + ??: stelem.ref</span></span><br><span class=\"line\">    DoEmit(ilGen, OpCodes.Stelem_Ref);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"u6E90_u4EE3_u7801_u53CA_u4F7F_u7528_u65B9_u6CD5\"><a href=\"#u6E90_u4EE3_u7801_u53CA_u4F7F_u7528_u65B9_u6CD5\" class=\"headerlink\" title=\"源代码及使用方法\"></a>源代码及使用方法</h2><p>见<a href=\"https://github.com/akfish/ProxyEmitter\" target=\"_blank\" rel=\"external\">GitHub</a>。</p>\n","date":"2014-02-28T18:50:56.000Z","path":"2014/03/01/generate-dynamic-proxy-class-at-runtime-with-ilgenerator-c-sharp/","isDark":false,"featureColor":"#d19e40","featureImage":"/image/stock/5.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#d19e40","isDark":false,"contrast":2.433412395275077},"Muted":{"color":"#798249","isDark":true,"contrast":4.168289617634703},"DarkVibrant":{"color":"#97623d","isDark":true,"contrast":7.586487507499872},"DarkMuted":{"color":"#5a4e32","isDark":true,"contrast":14.22073373466042},"LightVibrant":{"color":"#d6c395","isDark":false,"contrast":1.7356438765314866},"LightMuted":{"color":"#aea18e","isDark":false,"contrast":2.5336980009663206}},"json":"data/posts/2014/03/01/generate-dynamic-proxy-class-at-runtime-with-ilgenerator-c-sharp.json","tags":[{"name":".Net","slug":"Net","path":"tags/Net/","permalink":"http://catx.me/tags/Net/","postCount":5},{"name":"compiler","slug":"compiler","path":"tags/compiler/","permalink":"http://catx.me/tags/compiler/","postCount":5}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]},"next":{"title":"单片机控制笔记本风扇(1)-引脚定义","content":"<p>由于今天照例失眠，顺手把前几天刚换下的老旧笔记本风扇拆开折腾，作为从软转硬的Hello world。</p>\n<p>采用的芯片是STC12C4052AD，用USP转ISP模块供电+串口通信。</p>\n<p>整个折腾的大致计划是：</p>\n<ol>\n<li>无刷风扇的引脚定义以及控制方法</li>\n<li>用单片机读取风扇转速并实现调速控制</li>\n</ol>\n<p><div><a id=\"more\"></a></div><br><img src=\"/images/e19f51b63051b973df9e04e2091b1c96e5dac72b.jpg\" alt=\"\"></p>\n<p>A. 首先观察单片机的引脚定义把ISP下载线搞好，在面包板上搭好了用12MHz外部晶振的最小系统。这部分毫无难度，没神马好说的。</p>\n<p>B. 然后拆风扇，有4条连线，颜色分别是红黑黄蓝。</p>\n<p>红色和黑色对于所有理科人类以及部分文科人类而言，一眼就能看出必然是负责供电的。</p>\n<p>黑色接GND，红色接Vcc，果断风扇就开始biubiu的转动了。</p>\n<p>黄色和蓝色其中之一必然是风扇转速输出，由于手里没有万用表或示波器，就分别用蓝线和黄线短接单片机的3号引脚（TXD），然后就可以在笔记本上通过串口助手查看通过ISP模块传回的串口电平变化。结果是黄色有稳定的数据输出，蓝色没有任何输出。几乎可以确定黄色就是转速信号的输出了。</p>\n<p>为了确定这一点，断掉风扇的电源然后人肉转动，结果神马都没发生。</p>\n<p>接下来研究蓝色了，首先接到Vcc上，没有任何变化，风扇依然biubiu的转；然后插到GND，风扇神奇的停止了转动，然后人肉转动风扇，发现黄色脚有数据输出，每一转两个脉冲。</p>\n<p>于是可以确定各个引脚的作用：</p>\n<table>\n<thead>\n<tr>\n<th>颜色</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>红</td>\n<td>Vcc （接公共正极）</td>\n</tr>\n<tr>\n<td>黑</td>\n<td>GND （接公共地）</td>\n</tr>\n<tr>\n<td>黄</td>\n<td>脉冲信号输出，一圈两次。（接TXD输出到串口）</td>\n</tr>\n<tr>\n<td>蓝</td>\n<td>控制信号，高电平正常转动，低电平停转。（接PWM0，见下文）</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/images/b17abc0595e4256524ee17d9e7f9b53535012d44.jpg\" alt=\"\"></p>\n<p>C.控制信号研究</p>\n<p>风扇的转速是可调的，所以蓝色信号线的作用不仅仅是开关。</p>\n<p>查阅STC12C4052AD的引脚定义，发现有两个能产生PWM信号的引脚，PWM0（11脚）和PWM1（9脚）。</p>\n<p>接下来就是对单片机编程产生一个PWM控制信号，当然作为一个死程序员，软的部分几乎可以说不是问题了。</p>\n<p>在对蓝色信号线输入一个频率按正弦规律变化的PWM信号以后，在笔记本上通过串口接收到的Raw Data（1/2控制信号周期）如下：</p>\n<p><img src=\"/images/f16c6566b3d4f480b8b47913948ae88b91306cc6.png\" alt=\"\"></p>\n<p>可以看出风扇转速大致按照控制信号的变化而变化，其中有一部分数值变小是因为软件按照一定的编码规则把字节截断了。</p>\n<p>值得一提的是，串口通信时有多种波特率可以选择，波特率直接决定软件如何截断字节流。</p>\n<p>在这个试验中，只有最低的波特率600bps能够得出可读的有意义数据，从这个结果可以估计出风扇的转速大概在10^3(rpm)的数量级，与实际情况下风扇的转速吻合，进一步验证了之前的结果。（以3000rpm为例，每秒钟50转，产生100个高电平脉冲，考虑两个脉冲信号之间的（低电平信号）距离会大于最小距离，输出信号的波特率数量级大概就是10^2bps）</p>\n","date":"2011-05-11T01:14:32.000Z","path":"2011/05/11/fan-study-1-pin-de/","isDark":false,"featureColor":"#d19e40","featureImage":"/image/stock/5.jpg","excerpt":"<p>由于今天照例失眠，顺手把前几天刚换下的老旧笔记本风扇拆开折腾，作为从软转硬的Hello world。</p>\n<p>采用的芯片是STC12C4052AD，用USP转ISP模块供电+串口通信。</p>\n<p>整个折腾的大致计划是：</p>\n<ol>\n<li>无刷风扇的引脚定义以及控制方法</li>\n<li>用单片机读取风扇转速并实现调速控制</li>\n</ol>\n<p><div>","featureSwatch":{"Vibrant":{"color":"#d19e40","isDark":false,"contrast":2.433412395275077},"Muted":{"color":"#798249","isDark":true,"contrast":4.168289617634703},"DarkVibrant":{"color":"#97623d","isDark":true,"contrast":7.586487507499872},"DarkMuted":{"color":"#5a4e32","isDark":true,"contrast":14.22073373466042},"LightVibrant":{"color":"#d6c395","isDark":false,"contrast":1.7356438765314866},"LightMuted":{"color":"#aea18e","isDark":false,"contrast":2.5336980009663206}},"json":"data/posts/2011/05/11/fan-study-1-pin-de.json","tags":[{"name":"单片机","slug":"单片机","path":"tags/单片机/","permalink":"http://catx.me/tags/单片机/","postCount":2},{"name":"电子","slug":"电子","path":"tags/电子/","permalink":"http://catx.me/tags/电子/","postCount":2},{"name":"风扇","slug":"风扇","path":"tags/风扇/","permalink":"http://catx.me/tags/风扇/","postCount":2}],"categories":[{"name":"硬","slug":"硬","path":"categories/硬/","permalink":"http://catx.me/categories/硬/","postCount":2}]}}
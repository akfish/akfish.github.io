{"type":"post","json_base":"data/posts","json":"data/posts/2011/06/06/noctilucent-cloud.json","path":"2011/06/06/noctilucent-cloud/","data":{"title":"高纬度地区不只有极光 还有夜光云","content":"<p><img src=\"/images/46f0d466ca6404ea0257f79e81f4beab8cdb8245.jpg\" alt=\"\"></p>\n<p>高纬度地区的群众们，除了能看到下雪、极光、受全球变暖影响融化中的冰川甚至北极熊以外，还有一个著名的独有的现象就是极光。</p>\n<p>所以上个冬天成都飘雪的时候，见多识广的高纬度同学都对激动的南方围观群众的内牛满面表示不解与淡定。</p>\n<p>不过这些都不是本文重点，接下来要介绍的夜光云（Noctilucent cloud），又是一种高纬度地区的群众才能围观到的美丽景象。最近欧洲又进入了夜光云季节，各种围观群众纷纷45度仰望，在一些专业网站（如<a href=\"http://spaceweather.com/\" target=\"_blank\" rel=\"external\">spaceweather</a>）也能找到观光指南。</p>\n<a id=\"more\"></a>\n<p><img src=\"/images/aa171b8034c5f86713be6f26d07c13646d2a9541.jpg\" alt=\"\"></p>\n<p>夜光云，简单的说，是一种，夜光的，云。对于这种绝对正确的废话，软件工程的同学们是非常熟悉的。（软件工程是神马？I.工程化的，写软件。II.对I这句废话的研究）</p>\n<p>详细的说起来，夜光云的外观具有非常诡异的美感：天鹅绒一样的质感，蓝色电晕一样的颜色，而且只出现在高纬度地区（50°~70°，南北半球均有，但南半球太过暗淡）夏天日落后的黄昏。</p>\n<p>不过尽管和极光有那么一点神似，其实它真的是云。形成在距地面76~85公里高度的中间层，是地球上最高的云。</p>\n<p><img src=\"/images/91d7a75c79ae37bc643da5764e050f8de1d849e8.jpg\" alt=\"\"></p>\n<p>上图为普通云层与夜光云的区别，可以看到夜光云高度更高，而且是发光（反光）而不是吸收光线。</p>\n<p>关于夜光云的形成，目前认为其主体是中间层直径为100纳米左右的冰晶，平时非常暗淡不容易观察到，在夏天时中间层温度最低，冰晶密度增大，由于日落后阳光的照射而反光可见（此时低层大气和地面已经受不到阳光照射，故称其夜光）。</p>\n<p>关于夜光云最早的记载在1885年，喀拉喀托火山爆发后的2年。至于夜光云是因为火山的爆发才开始出现，还是因为火山爆发后，日落变得更加壮观，围观群众变多提高了它被发现的概率，这就不为人知了。</p>\n<p><img src=\"/images/9c3e2cf631191e1eba4a6263e7a64f73fb04cc82.jpg\" alt=\"\"></p>\n<p>夜光云的出现在工业革命后20世纪开始增多，并且最近几年越来越频繁并且范围也有所扩大，研究表明这与人类活动导致的全球变暖有密切联系（-_-又是你们人类干的好事）。气候模型指出，温室气体的增加导致中间层的温度降低，因为更多的太阳辐射被低层大气吸收。另有理论计算表明，畜牧业的发展所增加的甲烷排放在过去的一百年中翻了一倍，使得上层大气中的水蒸气含量大幅度增加。</p>\n<p>所以你们人类在组成观光团围观这一美景的时候，想想Windows死机时的蓝屏也差不多是这个颜色，好自为之吧。</p>\n","date":"2011-06-05T16:19:51.000Z","path":"2011/06/06/noctilucent-cloud/","isDark":true,"featureColor":"#2b6a7d","featureImage":"/image/stock/3.jpg","excerpt":"<p><img src=\"/images/46f0d466ca6404ea0257f79e81f4beab8cdb8245.jpg\" alt=\"\"></p>\n<p>高纬度地区的群众们，除了能看到下雪、极光、受全球变暖影响融化中的冰川甚至北极熊以外，还有一个著名的独有的现象就是极光。</p>\n<p>所以上个冬天成都飘雪的时候，见多识广的高纬度同学都对激动的南方围观群众的内牛满面表示不解与淡定。</p>\n<p>不过这些都不是本文重点，接下来要介绍的夜光云（Noctilucent cloud），又是一种高纬度地区的群众才能围观到的美丽景象。最近欧洲又进入了夜光云季节，各种围观群众纷纷45度仰望，在一些专业网站（如<a href=\"http://spaceweather.com/\">spaceweather</a>）也能找到观光指南。</p>","featureSwatch":{"Vibrant":{"color":"#2b6a7d","isDark":true,"contrast":6.152506571402196},"Muted":{"color":"#628d9b","isDark":true,"contrast":3.8818866665042275},"DarkVibrant":{"color":"#08536a","isDark":true,"contrast":13.30121420712154},"DarkMuted":{"color":"#4d7e8e","isDark":true,"contrast":4.693454244598322},"LightVibrant":{"color":"#74d4e4","isDark":false,"contrast":1.7100585291773622},"LightMuted":{"color":"#769ca9","isDark":false,"contrast":2.958324937392382}},"json":"data/posts/2011/06/06/noctilucent-cloud.json","tags":[{"name":"云","slug":"云","path":"tags/云/","permalink":"http://catx.me/tags/云/","postCount":1},{"name":"天文","slug":"天文","path":"tags/天文/","permalink":"http://catx.me/tags/天文/","postCount":1}],"categories":[{"name":"天文","slug":"天文","path":"categories/天文/","permalink":"http://catx.me/categories/天文/","postCount":1}]},"sha1":"448c3119fd08ed76bb614af7dd0e1c58e01aca7f","prev":{"title":"通过Git Pre-Commit Hook执行MSBuild和MSTest","content":"<p>Git的pre-commit hook会在commit之前执行，当脚本的返回值不为0的时候，终止commit过程，因此可以把编译、测试、lint等workflow放到这一hook中，减少引入到版本库中的bug。</p>\n<p>以下脚本用于调用MSBuild和MSTest对C#工程在commit前进行build和test。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh&#10; &#10;# Helper&#10;safeRunCommand() &#123;&#10;    typeset cmd=&#34;$*&#34;&#10;    typeset ret_code&#10; &#10;    echo cmd=$cmd&#10;    eval $cmd&#10;    ret_code=$?&#10;    if [ $ret_code != 0 ]; then&#10;        printf &#34;Error : [%d] when executing command: &#39;$cmd&#39;&#34; $ret_code&#10;        exit $ret_code&#10;    fi&#10;&#125;&#10; &#10;# Path To MSBuild.exe&#10;MSBuild=&#34;/c/Windows/Microsoft.NET/Framework/v4.0.30319/MSBuild.exe&#34;&#10;# Path To MSTest.exe&#10;MSTest=&#34;/d/Program\\ Files\\ \\(x86\\)/Microsoft\\ Visual\\ Studio\\ 11.0/Common7/IDE/MSTest.exe&#34;&#10;# Get Project root path (without tailing /)&#10;ProjectRoot=&#34;$(git rev-parse --show-toplevel)&#34;&#10; &#10;# Test Containers (without leading /)&#10;Tests=(&#10;    &#34;ConsoleSharp.Tests/bin/Debug/ConsoleSharp.Tests.dll&#34; &#10;    &#34;Mirror.Test/bin/Debug/Mirror.Test.dll&#34;&#10;)&#10; &#10; &#10;# Build&#10;safeRunCommand $MSBuild $ProjectRoot/ConsoleSharp.sln&#10; &#10;# Test&#10;Args=(&#34;$&#123;Tests[@]/#//testcontainer:$ProjectRoot/&#125;&#34;)&#10;safeRunCommand $MSTest $(eval &#39;echo &#34;$&#123;Args[*]&#125;&#34;&#39;)</span><br></pre></td></tr></table></figure>\n","date":"2014-01-15T13:06:56.000Z","path":"2014/01/15/run-msbuild-and-mstest-from-git-pre-commit-hook/","isDark":true,"featureColor":"#2b6a7d","featureImage":"/image/stock/3.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#2b6a7d","isDark":true,"contrast":6.152506571402196},"Muted":{"color":"#628d9b","isDark":true,"contrast":3.8818866665042275},"DarkVibrant":{"color":"#08536a","isDark":true,"contrast":13.30121420712154},"DarkMuted":{"color":"#4d7e8e","isDark":true,"contrast":4.693454244598322},"LightVibrant":{"color":"#74d4e4","isDark":false,"contrast":1.7100585291773622},"LightMuted":{"color":"#769ca9","isDark":false,"contrast":2.958324937392382}},"json":"data/posts/2014/01/15/run-msbuild-and-mstest-from-git-pre-commit-hook.json","tags":[{"name":"Shell","slug":"Shell","path":"tags/Shell/","permalink":"http://catx.me/tags/Shell/","postCount":1},{"name":"git","slug":"git","path":"tags/git/","permalink":"http://catx.me/tags/git/","postCount":2},{"name":"测试","slug":"测试","path":"tags/测试/","permalink":"http://catx.me/tags/测试/","postCount":2}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]},"next":{"title":"关于循环展开优化","content":"<p>这几天蛋疼，下手开始实现一个虚拟机，主要的参考书籍是Bill Blunden的&lt;Virtual Machine Design and Implementation in C/C++&gt;，书中实现了一个基本完整的HEC虚拟机。除了实践一下其中的知识以外，最主要的还是实际调查一下自己对原作者实现中不满意的地方，如果时间和精力足够，再添加没有实现的JIT以及配套的高级语言编译器。</p>\n<p>在Hec的实现中，有一个基本的功能，就是实现虚拟机字节码的endian与native code的endian之间的转换（如果相反），只是简单的颠倒字节顺序。主要在虚拟机加载字节码，开始执行之前调用，直接影响字节码加载到开始执行期间用户的等待时间。</p>\n<p>Blunden为了优化性能，在这部分应用了循环展开[<a href=\"http://en.wikipedia.org/wiki/Loop_unwinding\" title=\"Loop unwinding @ wikipedia\" target=\"_blank\" rel=\"external\">1</a>]技术。本文记录了在开发过程中采用的几种与Blunden不同的实现方法，以及初步的对比。</p>\n<a id=\"more\"></a>\n<p><strong>0. Blunden原始实现</strong></p>\n<p>原始实现提供了一系列单独的bytecodeToTypeName以及typeNameToBytecode全局函数：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">U2 <span class=\"title\">bytecodeToWord</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">U4 <span class=\"title\">bytecodeToDWord</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">U8 <span class=\"title\">bytecodeToQWord</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">F4 <span class=\"title\">bytecodeToFloat</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"><span class=\"function\">F8 <span class=\"title\">bytecodeToDouble</span><span class=\"params\">(U1 bytes[])</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">wordToBytecode</span><span class=\"params\">(U2 word, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dwordToBytecode</span><span class=\"params\">(U4 dword, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">qwordToBytecode</span><span class=\"params\">(U8 qword, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">floatToBytecode</span><span class=\"params\">(F4 flt, U1 arr[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doubleToBytecode</span><span class=\"params\">(F8 dbl, U1 arr[])</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>其中U代表unsigned，后面的数字代表位长，在win32平台下的定义为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S1\tsigned char</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S2\tsigned short</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S4\tsigned long</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> S8\tsigned __int64\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U1\tunsigned char</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U2\tunsigned short</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U4\tunsigned long</span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> U8\tunsigned __int64</span></span><br></pre></td></tr></table></figure>\n<p>以下仅列举U8版本的qwordToBytecode实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">qwordToBytecode</span><span class=\"params\">(U8 qword, U1 arr[])</span></span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">\tU1 *buffer;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbuffer = (U1*)&amp;amp;qword;</span><br><span class=\"line\">\tarr[<span class=\"number\">0</span>] = buffer[<span class=\"number\">7</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">1</span>] = buffer[<span class=\"number\">6</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">2</span>] = buffer[<span class=\"number\">5</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">3</span>] = buffer[<span class=\"number\">4</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">4</span>] = buffer[<span class=\"number\">3</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">5</span>] = buffer[<span class=\"number\">2</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">6</span>] = buffer[<span class=\"number\">1</span>];</span><br><span class=\"line\">\tarr[<span class=\"number\">7</span>] = buffer[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;<span class=\"comment\">/*end qwordToBytecode*/</span></span><br></pre></td></tr></table></figure>\n<p>可以看出Blunden的实现是C Style的，基本上就是一大堆全局函数与变量，缺乏封装性。各个类型的转换函数没有统一的调用接口，而且由于采用了循环展开，导致对每一个类型转换的函数体都非常冗长，整个代码就变成了一大堆重复代码的组合。</p>\n<p>当然这主要是出于性能的考虑，不过考虑到现在的C++编译器的性能已经不再是当年的情况，C++完全可以做到与C相同甚至更好的性能，同时提供更易于维护的代码。实际上，很多C语言写的程序最后也是用C++编译器编译的。</p>\n<p><strong>1.实现一：For Loop</strong></p>\n<p>在讨论优化之前，要有个被优化的对象作为对比，以下是用For循环在一个struct中实现同样的功能：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">typename</span> T&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ForLoopAssign</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &amp;lt; <span class=\"keyword\">sizeof</span>(T); i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tdest[i] = src[<span class=\"keyword\">sizeof</span>(T) - i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里只是最主要的交换赋值部分，采用了模板类，为的是同一个接口实现不同类型转换功能的调用，而不是若干个单独的函数。</p>\n<p>模板类在编译时就会被展开，因此在运行时的性能损耗很小。</p>\n<p>可以看到这段代码的优点是简短，易于维护，几行代码实现了几十行代码的功能。缺点当然是For-Loop造成的性能损耗。</p>\n<p>调用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ForLoopAssign&amp;lt;T&amp;gt;::AssignBytes(src, dest);</span><br></pre></td></tr></table></figure>\n<p><strong>2.实现二：手动循环展开</strong></p>\n<p>Prototype：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">int</span> byteLen&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>特化：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">1</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">2</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">4</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">2</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">3</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ExplicitUnrolling&amp;lt;<span class=\"number\">8</span>&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">AssignBytes</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">7</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">6</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">2</span>] = src[<span class=\"number\">5</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">3</span>] = src[<span class=\"number\">4</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">4</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">5</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">6</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tdest[<span class=\"number\">7</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其实就是对C Style实现的C++封装，性能接近原实现，调用只需要一句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExplicitUnrolling&amp;lt;<span class=\"keyword\">sizeof</span>(T)&amp;gt;::AssignBytes(src, dest);</span><br></pre></td></tr></table></figure>\n<p>显然，作为显示实现的代码，也是难于维护的。</p>\n<p><strong>3.实现3：模板元递归</strong></p>\n<p>递归模板：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">int</span> byteN, <span class=\"keyword\">int</span> byteLen&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> AssignByte</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Assign</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[byteN - <span class=\"number\">1</span>] = src[byteLen - byteN];</span><br><span class=\"line\">\t\tAssignByte&amp;lt;byteN - <span class=\"number\">1</span>, byteLen&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>递归边界：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &amp;lt;<span class=\"keyword\">int</span> byteLen&amp;gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> AssignByte&amp;lt;<span class=\"number\">1</span>, byteLen&amp;gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Assign</span><span class=\"params\">(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\tdest[<span class=\"number\">0</span>] = src[byteLen - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AssignByte&amp;lt;<span class=\"keyword\">sizeof</span>(T), <span class=\"keyword\">sizeof</span>(T)&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>\n<p>和For Loop实现相比，这段代码只长了几句，但是却实现了循环展开。</p>\n<p>以U4为例，调用的时候实际上是：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">4</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>\n<p>在Assign函数体中形成递归调用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dest[<span class=\"number\">4</span> - byteLen] = src[<span class=\"number\">4</span> - byteLen];</span><br><span class=\"line\"><span class=\"comment\">//递归调用</span></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">4</span> - <span class=\"number\">1</span>, byteLen&amp;gt;::Assign(src, dest);</span><br></pre></td></tr></table></figure>\n<p>直到传入的byteN == 1到达递归边界。</p>\n<p>但这个递归是在编译时进行的，实际上是编译器递归的生成了如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">4</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">3</span>] = src[<span class=\"number\">0</span>];</span><br><span class=\"line\">\tAssignByte&amp;lt;<span class=\"number\">3</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">3</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">2</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">\tAssignByte&amp;lt;<span class=\"number\">2</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">2</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">1</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">\tAssignByte&amp;lt;<span class=\"number\">1</span>, <span class=\"number\">4</span>&amp;gt;::Assign(src, dest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AssignByte&amp;lt;<span class=\"number\">1</span>, <span class=\"number\">4</span>&amp;gt;::Assign(<span class=\"keyword\">const</span> U1 src[], U1 dest[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tdest[<span class=\"number\">0</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以在运行时没有任何递归，只是一系列的函数调用，但更妙的是对于足够短的函数体，编译器会自动进行inline优化，省略函数调用，以上代码最后编译后等效于人肉实现的循环展开。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dest[<span class=\"number\">0</span>] = src[<span class=\"number\">3</span>];</span><br><span class=\"line\">dest[<span class=\"number\">1</span>] = src[<span class=\"number\">2</span>];</span><br><span class=\"line\">dest[<span class=\"number\">2</span>] = src[<span class=\"number\">1</span>];</span><br><span class=\"line\">dest[<span class=\"number\">3</span>] = src[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>这种方法最后做到了与For Loop相近长度的易于维护的代码，以及（理论上）与人肉循环展开一致的性能。</p>\n<p><strong>4.测试与结果分析</strong></p>\n<p>测试代码分别调用以上3种实现100000000、1000000000、10000000000次，记录执行时间。</p>\n<p>测试平台：Windows 7 Ultimate 32bit + Visual Studio 2010</p>\n<p>Release Build:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----------------------------------&#10;Test U2&#10;For-Loop x100000000: 207&#10;Template x100000000: 88&#10;Explicit x100000000: 119&#10;&#10;Test U4&#10;For-Loop x100000000: 183&#10;Template x100000000: 85&#10;Explicit x100000000: 93&#10;&#10;Test U8&#10;For-Loop x100000000: 182&#10;Template x100000000: 86&#10;Explicit x100000000: 86&#10;&#10;----------------------------------&#10;Test U2&#10;For-Loop x1000000000: 1768&#10;Template x1000000000: 878&#10;Explicit x1000000000: 1169&#10;&#10;Test U4&#10;For-Loop x1000000000: 1796&#10;Template x1000000000: 879&#10;Explicit x1000000000: 882&#10;&#10;Test U8&#10;For-Loop x1000000000: 1760&#10;Template x1000000000: 881&#10;Explicit x1000000000: 893&#10;&#10;----------------------------------&#10;Test U2&#10;For-Loop x10000000000: 13508&#10;Template x10000000000: 7648&#10;Explicit x10000000000: 13349&#10;&#10;Test U4&#10;For-Loop x10000000000: 12094&#10;Template x10000000000: 6005&#10;Explicit x10000000000: 6267&#10;&#10;Test U8&#10;For-Loop x10000000000: 12075&#10;Template x10000000000: 5914&#10;Explicit x10000000000: 6314</span><br></pre></td></tr></table></figure></p>\n<p>输出中For Loop为循环实现，Template为模板元递归实现，Explicit为人肉实现。</p>\n<p>可以看到，For loop不出意外的慢。</p>\n<p>在Release Build模式下，模板元递归的性能与人肉循环展开一致，甚至在位长等于2的类型中优于后者，这应该是编译器优化造成的（待考）。</p>\n<p>在Debug Build模式下出现了反常，模板元递归实现的执行时间意外的比人肉实现慢：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-------------------------------------------&#10;Test U2&#10;For-Loop x100000000: 5187&#10;Template x100000000: 9629&#10;Explicit x100000000: 3576&#10;&#10;Test U4&#10;For-Loop x100000000: 4821&#10;Template x100000000: 16005&#10;Explicit x100000000: 3533&#10;&#10;Test U8&#10;For-Loop x100000000: 7009&#10;Template x100000000: 28891&#10;Explicit x100000000: 4171&#10;&#10;-------------------------------------------</span><br></pre></td></tr></table></figure>\n<p>查看Disassemblely：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//static inline void Assign(const U1 src[], U1 dest[])&#10;//&#123;&#10;01156D30  push        ebp&#10;01156D31  mov         ebp,esp&#10;01156D33  sub         esp,0C0h&#10;01156D39  push        ebx&#10;01156D3A  push        esi&#10;01156D3B  push        edi&#10;01156D3C  lea         edi,[ebp-0C0h]&#10;01156D42  mov         ecx,30h&#10;01156D47  mov         eax,0CCCCCCCCh&#10;01156D4C  rep stos    dword ptr es:[edi]&#10;//&#9;dest[byteN - 1] = src[byteLen - byteN];&#10;01156D4E  mov         eax,dword ptr [dest]&#10;01156D51  mov         ecx,dword ptr [src]&#10;01156D54  mov         dl,byte ptr [ecx]&#10;01156D56  mov         byte ptr [eax+1],dl&#10;//&#9;AssignByte&#38;lt;byteN - 1, byteLen&#38;gt;::Assign(src, dest);&#10;01156D59  mov         eax,dword ptr [dest]&#10;01156D5C  push        eax&#10;01156D5D  mov         ecx,dword ptr [src]&#10;01156D60  push        ecx&#10;01156D61  call        AssignByte&#38;lt;1,2&#38;gt;::Assign (11511FEh)&#10;01156D66  add         esp,8&#10;//&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出造成反常的原因是编译器为了便于debug，并没有进行inline优化，依然是函数调用。</p>\n<p>另外Debug模式会插入许多额外代码方便调试器，因此造成了整体性能的下降。</p>\n<p><strong>5.小结</strong></p>\n<p>因为偷懒，本文并未比较C实现与C++实现之间的性能差异，虽然有理由相信实现一中结构体静态成员函数调用的成本与C全局函数调用成本不相上下，但仍然是不严密之处。</p>\n<p>仅就3种实现的对比而言，可以确定的是：</p>\n<p>a.循环展开优化是有效果的</p>\n<p>b.执行成本：函数调用&gt;循环&gt;展开后代码</p>\n<p>c.实际优化结果结果依赖于编译器以及编译模式</p>\n<p>&nbsp;</p>\n","date":"2011-09-15T01:00:52.000Z","path":"2011/09/15/loop-unrolling-cpp/","isDark":false,"featureColor":"#d19e40","featureImage":"/image/stock/5.jpg","excerpt":"<p>这几天蛋疼，下手开始实现一个虚拟机，主要的参考书籍是Bill Blunden的&lt;Virtual Machine Design and Implementation in C/C++&gt;，书中实现了一个基本完整的HEC虚拟机。除了实践一下其中的知识以外，最主要的还是实际调查一下自己对原作者实现中不满意的地方，如果时间和精力足够，再添加没有实现的JIT以及配套的高级语言编译器。</p>\n<p>在Hec的实现中，有一个基本的功能，就是实现虚拟机字节码的endian与native code的endian之间的转换（如果相反），只是简单的颠倒字节顺序。主要在虚拟机加载字节码，开始执行之前调用，直接影响字节码加载到开始执行期间用户的等待时间。</p>\n<p>Blunden为了优化性能，在这部分应用了循环展开[<a href=\"http://en.wikipedia.org/wiki/Loop_unwinding\" title=\"Loop unwinding @ wikipedia\">1</a>]技术。本文记录了在开发过程中采用的几种与Blunden不同的实现方法，以及初步的对比。</p>","featureSwatch":{"Vibrant":{"color":"#d19e40","isDark":false,"contrast":2.433412395275077},"Muted":{"color":"#798249","isDark":true,"contrast":4.168289617634703},"DarkVibrant":{"color":"#97623d","isDark":true,"contrast":7.586487507499872},"DarkMuted":{"color":"#5a4e32","isDark":true,"contrast":14.22073373466042},"LightVibrant":{"color":"#d6c395","isDark":false,"contrast":1.7356438765314866},"LightMuted":{"color":"#aea18e","isDark":false,"contrast":2.5336980009663206}},"json":"data/posts/2011/09/15/loop-unrolling-cpp.json","tags":[{"name":"C++","slug":"C","path":"tags/C/","permalink":"http://catx.me/tags/C/","postCount":2},{"name":"VM","slug":"VM","path":"tags/VM/","permalink":"http://catx.me/tags/VM/","postCount":1},{"name":"optimization","slug":"optimization","path":"tags/optimization/","permalink":"http://catx.me/tags/optimization/","postCount":1},{"name":"template","slug":"template","path":"tags/template/","permalink":"http://catx.me/tags/template/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]}}
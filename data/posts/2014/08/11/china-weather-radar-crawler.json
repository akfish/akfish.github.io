{"type":"post","json_base":"data/posts","json":"data/posts/2014/08/11/china-weather-radar-crawler.json","path":"2014/08/11/china-weather-radar-crawler/","data":{"title":"中国区气象雷达数据爬虫","content":"<p>作为一个数据控，爱好各种实时数据，比如中央气象台的<a href=\"http://www.nmc.gov.cn/publish/radar/stations-chongqing.htm\" target=\"_blank\" rel=\"external\">气象雷达</a>数据。最近在进行的一个HTML5项目，就是利用Canvas和WebGL，把外观土鳖的官方数据，变成洋气+实用的交互式地图。由于HTML5 Canvas CORS的限制，在没有服务器配合的情况下，无法跨域载入图片，然后<code>getImageData</code>，因此就做了一个爬虫。</p>\n<p>经过一番试验，发现国外的免费云服务只有GAE能够访问nmc.gov.cn，确定爬虫在GAE上安家了。大致计算了下数据量，全国167个雷达站，平均10分钟更新1帧，每帧是一幅约35KB的GIF图像，一天下来就至少800+M的数据，放GAE上不现实。同时前端也需要<code>.json</code>文件，描述雷达站信息以及数据帧列表，所以还需要数据库存储，而GAE坑爹的datastore quota，一天只能5w次读写，爬虫大概跑3圈就爆了。在这样一些约束下，最后脑洞大开的结合GitHub API，把数据全存到一个GitHub repository里，然后再把git tree拖回来当数据库用，解决问题。</p>\n<p>目前在GAE上部署了两个实例，分时运行，因为bandwidth quota大概只能支撑半天，然后每天删除repository重建一次，避免超过GitHub的quota。</p>\n<p>除了爬图片，地图叠加层的对其需要知道雷达站的坐标，以及数据的范围（即图片上的“数据范围：xxx km”），前者通过之前人肉爬到的一个包含全国雷达站坐标的xml文件解决问题。<br>至于数据范围没有找到官方的数据，最后写了一个简单的OCR算法直接从图片上识别。</p>\n<h2 id=\"u9644_u8BB0_uFF1A_u7528GitHub_API_u521B_u5EFAcommit_u6D41_u7A0B\"><a href=\"#u9644_u8BB0_uFF1A_u7528GitHub_API_u521B_u5EFAcommit_u6D41_u7A0B\" class=\"headerlink\" title=\"附记：用GitHub API创建commit流程\"></a>附记：用GitHub API创建commit流程</h2><p>GitHub提供了<a href=\"https://developer.github.com/v3/repos/contents/\" target=\"_blank\" rel=\"external\">Content API</a>，可以方便的对单个文件进行CRUD操作，每次操作产生1个commit。<br>如果需要一次commit多个文件（比如这个爬虫每次cron会新增数百文件），这样显然不实际。<br>更好的做法是通过<a href=\"https://developer.github.com/v3/git/\" target=\"_blank\" rel=\"external\">Git Data API</a>，模拟git创建一次commit的过程。<br>之前做git私有传输协议的经验立即发挥作，轻车熟路的解决，流程如下：</p>\n<ol>\n<li>用<a href=\"https://developer.github.com/v3/git/blobs/\" target=\"_blank\" rel=\"external\">Blob API</a>为每个文件创建一个blob</li>\n<li>用<a href=\"https://developer.github.com/v3/git/trees/\" target=\"_blank\" rel=\"external\">Tree API</a>为每个子文件夹创建一个tree，并添加其中文件对应的blob</li>\n<li>用<a href=\"https://developer.github.com/v3/git/commits/\" target=\"_blank\" rel=\"external\">Commit API</a>读出要commit分支最新的commit，以及commit对应的tree</li>\n<li>创建root tree，未改变的文件/文件夹需要原封不动的在tree里面保留，插入/替换新增的blob/tree</li>\n<li>创建commit，tree指向新的root tree，parent指向分支最新commit</li>\n<li>用<a href=\"https://developer.github.com/v3/git/refs/\" target=\"_blank\" rel=\"external\">Reference API</a>更新分支的ref，指向新创建的commit</li>\n</ol>\n<p>如果操作中断或重复操作，blob/tree都不会导致多余的数据产生（纯浪费上传带宽而已）。<br>因为git用SHA1 Digest作为所有git object的文件名，同内容的blob/tree不会重复。<br>需要注意一个例外，commit由于包含了时间戳，会重复创建。</p>\n<p>当然最好封装好的library，会省不少事。<br>比如我在这个项目里用到的python library是<a href=\"https://github.com/jacquev6/PyGithub\" target=\"_blank\" rel=\"external\">PyGitHub</a>，几个月前给这个项目发过pull request增加了些功能，比较熟悉用起来顺手。</p>\n<h2 id=\"u94FE_u63A5\"><a href=\"#u94FE_u63A5\" class=\"headerlink\" title=\"链接\"></a>链接</h2><ul>\n<li>源码: <a href=\"https://github.com/catx-weather/radar-bot\" target=\"_blank\" rel=\"external\">radar-bot</a></li>\n<li>爬到的数据：<a href=\"https://github.com/catx-weather/data\" target=\"_blank\" rel=\"external\">data</a></li>\n<li>OCR工具：<a href=\"https://github.com/catx-weather/frame-range-ocr\" target=\"_blank\" rel=\"external\">Frame Range OCR</a></li>\n</ul>\n","date":"2014-08-10T16:14:12.000Z","path":"2014/08/11/china-weather-radar-crawler/","isDark":false,"featureColor":"#caa084","featureImage":"/images/tornado.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#caa084","isDark":false,"contrast":2.3667779450941966},"Muted":{"color":"#785541","isDark":true,"contrast":9.562217921145681},"DarkVibrant":{"color":"#9c5c3d","isDark":true,"contrast":7.395012998220232},"DarkMuted":{"color":"#4b3a32","isDark":true,"contrast":15.322594218985449},"LightVibrant":{"color":"#d8bba5","isDark":false,"contrast":1.814844701319505},"LightMuted":{"color":"#dcd9d6","isDark":false,"contrast":1.4056903887271448}},"json":"data/posts/2014/08/11/china-weather-radar-crawler.json","tags":[{"name":"Crawler","slug":"Crawler","path":"tags/Crawler/","permalink":"http://catx.me/tags/Crawler/","postCount":1},{"name":"Fun","slug":"Fun","path":"tags/Fun/","permalink":"http://catx.me/tags/Fun/","postCount":2},{"name":"GAE","slug":"GAE","path":"tags/GAE/","permalink":"http://catx.me/tags/GAE/","postCount":1},{"name":"GitHub","slug":"GitHub","path":"tags/GitHub/","permalink":"http://catx.me/tags/GitHub/","postCount":6},{"name":"Python","slug":"Python","path":"tags/Python/","permalink":"http://catx.me/tags/Python/","postCount":1},{"name":"Weather","slug":"Weather","path":"tags/Weather/","permalink":"http://catx.me/tags/Weather/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":17}]},"sha1":"782006404a88139474fb39bb6d391bdc181e5ead","prev":{"title":"用C# ILGenerator在运行时动态生成proxy","content":"<h2 id=\"u95EE_u9898_u63CF_u8FF0\"><a href=\"#u95EE_u9898_u63CF_u8FF0\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>C#中经常会遇到通过单一入口动态调用对象或服务的情况，形如：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title\">ProxyBase</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">object</span> <span class=\"title\">Invoke</span>(<span class=\"params\"><span class=\"keyword\">object</span> someMethodRelatedInfo, <span class=\"keyword\">object</span>[] arguments</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比如Reflection，远程服务，Host动态脚本引擎时从C#调用引擎context内的方法等等情况都可以归类于这样的模型。</p>\n<p>一种较好的工程实现就是把这些服务方法用接口定义，获得强类型的校验，避免出现不必要的bug，并便于维护。如：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IFooService</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MethodWithNoReturn</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MethodTakeParameterAndReturn</span>(<span class=\"params\"><span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于不同的后端，需要有具体的调用实现：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">FooProxyBase</span> : <span class=\"title\">ProxyBase</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">override</span> <span class=\"keyword\">object</span> <span class=\"title\">Invoke</span>(<span class=\"params\"><span class=\"keyword\">object</span> someMethodRelatedInfo, <span class=\"keyword\">object</span>[] arguments</span>)</span><br><span class=\"line\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Pack to JSON and send via http</span></span><br><span class=\"line\">    <span class=\"comment\">// Or adapte and call other classes</span></span><br><span class=\"line\">    <span class=\"comment\">// Or whatever</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终的Proxy类通过继承调用实现类，同时实现服务约定接口实现：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FooService : FooProxyBase, IFooService</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  #region Implement IFooService</span><br><span class=\"line\">  public void MethodWithNoReturn() </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    Invoke(\"MethodWithNoReturn\", new object[0]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public int MethodTakeParameterAndReturn(int a, int b)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    return Invoke(\"MethodTakeParameterAndReturn\", new object[] &#123; a, b &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  #endregion</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样一来有一个显然的问题，Proxy类包含大量重复的代码，方法越多实现起来越费劲。这个问题的point of interest就在于Proxy类的动态生成，实现以后只需要一行代码就能替代人肉实现一个巨大的Proxy类：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IFooService proxy = ProxyEmitter.CreateProxy&amp;lt;FooProxyBase, IFooService&amp;gt;(<span class=\"comment\">/*Constructor parameters are supported*/</span>);</span><br></pre></td></tr></table></figure>\n<p>要动态生成Proxy类有很多种方法（如生成源代码然后编译），这里采用在运行时通过Reflection获取服务接口的方法，动态生成Proxy类，最后用ILGenerator.Emit用.Net IL实现代码逻辑。</p>\n<h2 id=\"u5B9E_u73B0_u8981_u70B9\"><a href=\"#u5B9E_u73B0_u8981_u70B9\" class=\"headerlink\" title=\"实现要点\"></a>实现要点</h2><p>如何动态创建Assembly, Module, Type的框架性代码MSDN有详尽的walkthrough，不在本文讨论重点，具体实现可参考源代码。</p>\n<p>这一节记录在实现这个项目中几处逻辑的IL代码生成，有几点是必须要知道的：</p>\n<ul>\n<li>.Net CLR是基于栈的虚拟机</li>\n<li>.Net CLR（在生成C#类时）是强类型的</li>\n<li>参数顺序入栈</li>\n<li>非static method的第一个参数总是this指针</li>\n</ul>\n<p>1. 有参数的constructor</p>\n<p>在C#中很多涉及自动生成的情况（如serialization）都要求无参数的constructor，在有的情况下很让人忧桑，其实要支持有参数的constructor也是可行的。</p>\n<p>如果父类只有一个有参数的constructor，子类的constructor实现必须用足够的参数构造：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span>: <span class=\"title\">Base</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Derived</span>(<span class=\"params\"><span class=\"keyword\">int</span> may, <span class=\"keyword\">string</span> para, <span class=\"keyword\">object</span>[] meters</span>): <span class=\"title\">base</span>(<span class=\"params\">may, para, meters</span>) </span>&#123;&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用IL实现上述代码，需要将参数重新压栈，然后call base的ctor指针：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">EmitCtor</span>(<span class=\"params\">TypeBuilder tBuilder, ConstructorInfo ctor</span>)</span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pTypes = ctor.GetParameters().Select(p =&amp;gt; p.ParameterType).ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> builder = Emitter.GetConstructor(</span><br><span class=\"line\">        tBuilder,</span><br><span class=\"line\">        MethodAttributes.Public |</span><br><span class=\"line\">        MethodAttributes.HideBySig |</span><br><span class=\"line\">        MethodAttributes.SpecialName |</span><br><span class=\"line\">        MethodAttributes.RTSpecialName,</span><br><span class=\"line\">        pTypes</span><br><span class=\"line\">        );</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ilGen = builder.GetILGenerator();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// No locals</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Load all args, note arg 0 is this pointer, so must emit one more</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &amp;lt;= pTypes.Length; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        DoEmit(ilGen, OpCodes.Ldarg_S, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Call base ctor</span></span><br><span class=\"line\">    DoEmit(ilGen, OpCodes.Call, ctor);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Return</span></span><br><span class=\"line\">    DoEmit(ilGen, OpCodes.Ret);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生成的IL形如：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IL_0000: ldarg.0</span><br><span class=\"line\">IL_0001: ldarg.1</span><br><span class=\"line\">IL_0002: ldarg.2</span><br><span class=\"line\">IL_0003: ldarg.3</span><br><span class=\"line\">IL_0004: call instance void Base::.ctor(int32, string, object)</span><br><span class=\"line\">IL_0009: ret</span><br></pre></td></tr></table></figure>\n<p>2. Array的初始化<br>由于Invoke的长相，决定了这个生成器中需要大量的生成object[]对象，并把参数装进去。<br>创建一个local variable，首先需要declare：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ilGen.DeclareLocal(<span class=\"keyword\">typeof</span>(<span class=\"keyword\">object</span>[]))</span><br></pre></td></tr></table></figure>\n<p>每个method的运行环境里维护了一个local列表，IL代码通过index把local入栈和出栈。<br>创建Array对象，并设置到local：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize array</span></span><br><span class=\"line\"><span class=\"comment\">// IL_0006:  ldc.i4.x</span></span><br><span class=\"line\">DoEmit(ilGen, OpCodes.Ldc_I4_S, pTypes.Length);</span><br><span class=\"line\"><span class=\"comment\">// IL_0007:  newarr     [mscorlib]System.Object</span></span><br><span class=\"line\">DoEmit(ilGen, OpCodes.Newarr, <span class=\"keyword\">typeof</span>(Object));</span><br><span class=\"line\"><span class=\"comment\">// IL_000c:  stloc.1</span></span><br><span class=\"line\">DoEmit(ilGen, OpCodes.Stloc_0);</span><br><span class=\"line\">``` </span><br><span class=\"line\">对Array元素的逐条赋值由<span class=\"number\">4</span>~<span class=\"number\">5</span>条机器指令完成：</span><br><span class=\"line\"></span><br><span class=\"line\">*   ldloc.?将array入栈</span><br><span class=\"line\">*   ldc_i4_?将当前元素的index入栈</span><br><span class=\"line\">*   将需要赋给元素的值入栈（本例中为参数用ldarg_s，注意参数<span class=\"number\">0</span>为<span class=\"keyword\">this</span>指针）</span><br><span class=\"line\">*   如果是<span class=\"keyword\">value</span> type需要box</span><br><span class=\"line\">*   stelem.<span class=\"keyword\">ref</span>指令完成赋值</span><br><span class=\"line\"></span><br><span class=\"line\">```cs</span><br><span class=\"line\"><span class=\"comment\">// Now fill the array</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &amp;lt; pTypes.Length; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Load the array first</span></span><br><span class=\"line\">    <span class=\"comment\">// IL_000X + 00: ldloc.0</span></span><br><span class=\"line\">    DoEmit(ilGen, OpCodes.Ldloc_0);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Push the index</span></span><br><span class=\"line\">    <span class=\"comment\">// IL_000X + 01: ldc_i4_x</span></span><br><span class=\"line\">    DoEmit(ilGen, OpCodes.Ldc_I4_S, i);</span><br><span class=\"line\">    <span class=\"comment\">// Load argument i + 1 (note that argument 0 is this pointer(?))</span></span><br><span class=\"line\">    <span class=\"comment\">// IL_000X + 02: ldarg_X</span></span><br><span class=\"line\">    DoEmit(ilGen, OpCodes.Ldarg_S, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Box value type</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pTypes[i].IsValueType)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// IL_000X + 03: box pTypes[i]</span></span><br><span class=\"line\">        DoEmit(ilGen, OpCodes.Box, pTypes[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Set arrary element</span></span><br><span class=\"line\">    <span class=\"comment\">// IL_00X + ??: stelem.ref</span></span><br><span class=\"line\">    DoEmit(ilGen, OpCodes.Stelem_Ref);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"u6E90_u4EE3_u7801_u53CA_u4F7F_u7528_u65B9_u6CD5\"><a href=\"#u6E90_u4EE3_u7801_u53CA_u4F7F_u7528_u65B9_u6CD5\" class=\"headerlink\" title=\"源代码及使用方法\"></a>源代码及使用方法</h2><p>见<a href=\"https://github.com/akfish/ProxyEmitter\" target=\"_blank\" rel=\"external\">GitHub</a>。</p>\n","date":"2014-02-28T18:50:56.000Z","path":"2014/03/01/generate-dynamic-proxy-class-at-runtime-with-ilgenerator-c-sharp/","isDark":false,"featureColor":"#a99a48","featureImage":"/image/stock/7.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#a99a48","isDark":false,"contrast":2.8607233160176517},"Muted":{"color":"#b7ac6a","isDark":false,"contrast":2.3019786002998246},"DarkVibrant":{"color":"#8a7133","isDark":true,"contrast":4.70318580028283},"DarkMuted":{"color":"#534c37","isDark":true,"contrast":14.371837375676147},"LightVibrant":{"color":"#e4dcc3","isDark":false,"contrast":1.3703902496024831},"LightMuted":{"color":"#aba790","isDark":false,"contrast":2.4244396488445554}},"json":"data/posts/2014/03/01/generate-dynamic-proxy-class-at-runtime-with-ilgenerator-c-sharp.json","tags":[{"name":".Net","slug":"Net","path":"tags/Net/","permalink":"http://catx.me/tags/Net/","postCount":4},{"name":"compiler","slug":"compiler","path":"tags/compiler/","permalink":"http://catx.me/tags/compiler/","postCount":4}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":17}]},"next":{"title":"编译并使用虚拟HID驱动","content":"<h2 id=\"u80CC_u666F\"><a href=\"#u80CC_u666F\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>虚拟HID驱动用于虚拟一个或多个人机交互设备，如键盘、鼠标、摇杆等，作用都懂的。<br>经过搜索发现一个开源项目<a href=\"https://code.google.com/p/vmulti/\" target=\"_blank\" rel=\"external\">vmulti</a>，实现了虚拟的多点触控、鼠标、键盘、摇杆以及数位笔，省去了自己写驱动的麻烦。</p>\n<h2 id=\"u7F16_u8BD1vmulti\"><a href=\"#u7F16_u8BD1vmulti\" class=\"headerlink\" title=\"编译vmulti\"></a>编译vmulti</h2><ol>\n<li>安装WDK</li>\n<li>运行以管理员权限WDK build environment</li>\n<li>进入vmulti工程文件夹，运行</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build -wgc</span><br></pre></td></tr></table></figure>\n<ol>\n<li>把编译生成的<code>vmulti.sys</code>、<code>multi.inf</code>、<code>hidkmdf.sys</code>文件放到同一个文件夹</li>\n<li>把WDK中的<code>WdfCoInstaller01009.dll</code>, <code>devcon.exe</code>也放到这个文件夹</li>\n</ol>\n<h2 id=\"u9A71_u52A8_u7B7E_u540D\"><a href=\"#u9A71_u52A8_u7B7E_u540D\" class=\"headerlink\" title=\"驱动签名\"></a>驱动签名</h2><p>Windows x64系统上无法安装无签名的驱动，需要进行self sign。所有操作需要在管理员权限的WDK build environment中执行。</p>\n<h3 id=\"u6253_u5F00Windows_u6D4B_u8BD5_u6A21_u5F0F\"><a href=\"#u6253_u5F00Windows_u6D4B_u8BD5_u6A21_u5F0F\" class=\"headerlink\" title=\"打开Windows测试模式\"></a>打开Windows测试模式</h3><p>要加载self sign的内核代码，需要打开windows的测试模式：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bcdedit /set testsigning on</span><br></pre></td></tr></table></figure>\n<p>重启。</p>\n<h3 id=\"u521B_u5EFA_u8BC1_u4E66\"><a href=\"#u521B_u5EFA_u8BC1_u4E66\" class=\"headerlink\" title=\"创建证书\"></a>创建证书</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">makecert -r -pe -ss &#34;CatX&#34; -n &#34;CN=CatX Test Certificate&#34; catx.cer&#10;certmgr -add catx.cer /s /r localMachine root&#10;certmgr -add catx.cer /s /r localMachine trustedpublisher</span><br></pre></td></tr></table></figure>\n<p>验证证书是否正确安装，运行：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">certmgr</span><br></pre></td></tr></table></figure>\n<h3 id=\"u7B7E_u540D\"><a href=\"#u7B7E_u540D\" class=\"headerlink\" title=\"签名\"></a>签名</h3><p>驱动中的如下文件需要签名：</p>\n<ul>\n<li><code>*.sys</code>文件</li>\n<li><code>*.inf</code>中引用的<code>*.cat</code>文件</li>\n</ul>\n<p>如果<code>*.cat</code>文件不存在，需要运行inf2cat创建：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inf2cat /driver:%driver_folder% /os:7_x64</span><br></pre></td></tr></table></figure>\n<p>vmulti需要签名的文件有vmulti.sys、hidkmdf.sys和kmdfsamples.cat，运行：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">signtool sign /v /s &#34;CatX&#34; /n &#34;CatX Test Certificate&#34; /t http://timestamp.verisign.com/scripts/timestamp.dll %file_name%</span><br></pre></td></tr></table></figure>\n<p>验证签名：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">signtool verify /pa /v *.cat *.sys</span><br></pre></td></tr></table></figure>\n<h2 id=\"u5B89_u88C5vmulti\"><a href=\"#u5B89_u88C5vmulti\" class=\"headerlink\" title=\"安装vmulti\"></a>安装vmulti</h2><p>运行：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devcon install vmulti.inf djpnewton\\vmulti</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"u6D4B_u8BD5\"><a href=\"#u6D4B_u8BD5\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>vmulti工程中包含了一个测试程序<code>testvmulti.exe</code>，用于测试驱动功能：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">testvmulti.exe /multitouch&#10;testvmulti.exe /mouse&#10;testvmulti.exe /digitizer</span><br></pre></td></tr></table></figure></p>\n","date":"2014-03-11T02:24:16.000Z","path":"2014/03/11/build-and-use-virtual-hid-driver/","isDark":true,"featureColor":"#4e83a9","featureImage":"/images/cat-keyboard.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#4e83a9","isDark":true,"contrast":4.268205103945441},"Muted":{"color":"#66696d","isDark":true,"contrast":5.517007170923729},"DarkVibrant":{"color":"#5e4a2c","isDark":true,"contrast":14.365033884791707},"DarkMuted":{"color":"#484a69","isDark":true,"contrast":12.97746844631535},"LightVibrant":{"color":"#55bada","isDark":false,"contrast":2.2961725637158628},"LightMuted":{"color":"#e5e9da","isDark":false,"contrast":1.2353261496178072}},"json":"data/posts/2014/03/11/build-and-use-virtual-hid-driver.json","tags":[{"name":"HID","slug":"HID","path":"tags/HID/","permalink":"http://catx.me/tags/HID/","postCount":1},{"name":"驱动","slug":"驱动","path":"tags/驱动/","permalink":"http://catx.me/tags/驱动/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":17}]}}
{"type":"post","json_base":"data/posts","json":"data/posts/2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280.json","path":"2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280/","data":{"title":"JavaScript随机数生成算法中为什么要用9301, 49297, 233280作为Magic Number","content":"<p>今天在知乎上回答了这样一个问题：<a href=\"http://www.zhihu.com/question/22818104\" target=\"_blank\" rel=\"external\">网上常能见到的一段JS随机数生成算法如下，为什么用9301, 49297, 233280这三个数字做基数？</a></p>\n<p>问题中提到的代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rnd</span>(<span class=\"params\"> seed </span>)</span>&#123;</span><br><span class=\"line\">    seed = ( seed * <span class=\"number\">9301</span> + <span class=\"number\">49297</span> ) % <span class=\"number\">233280</span>; <span class=\"comment\">//Magic!</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> seed / ( <span class=\"number\">233280.0</span> );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rand</span>(<span class=\"params\">number</span>)</span>&#123;</span><br><span class=\"line\">    today = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); </span><br><span class=\"line\">    seed = today.getTime();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.ceil( rnd( seed ) * number );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myNum=(rand(<span class=\"number\">5</span>));</span><br></pre></td></tr></table></figure></p>\n<p>经过一系列的digging，最终找到了这个问题的答案，这三个数的选择是有数学依据的。</p>\n<p><strong>入门级的选择标准</strong><br>这种随机数生成器叫做线性同余生成器（LCG, Linear Congruential Generator)，几乎所有的运行库提供的rand都是采用的LCG，形如：<br><span>$I_{n+1}=aI_n + c\\ (mod\\ m)$</span><!-- Has MathJax --><br>生成的随机数序列最大周期m，生成0到m-1之间的随机数。要达到这个最大周期，必须满足</p>\n<ul>\n<li>c与m互质</li>\n<li>a - 1可以被m的所有质因数整除</li>\n<li>如果m是4的倍数，a - 1也必须是4的倍数<br>以上三条被称为Hull-Dobell定理。<br>作为一个随机数生成器，周期不够大是不好意思混的，所以这是要求之一。<br>可以看到，a=9301, c = 49297, m = 233280这组参数，以上三条全部满足。</li>\n</ul>\n<p><strong>进阶级的选择标准</strong><br>要在随机数生成器界混，仅仅入门是不够的。<br>从工程的角度来讲，$(m - 1)a + c$的值要（在合理的范围内）足够小，以避免溢出的问题。<br>从安全（实用）性的角度来讲，还要满足良好的随机性，这一点可以通过Knunth’s Spectral Test来评估（见[2]），要通过2,3,4,5以及6维的Spectral Test才行。Spectral Test考察的就是生成的随机数序列在超空间的网格结构（lattice structure），当年IBM的RANDU子程序闹出的乌龙，连3维的Spectral Test就不能通过，上图嘲讽下：</p>\n<p><a href=\"http://catx.me/wordpress/wp-content/uploads/2014/02/800px-Randu.png\"><img src=\"/images/bb1858cc61e6b2f8335f68221d141e0f5b289d68.png\" alt=\"800px-Randu\"></a></p>\n<p>其中每个点代表三个连续的RANDU生成的随机数值，可以看到所有随机数分布在了15个二维平面上。</p>\n<p>在这种要求面前，c的值最好：</p>\n<ul>\n<li>是质数 （c = 49297就是质数）</li>\n<li>接近<span>$(\\frac{1}{2}-\\frac{1}{6}\\sqrt{3})m$</span><!-- Has MathJax -->,(m = 233280时为49297.86460172205)<br>所以有了这样一些基本的标准，能够选择的参数范围就小了很多，弄个程序跑下Spectral Test，就能得到可选的参数组：</li>\n</ul>\n<p><a href=\"http://catx.me/wordpress/wp-content/uploads/2014/02/Unnamed-QQ-Screenshot20140222141315.png\"><img src=\"/images/5733d329521f86f7a2d59b5dc895f027ca119a83.png\" alt=\"Magic Number for LCG Random Generator\"></a></p>\n<p>参考资料：<a href=\"http://nuclear.fis.ucm.es/COMP-PHYS/RANDOM/RandomNumbers.pdf\" target=\"_blank\" rel=\"external\">[1]</a><a href=\"http://random.mat.sbg.ac.at/tests/theory/spectral/\" target=\"_blank\" rel=\"external\">[2]</a></p>\n","date":"2014-02-22T07:01:45.000Z","path":"2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280/","isDark":false,"featureColor":"#d19e40","featureImage":"/image/stock/5.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#d19e40","isDark":false,"contrast":2.433412395275077},"Muted":{"color":"#798249","isDark":true,"contrast":4.168289617634703},"DarkVibrant":{"color":"#97623d","isDark":true,"contrast":7.586487507499872},"DarkMuted":{"color":"#5a4e32","isDark":true,"contrast":14.22073373466042},"LightVibrant":{"color":"#d6c395","isDark":false,"contrast":1.7356438765314866},"LightMuted":{"color":"#aea18e","isDark":false,"contrast":2.5336980009663206}},"permalink":"http://catx.me/2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280/","json":"data/posts/2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280.json","tags":[{"name":"Algorithm","slug":"Algorithm","path":"tags/Algorithm/","permalink":"http://catx.me/tags/Algorithm/","postCount":2},{"name":"Magic Number","slug":"Magic-Number","path":"tags/Magic-Number/","permalink":"http://catx.me/tags/Magic-Number/","postCount":1},{"name":"Math","slug":"Math","path":"tags/Math/","permalink":"http://catx.me/tags/Math/","postCount":1},{"name":"Random","slug":"Random","path":"tags/Random/","permalink":"http://catx.me/tags/Random/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":17}]},"sha1":"4594b540043468ede1c7925a4006ccf0bbbaffce","next":{"title":"The Making Of Sarcasm (2) - AST, Generators and Fun with Visualization","content":"<p>In <a href=\"http://catx.me/2014/02/25/the-making-of-sarcasm-1/\">part 1</a> we discussed the design goals of Sarcasm and devised a grammar specification that covers most of Irony’s features.</p>\n<p>Continuing from <a href=\"https://github.com/akfish/Sarcasm/commit/15c9e6e1ef69bd1150d51af558e3a897e09accb8\" target=\"_blank\" rel=\"external\">commit 15c9e6</a>, in which I implemented the <a href=\"https://github.com/akfish/Sarcasm/blob/15c9e6e1ef69bd1150d51af558e3a897e09accb8/Sarcasm/Parser/SarcasmGrammar.cs\" target=\"_blank\" rel=\"external\">grammar specs</a> by hand with Irony, we will discuss the following topics:</p>\n<ul>\n<li>Construction of abstract syntax tree</li>\n<li>Generator workflow</li>\n<li>MarkDown generator</li>\n<li>Having some fun with visualization</li>\n</ul>\n<h2 id=\"AST_Overview\"><a href=\"#AST_Overview\" class=\"headerlink\" title=\"AST Overview\"></a>AST Overview</h2><p>After <a href=\"https://github.com/akfish/Sarcasm/blob/develop/Sarcasm/Parser/SarcasmGrammar.cs\" target=\"_blank\" rel=\"external\">grammar class</a> is implemented, the first thing you are going to do is to create a parser instance:</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> language = <span class=\"keyword\">new</span> LanguageData(<span class=\"keyword\">new</span> SarcasmGrammar());</span><br><span class=\"line\"><span class=\"keyword\">var</span> parser = <span class=\"keyword\">new</span> Irony.Parsing.Parser(_language);</span><br></pre></td></tr></table></figure>\n<p>With the Parser instance, we can parse source code by simply:</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parseTree = parser.Parse(sourceCode);</span><br><span class=\"line\"><span class=\"keyword\">var</span> parseRoot = parseTree.Root;</span><br><span class=\"line\"><span class=\"keyword\">var</span> astRoot = ParseRoot.AstNode;</span><br></pre></td></tr></table></figure>\n<p>If something is wrong with the grammar or source code, parseRoot and astRoot will be null. For now I will not go into error handling.</p>\n<p>Two kinds of trees are generated when Irony parses the source code: parsing tree and optional abstract syntax tree. To create an AST, you must do the following:</p>\n<p>1. Set language flag in grammar class’s constructor</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LanguageFlags |= LanguageFlags.CreateAst;</span><br></pre></td></tr></table></figure>\n<p>2. Create a bunch of AST node class deriving from Irony.Interpreter.Ast (also remember to add reference to assembly Irony.Interpreter.dll).</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Make your own base class will make life eaiser</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title\">SarcasmNode</span> : <span class=\"title\">AstNode</span> &#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">// For other nodes</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Document</span> : <span class=\"title\">SarcasmNode</span> &#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">IdNode</span> : <span class=\"title\">SarcasmNode</span> &#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">/*...*/</span></span><br></pre></td></tr></table></figure>\n<p>3. Assign AST node class to each Terminal/NonTerminal instances.</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// For terminals</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ID = <span class=\"keyword\">new</span> IdentifierTerminal(<span class=\"string\">\"ID\"</span>);</span><br><span class=\"line\">ID.AstConfig.NodeType = <span class=\"keyword\">typeof</span> (IdNode);</span><br><span class=\"line\"><span class=\"comment\">// For non-terminals</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Directive = <span class=\"keyword\">new</span> NonTerminal(<span class=\"string\">\"Directive\"</span>, <span class=\"keyword\">typeof</span>(DirectiveNode));</span><br></pre></td></tr></table></figure>\n<p>4. Override AST node’s Init method to handle initialization.</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// In AST node class</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> AstNode ChildNode;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Init</span>(<span class=\"params\">AstContext context, ParseTreeNode treeNode</span>)</span><br><span class=\"line\">        </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// Keep this</span></span><br><span class=\"line\">            <span class=\"keyword\">base</span>.Init(context, treeNode);</span><br><span class=\"line\">            <span class=\"comment\">// treeNode is the corresponding node in parse tree, contains information like:</span></span><br><span class=\"line\">            <span class=\"comment\">// Token</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> token = treeNode.Token;</span><br><span class=\"line\">            <span class=\"comment\">// Term</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> term = treeNode.Term;</span><br><span class=\"line\">            <span class=\"comment\">// Child nodes</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> nodes = treeNode.GetMappedChildNodes();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Set AsString to a human readable format. It will be used to display AST in Irony.GrammarExplorer</span></span><br><span class=\"line\">            AsString = <span class=\"string\">\"Id: \"</span> + token.Text;</span><br><span class=\"line\">            <span class=\"comment\">// Use AddChild to build tree structure, it returns an AstNode instance of child's AST node </span></span><br><span class=\"line\">            ChildNode = AddChild(<span class=\"keyword\">string</span>.Empty, nodes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>That’s almost all you need to know about how to construct an AST. However, if you mess it up, things can get ugly since the debug information is extremely not helpful. The most common exception on can get is:</p>\n<blockquote>\n<p>System.NullReferenceException: Object reference not set to an instance of an object.<br>at Irony.Ast.AstBuilder.BuildAst(ParseTreeNode parseNode) in f:\\Dev\\Tool\\Irony_2013_12_12\\Irony\\Ast\\AstBuilder.cs:line 97<br>This will not help you at all. But I will tell you that this always has to do with forgetting to set AST node type to one of your Terminals/Non-Terminals.</p>\n</blockquote>\n<p>Here are some tips I learned in the hard way (the only way mostly, since Irony’s documentation is poor):</p>\n<ul>\n<li>Assign AST node type to all Terminals/NonTerminals, including any intermediate/temporary ones.</li>\n<li>Except the ones marked as transient. They will not be created at all.</li>\n<li>CommentTerminals will NOT be mapped to AST at all. You will get the above error regardless the AST node type is set or not.</li>\n</ul>\n<h2 id=\"Generator_Workflow\"><a href=\"#Generator_Workflow\" class=\"headerlink\" title=\"Generator Workflow\"></a>Generator Workflow</h2><p>AST marks the watershed between compiler’s front end and back end. Although there’re still some work (e.g. type validation and  semantic analysis) left to be done, we can already generate something with this AST now. The most commonly used method here is the <a href=\"http://en.wikipedia.org/wiki/Visitor_pattern\" target=\"_blank\" rel=\"external\">visitor pattern</a>:</p>\n<p>1. Declare a interface for Visitor, one overload for each AST node</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">ISarcasmVisitor</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Visit</span>(<span class=\"params\">IdNode node</span>)</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Visit</span>(<span class=\"params\">Document node</span>)</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Visit</span>(<span class=\"params\">StringValueNode node</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// others</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2. Add virtual/abstract method to AST base class and implement in all derived class</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title\">SarcasmNode</span> : <span class=\"title\">AstNode</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">Accept</span>(<span class=\"params\">ISarcasmVisitor visitor</span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Document</span> : <span class=\"title\">SarcasmNode</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Accept</span>(<span class=\"params\">ISarcasmVisitor visitor</span>)</span><br><span class=\"line\">    </span>&#123;</span><br><span class=\"line\">        visitor.Visit(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3. Then we can create a generator by implement specific ISarcasmVisitor for different workflow, not only for target code generation but also outlining, semantic analysis.</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title\">TargetGenerator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> SarcasmParser Parser &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">TargetGenerator</span>(<span class=\"params\">SarcasmParser parser</span>)</span><br><span class=\"line\">    </span>&#123;</span><br><span class=\"line\">        Parser = parser;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">BeforeVisitor</span>(<span class=\"params\">StreamWriter writer, ISarcasmVisitor visitor</span>) </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> ISarcasmVisitor <span class=\"title\">MakeVisitor</span>(<span class=\"params\">StreamWriter writer</span>)</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">AfterVisitor</span>(<span class=\"params\">StreamWriter writer, ISarcasmVisitor visitor</span>) </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">Generate</span>(<span class=\"params\">StreamReader sourceStream, StreamWriter targetStream</span>)</span><br><span class=\"line\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Parse first</span></span><br><span class=\"line\">        Parser.Parse(sourceStream);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Parser.IsValid)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> visitor = MakeVisitor(targetStream);</span><br><span class=\"line\">            BeforeVisitor(targetStream, visitor);</span><br><span class=\"line\">            <span class=\"comment\">// Visit AST</span></span><br><span class=\"line\">            Parser.Document.Accept(visitor);</span><br><span class=\"line\">            AfterVisitor(targetStream, visitor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        targetStream.Flush();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Parser.IsValid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"MarkDown_Generation\"><a href=\"#MarkDown_Generation\" class=\"headerlink\" title=\"MarkDown Generation\"></a>MarkDown Generation</h2><p>MarkDown generation for Sarcasm is very straight forward, since the syntax is in MarkDown. All I need to do is remove comment delimiters, add correct amount of line endings, format grammar rule into block and escape some special characters.</p>\n<p>Again I won’t bother with the details here. Just see <a href=\"https://github.com/akfish/Sarcasm/blob/develop/Sarcasm/Generator/MarkDownGenerator.cs\" target=\"_blank\" rel=\"external\">the code</a> for yourself.</p>\n<h2 id=\"Something_Fun_with_Visualization\"><a href=\"#Something_Fun_with_Visualization\" class=\"headerlink\" title=\"Something Fun with Visualization\"></a>Something Fun with Visualization</h2><p>The original plan was to start generate C# parser class from here. Then I found an interesting project <a href=\"http://arborjs.org\" target=\"_blank\" rel=\"external\">arbor.js</a> (especially its <a href=\"http://arborjs.org/halfviz/\" target=\"_blank\" rel=\"external\">halfviz</a> demo) and decided to do something fun with it. The idea is to make a better tool for debug. What debug information is better than a visualized one?</p>\n<p>The halfviz demo converts a simple language called HalfTone to a node network. With the generator framework in place, it took me less than half an hour to <a href=\"https://github.com/akfish/Sarcasm/blob/feature/Visualization/Sarcasm/Generator/HalfToneGenerator.cs\" target=\"_blank\" rel=\"external\">generate node</a> representation from Sarcasm grammar source file. This can be used to visualize references between terminals and non-terminals:</p>\n<p><a href=\"http://catx.me/wordpress/wp-content/uploads/2014/02/vis.png\"><img src=\"/images/4be5b8b991d3bcafb280141940e1291eedbaf612.png\" alt=\"sarcasm-vis\"></a></p>\n<p>You can play with it live <a href=\"http://arborjs.org/halfviz/#/NjM0OA\" target=\"_blank\" rel=\"external\">here</a>. It looks more confusing in this form, for now. But with some interaction (filtering, folding, highlighting for example), it can help develops quickly navigate though the grammar.<br>Here’s another concept of how to visualize grammar related errors in this form (click to enlarge):<br><a href=\"http://catx.me/wordpress/wp-content/uploads/2014/02/concept.png\"><img src=\"/images/a645da29630a43fdaaedfc76d6a683eeeb522ebf.png\" alt=\"sarcasm-concept\"></a></p>\n<p>Imagine view build errors in Visual Studio with this graph and navigate to the line that is responsible by click on the node. I definitely will try to create something like that later when I begin to make tool chain for Sarcasm.</p>\n","date":"2014-02-27T18:46:18.000Z","path":"2014/02/28/the-making-of-sarcasm-2-ast-generators-and-fun-with-visualization/","isDark":true,"featureColor":"#3838a4","featureImage":"/image/stock/2.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#3838a4","isDark":true,"contrast":11.34232025151814},"Muted":{"color":"#5b5c4b","isDark":true,"contrast":13.55058952563751},"DarkVibrant":{"color":"#392d1b","isDark":true,"contrast":16.396358734600554},"DarkMuted":{"color":"#6a6256","isDark":true,"contrast":10.115562350289883},"LightVibrant":{"color":"#e8dbc6","isDark":false,"contrast":1.3654796219696164},"LightMuted":{"color":"#afabaf","isDark":false,"contrast":2.266109189190235}},"permalink":"http://catx.me/2014/02/28/the-making-of-sarcasm-2-ast-generators-and-fun-with-visualization/","json":"data/posts/2014/02/28/the-making-of-sarcasm-2-ast-generators-and-fun-with-visualization.json","tags":[{"name":".Net","slug":"Net","path":"tags/Net/","permalink":"http://catx.me/tags/Net/","postCount":4},{"name":"C++","slug":"C","path":"tags/C/","permalink":"http://catx.me/tags/C/","postCount":2},{"name":"Markdown","slug":"Markdown","path":"tags/Markdown/","permalink":"http://catx.me/tags/Markdown/","postCount":1},{"name":"Sarcasm","slug":"Sarcasm","path":"tags/Sarcasm/","permalink":"http://catx.me/tags/Sarcasm/","postCount":1},{"name":"compiler","slug":"compiler","path":"tags/compiler/","permalink":"http://catx.me/tags/compiler/","postCount":4}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":17}]}}
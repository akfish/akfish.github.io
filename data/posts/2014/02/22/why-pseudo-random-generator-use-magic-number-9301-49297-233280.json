{"type":"post","json_base":"data/posts","json":"data/posts/2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280.json","path":"2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280/","data":{"title":"JavaScript随机数生成算法中为什么要用9301, 49297, 233280作为Magic Number","content":"<p>今天在知乎上回答了这样一个问题：<a href=\"http://www.zhihu.com/question/22818104\" target=\"_blank\" rel=\"external\">网上常能见到的一段JS随机数生成算法如下，为什么用9301, 49297, 233280这三个数字做基数？</a></p>\n<p>问题中提到的代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rnd</span>(<span class=\"params\"> seed </span>)</span>&#123;</span><br><span class=\"line\">    seed = ( seed * <span class=\"number\">9301</span> + <span class=\"number\">49297</span> ) % <span class=\"number\">233280</span>; <span class=\"comment\">//Magic!</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> seed / ( <span class=\"number\">233280.0</span> );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rand</span>(<span class=\"params\">number</span>)</span>&#123;</span><br><span class=\"line\">    today = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); </span><br><span class=\"line\">    seed = today.getTime();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.ceil( rnd( seed ) * number );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myNum=(rand(<span class=\"number\">5</span>));</span><br></pre></td></tr></table></figure></p>\n<p>经过一系列的digging，最终找到了这个问题的答案，这三个数的选择是有数学依据的。</p>\n<p><strong>入门级的选择标准</strong><br>这种随机数生成器叫做线性同余生成器（LCG, Linear Congruential Generator)，几乎所有的运行库提供的rand都是采用的LCG，形如：<br><span>$I_{n+1}=aI_n + c\\ (mod\\ m)$</span><!-- Has MathJax --><br>生成的随机数序列最大周期m，生成0到m-1之间的随机数。要达到这个最大周期，必须满足</p>\n<ul>\n<li>c与m互质</li>\n<li>a - 1可以被m的所有质因数整除</li>\n<li>如果m是4的倍数，a - 1也必须是4的倍数<br>以上三条被称为Hull-Dobell定理。<br>作为一个随机数生成器，周期不够大是不好意思混的，所以这是要求之一。<br>可以看到，a=9301, c = 49297, m = 233280这组参数，以上三条全部满足。</li>\n</ul>\n<p><strong>进阶级的选择标准</strong><br>要在随机数生成器界混，仅仅入门是不够的。<br>从工程的角度来讲，$(m - 1)a + c$的值要（在合理的范围内）足够小，以避免溢出的问题。<br>从安全（实用）性的角度来讲，还要满足良好的随机性，这一点可以通过Knunth’s Spectral Test来评估（见[2]），要通过2,3,4,5以及6维的Spectral Test才行。Spectral Test考察的就是生成的随机数序列在超空间的网格结构（lattice structure），当年IBM的RANDU子程序闹出的乌龙，连3维的Spectral Test就不能通过，上图嘲讽下：</p>\n<p><a href=\"http://catx.me/wordpress/wp-content/uploads/2014/02/800px-Randu.png\"><img src=\"/images/bb1858cc61e6b2f8335f68221d141e0f5b289d68.png\" alt=\"800px-Randu\"></a></p>\n<p>其中每个点代表三个连续的RANDU生成的随机数值，可以看到所有随机数分布在了15个二维平面上。</p>\n<p>在这种要求面前，c的值最好：</p>\n<ul>\n<li>是质数 （c = 49297就是质数）</li>\n<li>接近<span>$(\\frac{1}{2}-\\frac{1}{6}\\sqrt{3})m$</span><!-- Has MathJax -->,(m = 233280时为49297.86460172205)<br>所以有了这样一些基本的标准，能够选择的参数范围就小了很多，弄个程序跑下Spectral Test，就能得到可选的参数组：</li>\n</ul>\n<p><a href=\"http://catx.me/wordpress/wp-content/uploads/2014/02/Unnamed-QQ-Screenshot20140222141315.png\"><img src=\"/images/5733d329521f86f7a2d59b5dc895f027ca119a83.png\" alt=\"Magic Number for LCG Random Generator\"></a></p>\n<p>参考资料：<a href=\"http://nuclear.fis.ucm.es/COMP-PHYS/RANDOM/RandomNumbers.pdf\" target=\"_blank\" rel=\"external\">[1]</a><a href=\"http://random.mat.sbg.ac.at/tests/theory/spectral/\" target=\"_blank\" rel=\"external\">[2]</a></p>\n","date":"2014-02-22T07:01:45.000Z","path":"2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280/","isDark":true,"featureColor":"#2f5a75","featureImage":"/image/stock/2.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#2f5a75","isDark":true,"contrast":12.293085300100254},"Muted":{"color":"#64767c","isDark":true,"contrast":5.234975288978602},"DarkVibrant":{"color":"#1f4b68","isDark":true,"contrast":13.414009026295917},"DarkMuted":{"color":"#477084","isDark":true,"contrast":5.611238656641319},"LightVibrant":{"color":"#ecdabf","isDark":false,"contrast":1.3683052639522741},"LightMuted":{"color":"#95b1b5","isDark":false,"contrast":2.274202152883682}},"json":"data/posts/2014/02/22/why-pseudo-random-generator-use-magic-number-9301-49297-233280.json","tags":[{"name":"Algorithm","slug":"Algorithm","path":"tags/Algorithm/","permalink":"http://catx.me/tags/Algorithm/","postCount":2},{"name":"Magic Number","slug":"Magic-Number","path":"tags/Magic-Number/","permalink":"http://catx.me/tags/Magic-Number/","postCount":1},{"name":"Math","slug":"Math","path":"tags/Math/","permalink":"http://catx.me/tags/Math/","postCount":1},{"name":"Random","slug":"Random","path":"tags/Random/","permalink":"http://catx.me/tags/Random/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]},"sha1":"fa4896b1cf1890f5b164fd87baa6b6de55f83594","prev":{"title":"用批处理在Windows下实现sudo命令","content":"<p>在Windows下运行某些命令的时候，必须要管理员权限。每次要重新选择“以管理员权限运行”很不方便而且没有效率，于是写了一个批处理文件，实现类似Linux下的sudo命令。</p>\n<p>保存为sudo.bat，放在环境变量PATH中指定的任意一个文件夹下，在命令行窗口中输入：</p>\n<blockquote>\n<p>sudo [command line]</p>\n</blockquote>\n<p>就会出现UAC对话框，确认后就会以管理员权限执行指定的命令。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Echo off&#10;:: Check for permissions&#10;&#38;gt;nul 2&#38;gt;&#38;amp;1 &#34;%SYSTEMROOT%\\system32\\cacls.exe&#34; &#34;%SYSTEMROOT%\\system32\\config\\system&#34;&#10;&#10;:: If error flag set, we do not have admin.&#10;if &#39;%errorlevel%&#39; NEQ &#39;0&#39; (&#10;Echo Requesting administrative privileges...&#10;goto UACPrompt&#10;) else ( goto gotAdmin )&#10;&#10;:UACPrompt&#10;Echo Set UAC = CreateObject^(&#34;Shell.Application&#34;^) &#38;gt; &#34;%temp%\\getadmin.vbs&#34;&#10;Echo UAC.ShellExecute &#34;%~s0&#34;, &#34;%*&#34;, &#34;&#34;, &#34;runas&#34;, 1 &#38;gt;&#38;gt; &#34;%temp%\\getadmin.vbs&#34;&#10;&#10;&#34;%temp%\\getadmin.vbs&#34;&#10;Exit &#10;&#10;:gotAdmin&#10;if exist &#34;%temp%\\getadmin.vbs&#34; ( Del &#34;%temp%\\getadmin.vbs&#34; )&#10;Pushd &#34;%CD%&#34;&#10;CD /D &#34;%~dp0&#34;&#10;:--------------------------------------&#10;cmd.exe /k %*</span><br></pre></td></tr></table></figure>\n<p>类似的也可以用ls.bat来模拟Linux的ls命令，就不用担心习惯ls手抖打错了：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@echo off&#10;dir %*</span><br></pre></td></tr></table></figure>\n","date":"2012-05-11T04:00:43.000Z","path":"2012/05/11/windows-sudo-batch/","isDark":true,"featureColor":"#266cb4","featureImage":"/image/stock/1.jpg","excerpt":"<p>在Windows下运行某些命令的时候，必须要管理员权限。每次要重新选择“以管理员权限运行”很不方便而且没有效率，于是写了一个批处理文件，实现类似Linux下的sudo命令。</p>\n<p>保存为sudo.bat，放在环境变量PATH中指定的任意一个文件夹下，在命令行窗口中输入：</p>\n<blockquote>\n<p>sudo [command line]</p>\n</blockquote>\n<p>就会出现UAC对话框，确认后就会以管理员权限执行指定的命令。</p>","featureSwatch":{"Vibrant":{"color":"#266cb4","isDark":true,"contrast":5.450121616568956},"Muted":{"color":"#4b70a6","isDark":true,"contrast":5.296212493095912},"DarkVibrant":{"color":"#3260a1","isDark":true,"contrast":10.521199995853594},"DarkMuted":{"color":"#515787","isDark":true,"contrast":11.462157427934459},"LightVibrant":{"color":"#5791c6","isDark":true,"contrast":3.512948192359975},"LightMuted":{"color":"#9bb4cc","isDark":false,"contrast":2.144138719552091}},"json":"data/posts/2012/05/11/windows-sudo-batch.json","tags":[{"name":"Linux","slug":"Linux","path":"tags/Linux/","permalink":"http://catx.me/tags/Linux/","postCount":1},{"name":"sudo","slug":"sudo","path":"tags/sudo/","permalink":"http://catx.me/tags/sudo/","postCount":1},{"name":"命令行","slug":"命令行","path":"tags/命令行/","permalink":"http://catx.me/tags/命令行/","postCount":1},{"name":"管理","slug":"管理","path":"tags/管理/","permalink":"http://catx.me/tags/管理/","postCount":1}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]},"next":{"title":"Visual Studio GPLEX/GPPG配置","content":"<p>入手实现Coffee#（CoffeeScript for .Net）的编译器时，发现了<a href=\"http://gplex.codeplex.com\" target=\"_blank\" rel=\"external\">GPLEX</a>和<a href=\"http://gppg.codeplex.com/\" target=\"_blank\" rel=\"external\">GPPG</a>这一对.Net环境下类Lex和Yacc的工具，用于自动生成C#实现的Scanner和Parser，可以快速的构建编译器的前端部分。使用时需要编写.lex（词法描述）和.y（语法描述）文件，调用工具生成.cs文件，加入到工程中编译。</p>\n<p>通过修改csproject文件的配置，可以让vs自动处理.lex/.y文件的生成以及依赖关系。工程目录结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CoffeeSharp&#10; &#9500;&#9472;documents&#10; &#9500;&#9472;src&#10; &#9474; &#9492;&#9472;CoffeeSharp&#10; &#9474; &#9500;&#9472;CoffeeSharp.csproj&#10; &#9474; &#9500;&#9472;Scanner.lex&#10; &#9474; &#9500;&#9472;Scanner.cs&#10; &#9474; &#9500;&#9472;Parser.y&#10; &#9474; &#9500;&#9472;Parser.cs&#10; &#9474; &#9492;&#9472;...&#10; &#9492;&#9472;tools&#10; &#9500;&#9472;gppg.exe&#10; &#9492;&#9472;gplex.exe</span><br></pre></td></tr></table></figure>\n<p>编辑CoffeeScript.csproj文件：</p>\n<p>1. 添加依赖关系：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;lt;!-- Generated with GPLEX and GPPG--&amp;gt;</span><br><span class=\"line\">&amp;lt;ItemGroup&amp;gt;</span><br><span class=\"line\">  &amp;lt;Compile Include=\"Scanner.cs\"&amp;gt;</span><br><span class=\"line\">    &amp;lt;AutoGen&amp;gt;True&amp;lt;/AutoGen&amp;gt;</span><br><span class=\"line\">    &amp;lt;DependentUpon&amp;gt;Scanner.lex&amp;lt;/DependentUpon&amp;gt;</span><br><span class=\"line\">  &amp;lt;/Compile&amp;gt;</span><br><span class=\"line\">  &amp;lt;Compile Include=\"Parser.cs\"&amp;gt;</span><br><span class=\"line\">    &amp;lt;AutoGen&amp;gt;True&amp;lt;/AutoGen&amp;gt;</span><br><span class=\"line\">    &amp;lt;DependentUpon&amp;gt;Parser.y&amp;lt;/DependentUpon&amp;gt;</span><br><span class=\"line\">  &amp;lt;/Compile&amp;gt;</span><br><span class=\"line\">&amp;lt;/ItemGroup&amp;gt;</span><br></pre></td></tr></table></figure>\n<p>2. 创建Lex/Yacc Target（修改原有的.lex/.y文件项）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;lt;!-- Lexer And Parser Specification Files --&amp;gt;</span><br><span class=\"line\">&amp;lt;ItemGroup&amp;gt;</span><br><span class=\"line\">  &amp;lt;Lex Include=\"Scanner.lex\" /&amp;gt;</span><br><span class=\"line\">  &amp;lt;Yacc Include=\"Parser.y\" /&amp;gt;</span><br><span class=\"line\">&amp;lt;/ItemGroup&amp;gt;</span><br></pre></td></tr></table></figure>\n<p>3. 设置Target生成规则，命令行根据实际情况修改</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;lt;!-- Lex Target --&amp;gt;</span><br><span class=\"line\">&amp;lt;Target Name=\"LexGenerator\" Inputs=\"@(Lex)\" Outputs=\"@(Lex-&amp;gt;'%(RelativeDir)%(Filename).cs')\"&amp;gt;</span><br><span class=\"line\">  &amp;lt;Exec Command=\"$(SolutionDir)..\\tools\\gplex.exe /unicode /out:@(Lex -&amp;gt;'%(RelativeDir)%(Filename).cs') %(Lex.Identity)\" /&amp;gt;</span><br><span class=\"line\">  &amp;lt;CreateItem Include=\"%(Lex.RelativeDir)%(Lex.Filename).cs\"&amp;gt;</span><br><span class=\"line\">    &amp;lt;Output TaskParameter=\"Include\" ItemName=\"FileWrites\" /&amp;gt;</span><br><span class=\"line\">  &amp;lt;/CreateItem&amp;gt;</span><br><span class=\"line\">&amp;lt;/Target&amp;gt;</span><br><span class=\"line\">&amp;lt;!-- Yacc Target --&amp;gt;</span><br><span class=\"line\">&amp;lt;Target Name=\"YaccGenerator\" Inputs=\"@(Yacc)\" Outputs=\"@(Yacc-&amp;gt;'%(RelativeDir)%(Filename).cs')\"&amp;gt;</span><br><span class=\"line\">  &amp;lt;Exec Command=\"$(SolutionDir)..\\tools\\gppg.exe /gplex /out:@(Yacc -&amp;gt;'%(RelativeDir)%(Filename).cs') %(Yacc.Identity)\" /&amp;gt;</span><br><span class=\"line\">  &amp;lt;CreateItem Include=\"%(Yacc.RelativeDir)%(Yacc.Filename).cs\"&amp;gt;</span><br><span class=\"line\">    &amp;lt;Output TaskParameter=\"Include\" ItemName=\"FileWrites\" /&amp;gt;</span><br><span class=\"line\">  &amp;lt;/CreateItem&amp;gt;</span><br><span class=\"line\">&amp;lt;/Target&amp;gt;</span><br></pre></td></tr></table></figure>\n<p>4. 设置依赖关系</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;lt;PropertyGroup&amp;gt;</span><br><span class=\"line\">    &amp;lt;BuildDependsOn&amp;gt;LexGenerator;YaccGenerator;$(BuildDependsOn)&amp;lt;/BuildDependsOn&amp;gt;</span><br><span class=\"line\">    &amp;lt;CompileDependsOn&amp;gt;LexGenerator;YaccGenerator;$(CompileDependsOn)&amp;lt;/CompileDependsOn&amp;gt;</span><br><span class=\"line\">  &amp;lt;/PropertyGroup&amp;gt;</span><br></pre></td></tr></table></figure>\n<p>重新载入工程文件，会看到生成的.cs文件都折叠在了对应的.lex/.y文件之下：</p>\n<p><a href=\"http://catx.me/wordpress/wp-content/uploads/2014/02/yacc-lex-config.png\"><img src=\"/images/664de6c412578efb10f8d11276fe46b559eceace.png\" alt=\"yacc-lex-config\"></a></p>\n<p>编译时的错误信息也会显示在vs中：</p>\n<p><a href=\"http://catx.me/wordpress/wp-content/uploads/2014/02/lex-error.png\"><img src=\"/images/757c2a223d238b4ef3fa0349d6be0704996d7330.png\" alt=\"lex-error\"></a></p>\n<p>和使用pre-build event来实现预编译相比，这种方式最大的优点在于依赖关系明显，不易误操作编辑生成的文件，并且vs只会在.lex/.y文件有变更的情况下重新生成代码。支持按需生成会省不少事，比如在项目中配置了git pre-commit hook要求<a href=\"http://catx.me/2014/01/15/run-msbuild-and-mstest-from-git-pre-commit-hook/\" title=\"通过Git Pre-Commit Hook执行MSBuild和MSTest\">每次commit前检查build和test的正确性</a>，而很多代码自动生成工具会加上时间戳，这样编译一次就会带来文件变更，导致每次commit后都会产生新的diff。</p>\n","date":"2014-02-07T21:10:49.000Z","path":"2014/02/08/visual-studio-gplex-gppg-project-config/","isDark":true,"featureColor":"#2b6a7d","featureImage":"/image/stock/3.jpg","excerpt":"","featureSwatch":{"Vibrant":{"color":"#2b6a7d","isDark":true,"contrast":6.152506571402196},"Muted":{"color":"#628d9b","isDark":true,"contrast":3.8818866665042275},"DarkVibrant":{"color":"#08536a","isDark":true,"contrast":13.30121420712154},"DarkMuted":{"color":"#4d7e8e","isDark":true,"contrast":4.693454244598322},"LightVibrant":{"color":"#74d4e4","isDark":false,"contrast":1.7100585291773622},"LightMuted":{"color":"#769ca9","isDark":false,"contrast":2.958324937392382}},"json":"data/posts/2014/02/08/visual-studio-gplex-gppg-project-config.json","tags":[{"name":".Net","slug":"Net","path":"tags/Net/","permalink":"http://catx.me/tags/Net/","postCount":5},{"name":"CoffeeScript","slug":"CoffeeScript","path":"tags/CoffeeScript/","permalink":"http://catx.me/tags/CoffeeScript/","postCount":9},{"name":"Visual Studio 2012","slug":"Visual-Studio-2012","path":"tags/Visual-Studio-2012/","permalink":"http://catx.me/tags/Visual-Studio-2012/","postCount":2},{"name":"compiler","slug":"compiler","path":"tags/compiler/","permalink":"http://catx.me/tags/compiler/","postCount":5}],"categories":[{"name":"挨踢","slug":"挨踢","path":"categories/挨踢/","permalink":"http://catx.me/categories/挨踢/","postCount":24}]}}